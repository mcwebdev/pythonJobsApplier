{
    "sourceFile": "job_application_automator.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 121,
            "patches": [
                {
                    "date": 1726887760936,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1726890000550,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,119 @@\n+# job_application_automator.py\r\n+\r\n+import configparser\r\n+import logging\r\n+import time\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+\r\n+# Load configuration\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(filename='application_log.txt', level=logging.INFO)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Initialize the WebDriver\r\n+driver = webdriver.Chrome(options=chrome_options)\r\n+\r\n+# Maximize window\r\n+driver.maximize_window()\r\n+\r\n+def login_to_dice():\r\n+    driver.get('https://www.dice.com/dashboard/login')\r\n+    time.sleep(3)\r\n+    \r\n+    # Locate the email field by name\r\n+    email_field = driver.find_element(By.NAME, 'email')\r\n+    email_field.clear()\r\n+    email_field.send_keys(EMAIL)\r\n+    \r\n+    # Locate the \"Continue\" button by its text or another attribute\r\n+    continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+    continue_button.click()\r\n+    time.sleep(3)\r\n+    \r\n+    # After clicking continue, locate the password field and enter the password\r\n+    password_field = driver.find_element(By.NAME, 'password')\r\n+    password_field.clear()\r\n+    password_field.send_keys(PASSWORD)\r\n+    \r\n+    # Locate the \"Sign In\" button and click it\r\n+    sign_in_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Sign In\")]')\r\n+    sign_in_button.click()\r\n+    time.sleep(5)\r\n+\r\n+def apply_to_job(job_link):\r\n+    driver.get(job_link)\r\n+    time.sleep(2)  # Wait for the page to load\r\n+\r\n+    try:\r\n+        # Find the 'Apply' button; update the XPath if necessary\r\n+        apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n+        apply_button.click()\r\n+        time.sleep(2)\r\n+\r\n+        # Upload resume\r\n+        upload_field = driver.find_element(By.NAME, 'resume')\r\n+        upload_field.send_keys(RESUME_PATH)\r\n+        time.sleep(2)\r\n+\r\n+        # Submit application\r\n+        submit_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Submit\")]')\r\n+        submit_button.click()\r\n+        logging.info(f'Successfully applied to {job_link}')\r\n+        print(f\"Successfully applied to {job_link}\")\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to {job_link}: {e}')\r\n+        print(f\"Failed to apply to {job_link}: {e}\")\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    # Enter search criteria\r\n+    driver.get('https://www.dice.com/')\r\n+    time.sleep(3)\r\n+    search_field = driver.find_element(By.ID, 'typeaheadInput')\r\n+    search_field.clear()\r\n+    search_field.send_keys(SEARCH_TERMS)\r\n+    search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+    search_button.click()\r\n+    time.sleep(5)\r\n+\r\n+    # Get the list of job postings\r\n+    jobs = driver.find_elements(By.XPATH, '//a[@data-cy=\"card-title-link\"]')\r\n+\r\n+    for index, job in enumerate(jobs):\r\n+        job_title = job.text\r\n+\r\n+        # Check if the job title contains both \"Angular\" and \"Senior Frontend Developer\"\r\n+        if 'Angular' in job_title and 'Senior Frontend Developer' in job_title:\r\n+            print(f\"Applying to job: {job_title}\")\r\n+            job_link = job.get_attribute('href')\r\n+            apply_to_job(job_link)\r\n+\r\n+            # Pause for specified duration before the next application\r\n+            print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+            time.sleep(PAUSE_DURATION)\r\n+        else:\r\n+            print(f\"Skipping job: {job_title}\")\r\n+\r\n+    print(\"Job application process completed.\")\r\n+\r\n+if __name__ == '__main__':\r\n+    try:\r\n+        main()\r\n+    finally:\r\n+        driver.quit()\r\n"
                },
                {
                    "date": 1726890334252,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n     password_field.clear()\r\n     password_field.send_keys(PASSWORD)\r\n     \r\n     # Locate the \"Sign In\" button and click it\r\n-    sign_in_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Sign In\")]')\r\n+    sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n     sign_in_button.click()\r\n     time.sleep(5)\r\n \r\n def apply_to_job(job_link):\r\n"
                },
                {
                    "date": 1726891037228,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,160 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    InvalidArgumentException,\r\n+    WebDriverException,\r\n+)\r\n+\r\n+# Load configuration\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(filename='application_log.txt', level=logging.INFO,\r\n+                    format='%(asctime)s:%(levelname)s:%(message)s')\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize window\r\n+driver.maximize_window()\r\n+\r\n+def login_to_dice():\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        time.sleep(3)\r\n+\r\n+        # Locate the email field by name\r\n+        email_field = driver.find_element(By.NAME, 'email')\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+\r\n+        # Locate the \"Continue\" button by its data-testid attribute\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        time.sleep(3)\r\n+\r\n+        # After clicking continue, locate the password field and enter the password\r\n+        password_field = driver.find_element(By.NAME, 'password')\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+\r\n+        # Locate the \"Sign In\" button and click it\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        time.sleep(5)\r\n+        \r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def apply_to_job(job_link, job_title):\r\n+    try:\r\n+        if not job_link or not isinstance(job_link, str):\r\n+            logging.error(f'Invalid job link for \"{job_title}\": {job_link}')\r\n+            print(f\"Invalid job link for \\\"{job_title}\\\": {job_link}\")\r\n+            return\r\n+\r\n+        driver.get(job_link)\r\n+        time.sleep(2)  # Wait for the page to load\r\n+\r\n+        # Find the 'Apply' button; update the XPath if necessary\r\n+        apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n+        apply_button.click()\r\n+        time.sleep(2)\r\n+\r\n+        # Upload resume\r\n+        upload_field = driver.find_element(By.NAME, 'resume')\r\n+        upload_field.send_keys(RESUME_PATH)\r\n+        time.sleep(2)\r\n+\r\n+        # Submit application\r\n+        submit_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Submit\")]')\r\n+        submit_button.click()\r\n+        logging.info(f'Successfully applied to {job_link}')\r\n+        print(f\"Successfully applied to {job_link}\")\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f'Element not found while applying to {job_link}: {e}')\r\n+        print(f\"Element not found while applying to {job_link}: {e}\")\r\n+    except InvalidArgumentException as e:\r\n+        logging.error(f'Invalid URL \"{job_link}\": {e}')\r\n+        print(f\"Invalid URL \\\"{job_link}\\\": {e}\")\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to {job_link}: {e}')\r\n+        print(f\"Failed to apply to {job_link}: {e}\")\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        time.sleep(3)\r\n+        search_field = driver.find_element(By.ID, 'typeaheadInput')\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        time.sleep(5)\r\n+\r\n+        # Get the list of job postings\r\n+        jobs = driver.find_elements(By.XPATH, '//a[@data-cy=\"card-title-link\"]')\r\n+        logging.info(f'Found {len(jobs)} job postings.')\r\n+        print(f'Found {len(jobs)} job postings.')\r\n+\r\n+        for index, job in enumerate(jobs):\r\n+            job_title = job.text.strip()\r\n+            job_link = job.get_attribute('href')\r\n+\r\n+            # Debugging: Log job titles and links\r\n+            logging.debug(f'Job {index + 1}: Title=\"{job_title}\", Link=\"{job_link}\"')\r\n+            print(f'Job {index + 1}: Title=\"{job_title}\", Link=\"{job_link}\"')\r\n+\r\n+            # Check if the job title contains both \"Angular\" and \"Senior Frontend Developer\"\r\n+            if 'Angular' in job_title and 'Senior Frontend Developer' in job_title:\r\n+                print(f\"Applying to job: {job_title}\")\r\n+                logging.info(f\"Applying to job: {job_title} | Link: {job_link}\")\r\n+                apply_to_job(job_link, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+                logging.info(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726891444733,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,19 @@\n import configparser\r\n import logging\r\n import time\r\n+import os\r\n from selenium import webdriver\r\n from selenium.webdriver.common.by import By\r\n from selenium.webdriver.chrome.options import Options\r\n from selenium.common.exceptions import (\r\n     NoSuchElementException,\r\n     InvalidArgumentException,\r\n     WebDriverException,\r\n+    TimeoutException,\r\n )\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n \r\n # Load configuration\r\n config = configparser.ConfigParser()\r\n config.read('config.ini')\r\n@@ -19,11 +23,19 @@\n PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n EMAIL = config['DEFAULT']['Email']\r\n PASSWORD = config['DEFAULT']['Password']\r\n \r\n+# Check if resume exists\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n # Configure logging\r\n-logging.basicConfig(filename='application_log.txt', level=logging.INFO,\r\n-                    format='%(asctime)s:%(levelname)s:%(message)s')\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n \r\n # Set up Chrome options\r\n chrome_options = Options()\r\n # Uncomment the following line to run the browser in headless mode\r\n@@ -42,105 +54,114 @@\n \r\n def login_to_dice():\r\n     try:\r\n         driver.get('https://www.dice.com/dashboard/login')\r\n-        time.sleep(3)\r\n+        wait = WebDriverWait(driver, 10)\r\n \r\n-        # Locate the email field by name\r\n-        email_field = driver.find_element(By.NAME, 'email')\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n         email_field.clear()\r\n         email_field.send_keys(EMAIL)\r\n \r\n-        # Locate the \"Continue\" button by its data-testid attribute\r\n+        # Locate and click the \"Continue\" button\r\n         continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n         continue_button.click()\r\n-        time.sleep(3)\r\n \r\n-        # After clicking continue, locate the password field and enter the password\r\n-        password_field = driver.find_element(By.NAME, 'password')\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n         password_field.clear()\r\n         password_field.send_keys(PASSWORD)\r\n \r\n-        # Locate the \"Sign In\" button and click it\r\n+        # Locate and click the \"Sign In\" button\r\n         sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n         sign_in_button.click()\r\n-        time.sleep(5)\r\n-        \r\n+\r\n+        # Wait until dashboard loads by checking URL or specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+\r\n         logging.info('Successfully logged into Dice.')\r\n         print(\"Successfully logged into Dice.\")\r\n-    except NoSuchElementException as e:\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error during login: {e}')\r\n         print(f\"Error during login: {e}\")\r\n         driver.quit()\r\n         exit(1)\r\n \r\n-def apply_to_job(job_link, job_title):\r\n+def apply_to_job(job_card, job_title):\r\n     try:\r\n-        if not job_link or not isinstance(job_link, str):\r\n-            logging.error(f'Invalid job link for \"{job_title}\": {job_link}')\r\n-            print(f\"Invalid job link for \\\"{job_title}\\\": {job_link}\")\r\n-            return\r\n-\r\n-        driver.get(job_link)\r\n-        time.sleep(2)  # Wait for the page to load\r\n-\r\n-        # Find the 'Apply' button; update the XPath if necessary\r\n-        apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n+        wait = WebDriverWait(driver, 10)\r\n+        \r\n+        # Find and click the 'Easy Apply' button within the job card\r\n+        apply_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Easy Apply\")]')\r\n         apply_button.click()\r\n-        time.sleep(2)\r\n-\r\n-        # Upload resume\r\n-        upload_field = driver.find_element(By.NAME, 'resume')\r\n+        logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+        print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+        \r\n+        # Wait for the resume upload field to be present\r\n+        upload_field = wait.until(EC.presence_of_element_located((By.NAME, 'resume')))\r\n         upload_field.send_keys(RESUME_PATH)\r\n-        time.sleep(2)\r\n-\r\n-        # Submit application\r\n-        submit_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Submit\")]')\r\n+        logging.info(f'Uploaded resume for job: {job_title}')\r\n+        print(f'Uploaded resume for job: {job_title}')\r\n+        \r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Submit\")]')))\r\n         submit_button.click()\r\n-        logging.info(f'Successfully applied to {job_link}')\r\n-        print(f\"Successfully applied to {job_link}\")\r\n+        logging.info(f'Successfully applied to {job_title}')\r\n+        print(f\"Successfully applied to {job_title}\")\r\n+        \r\n+        # Optionally, wait for a confirmation message or element\r\n+        # wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+        \r\n     except NoSuchElementException as e:\r\n-        logging.error(f'Element not found while applying to {job_link}: {e}')\r\n-        print(f\"Element not found while applying to {job_link}: {e}\")\r\n-    except InvalidArgumentException as e:\r\n-        logging.error(f'Invalid URL \"{job_link}\": {e}')\r\n-        print(f\"Invalid URL \\\"{job_link}\\\": {e}\")\r\n+        logging.error(f'Element not found while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not found while applying to \"{job_title}\": {e}')\r\n+    except TimeoutException as e:\r\n+        logging.error(f'Timeout while applying to \"{job_title}\": {e}')\r\n+        print(f'Timeout while applying to \"{job_title}\": {e}')\r\n     except Exception as e:\r\n-        logging.error(f'Failed to apply to {job_link}: {e}')\r\n-        print(f\"Failed to apply to {job_link}: {e}\")\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n \r\n def main():\r\n     login_to_dice()\r\n \r\n     try:\r\n         # Enter search criteria\r\n         driver.get('https://www.dice.com/')\r\n-        time.sleep(3)\r\n-        search_field = driver.find_element(By.ID, 'typeaheadInput')\r\n+        wait = WebDriverWait(driver, 10)\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n         search_field.clear()\r\n         search_field.send_keys(SEARCH_TERMS)\r\n         search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n         search_button.click()\r\n-        time.sleep(5)\r\n \r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card search-card\")]')))\r\n+\r\n         # Get the list of job postings\r\n-        jobs = driver.find_elements(By.XPATH, '//a[@data-cy=\"card-title-link\"]')\r\n-        logging.info(f'Found {len(jobs)} job postings.')\r\n-        print(f'Found {len(jobs)} job postings.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n \r\n-        for index, job in enumerate(jobs):\r\n-            job_title = job.text.strip()\r\n-            job_link = job.get_attribute('href')\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title\r\n+                title_element = job_card.find_element(By.XPATH, './/h5/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+                continue\r\n \r\n-            # Debugging: Log job titles and links\r\n-            logging.debug(f'Job {index + 1}: Title=\"{job_title}\", Link=\"{job_link}\"')\r\n-            print(f'Job {index + 1}: Title=\"{job_title}\", Link=\"{job_link}\"')\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n \r\n             # Check if the job title contains both \"Angular\" and \"Senior Frontend Developer\"\r\n             if 'Angular' in job_title and 'Senior Frontend Developer' in job_title:\r\n                 print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title} | Link: {job_link}\")\r\n-                apply_to_job(job_link, job_title)\r\n+                logging.info(f\"Applying to job: {job_title}\")\r\n+                apply_to_job(job_card, job_title)\r\n \r\n                 # Pause for specified duration before the next application\r\n                 print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n                 time.sleep(PAUSE_DURATION)\r\n@@ -157,231 +178,4 @@\n         driver.quit()\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-# job_application_automator.py\r\n-\r\n-import configparser\r\n-import logging\r\n-import time\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-\r\n-# Load configuration\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(filename='application_log.txt', level=logging.INFO)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Initialize the WebDriver\r\n-driver = webdriver.Chrome(options=chrome_options)\r\n-\r\n-# Maximize window\r\n-driver.maximize_window()\r\n-\r\n-def login_to_dice():\r\n-    driver.get('https://www.dice.com/dashboard/login')\r\n-    time.sleep(3)\r\n-    \r\n-    # Locate the email field by name\r\n-    email_field = driver.find_element(By.NAME, 'email')\r\n-    email_field.clear()\r\n-    email_field.send_keys(EMAIL)\r\n-    \r\n-    # Locate the \"Continue\" button by its text or another attribute\r\n-    continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-    continue_button.click()\r\n-    time.sleep(3)\r\n-    \r\n-    # After clicking continue, locate the password field and enter the password\r\n-    password_field = driver.find_element(By.NAME, 'password')\r\n-    password_field.clear()\r\n-    password_field.send_keys(PASSWORD)\r\n-    \r\n-    # Locate the \"Sign In\" button and click it\r\n-    sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-    sign_in_button.click()\r\n-    time.sleep(5)\r\n-\r\n-def apply_to_job(job_link):\r\n-    driver.get(job_link)\r\n-    time.sleep(2)  # Wait for the page to load\r\n-\r\n-    try:\r\n-        # Find the 'Apply' button; update the XPath if necessary\r\n-        apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n-        apply_button.click()\r\n-        time.sleep(2)\r\n-\r\n-        # Upload resume\r\n-        upload_field = driver.find_element(By.NAME, 'resume')\r\n-        upload_field.send_keys(RESUME_PATH)\r\n-        time.sleep(2)\r\n-\r\n-        # Submit application\r\n-        submit_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Submit\")]')\r\n-        submit_button.click()\r\n-        logging.info(f'Successfully applied to {job_link}')\r\n-        print(f\"Successfully applied to {job_link}\")\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to {job_link}: {e}')\r\n-        print(f\"Failed to apply to {job_link}: {e}\")\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    # Enter search criteria\r\n-    driver.get('https://www.dice.com/')\r\n-    time.sleep(3)\r\n-    search_field = driver.find_element(By.ID, 'typeaheadInput')\r\n-    search_field.clear()\r\n-    search_field.send_keys(SEARCH_TERMS)\r\n-    search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-    search_button.click()\r\n-    time.sleep(5)\r\n-\r\n-    # Get the list of job postings\r\n-    jobs = driver.find_elements(By.XPATH, '//a[@data-cy=\"card-title-link\"]')\r\n-\r\n-    for index, job in enumerate(jobs):\r\n-        job_title = job.text\r\n-\r\n-        # Check if the job title contains both \"Angular\" and \"Senior Frontend Developer\"\r\n-        if 'Angular' in job_title and 'Senior Frontend Developer' in job_title:\r\n-            print(f\"Applying to job: {job_title}\")\r\n-            job_link = job.get_attribute('href')\r\n-            apply_to_job(job_link)\r\n-\r\n-            # Pause for specified duration before the next application\r\n-            print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-            time.sleep(PAUSE_DURATION)\r\n-        else:\r\n-            print(f\"Skipping job: {job_title}\")\r\n-\r\n-    print(\"Job application process completed.\")\r\n-\r\n-if __name__ == '__main__':\r\n-    try:\r\n-        main()\r\n-    finally:\r\n-        driver.quit()\r\n-# job_application_automator.py\r\n-\r\n-import configparser\r\n-import logging\r\n-import time\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-\r\n-# Load configuration\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(filename='application_log.txt', level=logging.INFO)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Initialize the WebDriver\r\n-driver = webdriver.Chrome(options=chrome_options)\r\n-\r\n-# Maximize window\r\n-driver.maximize_window()\r\n-\r\n-def login_to_dice():\r\n-    driver.get('https://www.dice.com/dashboard/login')\r\n-    time.sleep(3)\r\n-    email_field = driver.find_element(By.ID, 'email')\r\n-    email_field.clear()\r\n-    email_field.send_keys(EMAIL)\r\n-    password_field = driver.find_element(By.ID, 'password')\r\n-    password_field.clear()\r\n-    password_field.send_keys(PASSWORD)\r\n-    login_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Sign In\")]')\r\n-    login_button.click()\r\n-    time.sleep(5)\r\n-\r\n-def apply_to_job(job_link):\r\n-    driver.get(job_link)\r\n-    time.sleep(2)  # Wait for the page to load\r\n-\r\n-    try:\r\n-        # Find the 'Apply' button; update the XPath if necessary\r\n-        apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n-        apply_button.click()\r\n-        time.sleep(2)\r\n-\r\n-        # Upload resume\r\n-        upload_field = driver.find_element(By.NAME, 'resume')\r\n-        upload_field.send_keys(RESUME_PATH)\r\n-        time.sleep(2)\r\n-\r\n-        # Submit application\r\n-        submit_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Submit\")]')\r\n-        submit_button.click()\r\n-        logging.info(f'Successfully applied to {job_link}')\r\n-        print(f\"Successfully applied to {job_link}\")\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to {job_link}: {e}')\r\n-        print(f\"Failed to apply to {job_link}: {e}\")\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    # Enter search criteria\r\n-    driver.get('https://www.dice.com/')\r\n-    time.sleep(3)\r\n-    search_field = driver.find_element(By.ID, 'typeaheadInput')\r\n-    search_field.clear()\r\n-    search_field.send_keys(SEARCH_TERMS)\r\n-    search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-    search_button.click()\r\n-    time.sleep(5)\r\n-\r\n-    # Get the list of job postings\r\n-    jobs = driver.find_elements(By.XPATH, '//a[@data-cy=\"card-title-link\"]')\r\n-\r\n-    for index, job in enumerate(jobs):\r\n-        job_title = job.text\r\n-\r\n-        # Check if the job title contains both \"Angular\" and \"Senior Frontend Developer\"\r\n-        if 'Angular' in job_title and 'Senior Frontend Developer' in job_title:\r\n-            print(f\"Applying to job: {job_title}\")\r\n-            job_link = job.get_attribute('href')\r\n-            apply_to_job(job_link)\r\n-\r\n-            # Pause for specified duration before the next application\r\n-            print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-            time.sleep(PAUSE_DURATION)\r\n-        else:\r\n-            print(f\"Skipping job: {job_title}\")\r\n-\r\n-    print(\"Job application process completed.\")\r\n-\r\n-if __name__ == '__main__':\r\n-    try:\r\n-        main()\r\n-    finally:\r\n-        driver.quit()\r\n"
                },
                {
                    "date": 1726892096959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -137,16 +137,16 @@\n         # Wait until job listings are loaded\r\n         wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card search-card\")]')))\r\n \r\n         # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card search-card\")]')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"search-card\")]')\r\n         logging.info(f'Found {len(job_cards)} job postings.')\r\n         print(f'Found {len(job_cards)} job postings.')\r\n \r\n         for index, job_card in enumerate(job_cards, start=1):\r\n             try:\r\n                 # Extract the job title\r\n-                title_element = job_card.find_element(By.XPATH, './/h5/a[@data-cy=\"card-title-link\"]')\r\n+                title_element = job_card.find_element(By.XPATH, './/h5/a[@class=\"card-title-link\"]')\r\n                 job_title = title_element.text.strip()\r\n             except NoSuchElementException:\r\n                 logging.warning(f'Job {index}: Title element not found.')\r\n                 print(f'Job {index}: Title element not found.')\r\n"
                },
                {
                    "date": 1726892262904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -137,16 +137,16 @@\n         # Wait until job listings are loaded\r\n         wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card search-card\")]')))\r\n \r\n         # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"search-card\")]')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card search-card\")]')\r\n         logging.info(f'Found {len(job_cards)} job postings.')\r\n         print(f'Found {len(job_cards)} job postings.')\r\n \r\n         for index, job_card in enumerate(job_cards, start=1):\r\n             try:\r\n                 # Extract the job title\r\n-                title_element = job_card.find_element(By.XPATH, './/h5/a[@class=\"card-title-link\"]')\r\n+                title_element = job_card.find_element(By.XPATH, './/h5/a[@class=\"card-title-link normal viewed\"]')\r\n                 job_title = title_element.text.strip()\r\n             except NoSuchElementException:\r\n                 logging.warning(f'Job {index}: Title element not found.')\r\n                 print(f'Job {index}: Title element not found.')\r\n"
                },
                {
                    "date": 1726892444501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,191 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    InvalidArgumentException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# Load configuration\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize window\r\n+driver.maximize_window()\r\n+\r\n+def login_to_dice():\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+\r\n+        # Wait until dashboard loads by checking URL or specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def apply_to_job(job_card, job_title):\r\n+    try:\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+\r\n+        # Find and click the 'Easy Apply' button within the job card\r\n+        apply_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Easy Apply\")]')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+        print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+        # Wait for the modal to appear\r\n+        # Update the XPath based on the actual modal structure\r\n+        modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+        logging.debug(f'Modal appeared for job: {job_title}')\r\n+        print(f'Modal appeared for job: {job_title}')\r\n+\r\n+        # Wait for the resume upload field to be present within the modal\r\n+        # Update the XPath based on the actual upload field attributes\r\n+        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+        upload_field.send_keys(RESUME_PATH)\r\n+        logging.info(f'Uploaded resume for job: {job_title}')\r\n+        print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+        submit_button.click()\r\n+        logging.info(f'Successfully applied to {job_title}')\r\n+        print(f\"Successfully applied to {job_title}\")\r\n+\r\n+        # Optionally, wait for a confirmation message or element\r\n+        # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+        # logging.info(f'Application confirmed for job: {job_title}')\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')))\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+                \r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Check if the job title contains both \"Angular\" and \"Senior Frontend Developer\"\r\n+            if 'Angular' in job_title and 'Senior Frontend Developer' in job_title:\r\n+                print(f\"Applying to job: {job_title}\")\r\n+                logging.info(f\"Applying to job: {job_title}\")\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+                logging.info(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726892637519,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,22 +90,31 @@\n def apply_to_job(job_card, job_title):\r\n     try:\r\n         wait = WebDriverWait(driver, 15)  # Increased timeout\r\n \r\n-        # Find and click the 'Easy Apply' button within the job card\r\n-        apply_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Easy Apply\")]')\r\n+        # Find and click the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load (update XPath as necessary)\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Find and click the 'Easy Apply' button within the job details\r\n+        apply_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Easy Apply\")]')\r\n         apply_button.click()\r\n         logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n         print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n \r\n-        # Wait for the modal to appear\r\n-        # Update the XPath based on the actual modal structure\r\n+        # Wait for the modal to appear (update XPath based on actual modal structure)\r\n         modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n         logging.debug(f'Modal appeared for job: {job_title}')\r\n         print(f'Modal appeared for job: {job_title}')\r\n \r\n         # Wait for the resume upload field to be present within the modal\r\n-        # Update the XPath based on the actual upload field attributes\r\n         upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n         upload_field.send_keys(RESUME_PATH)\r\n         logging.info(f'Uploaded resume for job: {job_title}')\r\n         print(f'Uploaded resume for job: {job_title}')\r\n@@ -118,15 +127,37 @@\n \r\n         # Optionally, wait for a confirmation message or element\r\n         # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n         # logging.info(f'Application confirmed for job: {job_title}')\r\n+\r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error applying to \"{job_title}\": {e}')\r\n         print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Debugging: Print all available buttons' texts within the job details\r\n+        buttons = driver.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n     except Exception as e:\r\n         logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n         print(f'Failed to apply to \"{job_title}\": {e}')\r\n \r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n def main():\r\n     login_to_dice()\r\n \r\n     try:\r\n@@ -165,10 +196,11 @@\n             # Debugging: Log job titles\r\n             logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n             print(f'Job {index}: Title=\"{job_title}\"')\r\n \r\n-            # Check if the job title contains both \"Angular\" and \"Senior Frontend Developer\"\r\n-            if 'Angular' in job_title and 'Senior Frontend Developer' in job_title:\r\n+            # Define the criteria for applying\r\n+            criteria = ['Angular', 'Senior Frontend Developer']\r\n+            if all(keyword in job_title for keyword in criteria):\r\n                 print(f\"Applying to job: {job_title}\")\r\n                 logging.info(f\"Applying to job: {job_title}\")\r\n                 apply_to_job(job_card, job_title)\r\n \r\n"
                },
                {
                    "date": 1726892924688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,219 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    InvalidArgumentException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# Load configuration\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize window\r\n+driver.maximize_window()\r\n+\r\n+def login_to_dice():\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+\r\n+        # Wait until dashboard loads by checking URL or specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def apply_to_job(job_card, job_title):\r\n+    try:\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button\r\n+        try:\r\n+            apply_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Easy Apply\")]')\r\n+            apply_button.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+            # Proceed with uploading resume and submitting application\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found; likely already applied\r\n+            logging.info(f'\"Easy Apply\" not available for job: {job_title}. It may have already been applied to.')\r\n+            print(f'\"Easy Apply\" not available for job: {job_title}. Skipping application.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Debugging: Print all available buttons' texts within the job details\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')))\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+                \r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Define the criteria for applying\r\n+            criteria = ['Angular', 'Senior Frontend Developer']\r\n+            if all(keyword in job_title for keyword in criteria):\r\n+                print(f\"Applying to job: {job_title}\")\r\n+                logging.info(f\"Applying to job: {job_title}\")\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+                logging.info(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726893183174,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,208 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    InvalidArgumentException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# Load configuration\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize window\r\n+driver.maximize_window()\r\n+\r\n+def has_apply_now(job_card):\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+    button_texts = [button.text for button in buttons]\r\n+    logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+    print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+    # Capture a screenshot for visual debugging\r\n+    sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+    screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+    driver.save_screenshot(screenshot_path)\r\n+    logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+    print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+def apply_to_job(job_card, job_title):\r\n+    try:\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load (adjust the XPath based on actual DOM)\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Check if 'Apply now' button is present; if so, skip\r\n+        if has_apply_now(job_card):\r\n+            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button using the revised selector\r\n+        try:\r\n+            easy_apply_div = job_details.find_element(By.XPATH, './/div[@data-cy=\"card-easy-apply\"]')\r\n+            # Assuming clicking the div initiates the application\r\n+            easy_apply_div.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+            # Wait for the modal to appear (adjust the XPath based on actual modal structure)\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Modal appeared for job: {job_title}')\r\n+            print(f'Modal appeared for job: {job_title}')\r\n+\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found; likely already applied or not available\r\n+            logging.info(f'\"Easy Apply\" not available for job: {job_title}. It may have already been applied to.')\r\n+            print(f'\"Easy Apply\" not available for job: {job_title}. Skipping application.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')))\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Define the criteria for applying\r\n+            criteria = ['Angular', 'Senior Frontend Developer']\r\n+            if all(keyword in job_title for keyword in criteria):\r\n+                print(f\"Applying to job: {job_title}\")\r\n+                logging.info(f\"Applying to job: {job_title}\")\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+                logging.info(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726893288520,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,278 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    InvalidArgumentException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+# chrome_options.add_argument('--ignore-certificate-errors')\r\n+# chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(job_card):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+    button_texts = [button.text for button in buttons]\r\n+    logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+    print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+    # Capture a screenshot for visual debugging\r\n+    sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+    screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+    driver.save_screenshot(screenshot_path)\r\n+    logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+    print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+def apply_to_job(job_card, job_title):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" button.\r\n+    Skips if \"Easy Apply\" is not available or if \"Apply now\" is present.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load (adjust the XPath based on actual DOM)\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Check if 'Apply now' button is present; if so, skip\r\n+        if has_apply_now(job_card):\r\n+            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button using the revised selector\r\n+        try:\r\n+            easy_apply_div = job_details.find_element(By.XPATH, './/div[@data-cy=\"card-easy-apply\"]')\r\n+            # Assuming clicking the div initiates the application\r\n+            easy_apply_div.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+            # Wait for the modal to appear (adjust the XPath based on actual modal structure)\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Modal appeared for job: {job_title}')\r\n+            print(f'Modal appeared for job: {job_title}')\r\n+\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found; likely already applied or not available\r\n+            logging.info(f'\"Easy Apply\" not available for job: {job_title}. It may have already been applied to.')\r\n+            print(f'\"Easy Apply\" not available for job: {job_title}. Skipping application.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+# -----------------------------\r\n+# Main Execution Function\r\n+# -----------------------------\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Define the criteria for applying\r\n+            criteria = ['Angular', 'Senior Frontend Developer']\r\n+            if all(keyword in job_title for keyword in criteria):\r\n+                print(f\"Applying to job: {job_title}\")\r\n+                logging.info(f\"Applying to job: {job_title}\")\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+                logging.info(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726893609557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,8 @@\n from selenium.webdriver.common.by import By\r\n from selenium.webdriver.chrome.options import Options\r\n from selenium.common.exceptions import (\r\n     NoSuchElementException,\r\n-    InvalidArgumentException,\r\n     WebDriverException,\r\n     TimeoutException,\r\n )\r\n from selenium.webdriver.support.ui import WebDriverWait\r\n@@ -101,8 +100,46 @@\n         print(f\"Error during login: {e}\")\r\n         driver.quit()\r\n         exit(1)\r\n \r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+\r\n+        # Wait for the filter sidebar to load\r\n+        filter_sidebar = wait.until(EC.presence_of_element_located((By.ID, 'filterSidebar')))\r\n+\r\n+        # Locate the \"Easy Apply\" filter checkbox/button\r\n+        easy_apply_filter = filter_sidebar.find_element(\r\n+            By.XPATH, './/button[contains(@aria-label, \"Filter Search Results by Easy Apply\")]'\r\n+        )\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter.get_attribute('aria-checked')\r\n+        if aria_checked.lower() != 'true':\r\n+            easy_apply_filter.click()\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed\r\n+        else:\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f'Error locating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error locating \"Easy Apply\" filter: {e}')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except TimeoutException as e:\r\n+        logging.error(f'Timeout while activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Timeout while activating \"Easy Apply\" filter: {e}')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n def has_apply_now(job_card):\r\n     \"\"\"\r\n     Checks if a job card contains an \"Apply now\" button.\r\n     Returns True if present, False otherwise.\r\n@@ -130,10 +167,10 @@\n     print(f'Screenshot saved to {screenshot_path}')\r\n \r\n def apply_to_job(job_card, job_title):\r\n     \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" button.\r\n-    Skips if \"Easy Apply\" is not available or if \"Apply now\" is present.\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n     \"\"\"\r\n     try:\r\n         wait = WebDriverWait(driver, 15)  # Increased timeout\r\n \r\n@@ -142,9 +179,9 @@\n         title_element.click()\r\n         logging.info(f'Clicked on job title: {job_title}')\r\n         print(f'Clicked on job title: {job_title}')\r\n \r\n-        # Wait for the job details panel to load (adjust the XPath based on actual DOM)\r\n+        # Wait for the job details panel to load\r\n         job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         logging.debug(f'Job details loaded for: {job_title}')\r\n         print(f'Job details loaded for: {job_title}')\r\n \r\n@@ -178,8 +215,12 @@\n             submit_button.click()\r\n             logging.info(f'Successfully applied to {job_title}')\r\n             print(f\"Successfully applied to {job_title}\")\r\n \r\n+            # Optional: Wait for a confirmation message or element\r\n+            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+            # logging.info(f'Application confirmed for job: {job_title}')\r\n+\r\n         except NoSuchElementException:\r\n             # 'Easy Apply' button not found; likely already applied or not available\r\n             logging.info(f'\"Easy Apply\" not available for job: {job_title}. It may have already been applied to.')\r\n             print(f'\"Easy Apply\" not available for job: {job_title}. Skipping application.')\r\n@@ -218,8 +259,11 @@\n         search_field.send_keys(SEARCH_TERMS)\r\n         search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n         search_button.click()\r\n \r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n         # Wait until job listings are loaded\r\n         wait.until(EC.presence_of_all_elements_located(\r\n             (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n         ))\r\n"
                },
                {
                    "date": 1726894100886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,24 +107,27 @@\n     \"\"\"\r\n     try:\r\n         wait = WebDriverWait(driver, 15)  # Increased timeout\r\n \r\n-        # Wait for the filter sidebar to load\r\n-        filter_sidebar = wait.until(EC.presence_of_element_located((By.ID, 'filterSidebar')))\r\n+        # Wait for the filters widget to load\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n \r\n-        # Locate the \"Easy Apply\" filter checkbox/button\r\n-        easy_apply_filter = filter_sidebar.find_element(\r\n-            By.XPATH, './/button[contains(@aria-label, \"Filter Search Results by Easy Apply\")]'\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget\r\n+        easy_apply_accordion = filters_widget.find_element(By.XPATH, './/dhi-accordion[@data-cy=\"accordion-easyApply\"]')\r\n+\r\n+        # Within the \"Easy Apply\" accordion, locate the filter button\r\n+        easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+            By.XPATH, './/button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n         )\r\n \r\n         # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter.get_attribute('aria-checked')\r\n-        if aria_checked.lower() != 'true':\r\n-            easy_apply_filter.click()\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        if aria_checked and aria_checked.lower() != 'true':\r\n+            easy_apply_filter_button.click()\r\n             logging.info('\"Easy Apply\" filter activated.')\r\n             print('\"Easy Apply\" filter activated.')\r\n             # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n         else:\r\n             logging.info('\"Easy Apply\" filter is already active.')\r\n             print('\"Easy Apply\" filter is already active.')\r\n \r\n"
                },
                {
                    "date": 1726894302292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,31 +69,34 @@\n     Logs into Dice.com using the provided email and password.\r\n     \"\"\"\r\n     try:\r\n         driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n \r\n         # Wait for the email field to be present\r\n         email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n         email_field.clear()\r\n         email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n \r\n         # Locate and click the \"Continue\" button\r\n         continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n         continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n \r\n         # Wait for the password field to be present\r\n         password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n         password_field.clear()\r\n         password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n \r\n         # Locate and click the \"Sign In\" button\r\n         sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n         sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n \r\n         # Wait until dashboard loads by checking URL or a specific element\r\n         wait.until(EC.url_contains('/dashboard'))\r\n-\r\n         logging.info('Successfully logged into Dice.')\r\n         print(\"Successfully logged into Dice.\")\r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error during login: {e}')\r\n@@ -105,23 +108,32 @@\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     \"\"\"\r\n     try:\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n \r\n         # Wait for the filters widget to load\r\n         filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n \r\n         # Locate the \"Easy Apply\" accordion within the filters widget\r\n         easy_apply_accordion = filters_widget.find_element(By.XPATH, './/dhi-accordion[@data-cy=\"accordion-easyApply\"]')\r\n+        logging.info('\"Easy Apply\" accordion located.')\r\n+        print('\"Easy Apply\" accordion located.')\r\n \r\n         # Within the \"Easy Apply\" accordion, locate the filter button\r\n         easy_apply_filter_button = easy_apply_accordion.find_element(\r\n             By.XPATH, './/button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n         )\r\n+        logging.info('\"Easy Apply\" filter button located.')\r\n+        print('\"Easy Apply\" filter button located.')\r\n \r\n         # Check if the \"Easy Apply\" filter is already active\r\n         aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n         if aria_checked and aria_checked.lower() != 'true':\r\n             easy_apply_filter_button.click()\r\n             logging.info('\"Easy Apply\" filter activated.')\r\n             print('\"Easy Apply\" filter activated.')\r\n@@ -133,13 +145,17 @@\n \r\n     except NoSuchElementException as e:\r\n         logging.error(f'Error locating \"Easy Apply\" filter: {e}')\r\n         print(f'Error locating \"Easy Apply\" filter: {e}')\r\n+        # Capture a screenshot for debugging\r\n+        capture_screenshot('error_locating_easy_apply_filter')\r\n         driver.quit()\r\n         exit(1)\r\n     except TimeoutException as e:\r\n         logging.error(f'Timeout while activating \"Easy Apply\" filter: {e}')\r\n         print(f'Timeout while activating \"Easy Apply\" filter: {e}')\r\n+        # Capture a screenshot for debugging\r\n+        capture_screenshot('timeout_easy_apply_filter')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n def has_apply_now(job_card):\r\n@@ -156,27 +172,45 @@\n def log_available_buttons(job_card, job_title):\r\n     \"\"\"\r\n     Logs all available buttons within a job card for debugging purposes.\r\n     \"\"\"\r\n-    buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-    button_texts = [button.text for button in buttons]\r\n-    logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-    print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n \r\n-    # Capture a screenshot for visual debugging\r\n-    sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-    screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-    driver.save_screenshot(screenshot_path)\r\n-    logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-    print(f'Screenshot saved to {screenshot_path}')\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n \r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n def apply_to_job(job_card, job_title):\r\n     \"\"\"\r\n     Attempts to apply to a job using the \"Easy Apply\" option.\r\n     Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n     \"\"\"\r\n     try:\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n \r\n         # Click on the job title to open job details\r\n         title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n         title_element.click()\r\n@@ -193,20 +227,19 @@\n             logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n             print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n             return\r\n \r\n-        # Attempt to locate the 'Easy Apply' button using the revised selector\r\n+        # Attempt to locate the 'Easy Apply' button within job details\r\n         try:\r\n-            easy_apply_div = job_details.find_element(By.XPATH, './/div[@data-cy=\"card-easy-apply\"]')\r\n-            # Assuming clicking the div initiates the application\r\n-            easy_apply_div.click()\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+            easy_apply_button.click()\r\n             logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n             print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n \r\n-            # Wait for the modal to appear (adjust the XPath based on actual modal structure)\r\n+            # Wait for the apply modal to appear\r\n             modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Modal appeared for job: {job_title}')\r\n-            print(f'Modal appeared for job: {job_title}')\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n \r\n             # Wait for the resume upload field to be present within the modal\r\n             upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n             upload_field.send_keys(RESUME_PATH)\r\n@@ -223,11 +256,11 @@\n             # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n             # logging.info(f'Application confirmed for job: {job_title}')\r\n \r\n         except NoSuchElementException:\r\n-            # 'Easy Apply' button not found; likely already applied or not available\r\n-            logging.info(f'\"Easy Apply\" not available for job: {job_title}. It may have already been applied to.')\r\n-            print(f'\"Easy Apply\" not available for job: {job_title}. Skipping application.')\r\n+            # 'Easy Apply' button not found within job details\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error applying to \"{job_title}\": {e}')\r\n         print(f'Error applying to \"{job_title}\": {e}')\r\n@@ -255,22 +288,29 @@\n \r\n     try:\r\n         # Enter search criteria\r\n         driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n         search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n         search_field.clear()\r\n         search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n         search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n         search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n \r\n         # Activate the \"Easy Apply\" filter\r\n         activate_easy_apply_filter()\r\n \r\n         # Wait until job listings are loaded\r\n         wait.until(EC.presence_of_all_elements_located(\r\n             (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n         ))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n \r\n         # Get the list of job postings\r\n         job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n         logging.info(f'Found {len(job_cards)} job postings.')\r\n@@ -296,9 +336,9 @@\n             print(f'Job {index}: Title=\"{job_title}\"')\r\n \r\n             # Define the criteria for applying\r\n             criteria = ['Angular', 'Senior Frontend Developer']\r\n-            if all(keyword in job_title for keyword in criteria):\r\n+            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n                 print(f\"Applying to job: {job_title}\")\r\n                 logging.info(f\"Applying to job: {job_title}\")\r\n                 apply_to_job(job_card, job_title)\r\n \r\n"
                },
                {
                    "date": 1726894565308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,398 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+# chrome_options.add_argument('--ignore-certificate-errors')\r\n+# chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion\r\n+        try:\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked and aria_checked.lower() != 'true':\r\n+            easy_apply_filter_button.click()\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+        else:\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f'Error locating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error locating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_locating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except TimeoutException as e:\r\n+        logging.error(f'Timeout while activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Timeout while activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('timeout_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error in activate_easy_apply_filter(): {e}')\r\n+        print(f'Unexpected error in activate_easy_apply_filter(): {e}')\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(job_card):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Check if 'Apply now' button is present; if so, skip\r\n+        if has_apply_now(job_card):\r\n+            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button within job details\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+            # Wait for the apply modal to appear\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+\r\n+            # Optional: Wait for a confirmation message or element\r\n+            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+            # logging.info(f'Application confirmed for job: {job_title}')\r\n+\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found within job details\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+# -----------------------------\r\n+# Main Execution Function\r\n+# -----------------------------\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Define the criteria for applying\r\n+            criteria = ['Angular', 'Senior Frontend Developer']\r\n+            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n+                print(f\"Applying to job: {job_title}\")\r\n+                logging.info(f\"Applying to job: {job_title}\")\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+                logging.info(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726894725084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,398 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+# chrome_options.add_argument('--ignore-certificate-errors')\r\n+# chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        # Handle cases where 'aria-checked' might be missing or None\r\n+        if aria_checked is None:\r\n+            # Determine if the filter is active based on other attributes or states\r\n+            # For example, check if the icon has a 'selected' class\r\n+            try:\r\n+                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n+                class_attribute = icon.get_attribute('class')\r\n+                if 'selected' not in class_attribute:\r\n+                    easy_apply_filter_button.click()\r\n+                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n+                else:\r\n+                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n+                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n+            except NoSuchElementException:\r\n+                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+        else:\r\n+            if aria_checked.lower() != 'true':\r\n+                easy_apply_filter_button.click()\r\n+                logging.info('\"Easy Apply\" filter activated.')\r\n+                print('\"Easy Apply\" filter activated.')\r\n+                # Wait for the page to refresh after applying the filter\r\n+                time.sleep(3)  # Adjust as needed based on network speed\r\n+            else:\r\n+                logging.info('\"Easy Apply\" filter is already active.')\r\n+                print('\"Easy Apply\" filter is already active.')\r\n+\r\n+    def has_apply_now(job_card):\r\n+        \"\"\"\r\n+        Checks if a job card contains an \"Apply now\" button.\r\n+        Returns True if present, False otherwise.\r\n+        \"\"\"\r\n+        try:\r\n+            apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+            return True\r\n+        except NoSuchElementException:\r\n+            return False\r\n+\r\n+    def log_available_buttons(job_card, job_title):\r\n+        \"\"\"\r\n+        Logs all available buttons within a job card for debugging purposes.\r\n+        \"\"\"\r\n+        try:\r\n+            buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+            button_texts = [button.text for button in buttons]\r\n+            logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+            print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+            # Capture a screenshot for visual debugging\r\n+            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+            driver.save_screenshot(screenshot_path)\r\n+            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+            print(f'Screenshot saved to {screenshot_path}')\r\n+        except Exception as e:\r\n+            logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+            print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+    def apply_to_job(job_card, job_title):\r\n+        \"\"\"\r\n+        Attempts to apply to a job using the \"Easy Apply\" option.\r\n+        Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n+        \"\"\"\r\n+        try:\r\n+            wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+            # Click on the job title to open job details\r\n+            title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+\r\n+            # Wait for the job details panel to load\r\n+            job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+            logging.debug(f'Job details loaded for: {job_title}')\r\n+            print(f'Job details loaded for: {job_title}')\r\n+\r\n+            # Check if 'Apply now' button is present; if so, skip\r\n+            if has_apply_now(job_card):\r\n+                logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+                print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+                return\r\n+\r\n+            # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n+            try:\r\n+                easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+                easy_apply_button.click()\r\n+                logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+                # Wait for the apply modal to appear\r\n+                modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+                logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+                print(f'Apply modal appeared for job: {job_title}')\r\n+\r\n+                # Wait for the resume upload field to be present within the modal\r\n+                upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+                upload_field.send_keys(RESUME_PATH)\r\n+                logging.info(f'Uploaded resume for job: {job_title}')\r\n+                print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+                # Wait for the 'Submit' button to be clickable and click it\r\n+                submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+                submit_button.click()\r\n+                logging.info(f'Successfully applied to {job_title}')\r\n+                print(f\"Successfully applied to {job_title}\")\r\n+\r\n+                # Optional: Wait for a confirmation message or element\r\n+                # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+                # logging.info(f'Application confirmed for job: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                # 'Easy Apply' button not found within job details\r\n+                logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+                print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+\r\n+        except (NoSuchElementException, TimeoutException) as e:\r\n+            logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+            print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+            # Log available buttons and capture a screenshot\r\n+            log_available_buttons(job_card, job_title)\r\n+\r\n+        except Exception as e:\r\n+            logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+            print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+            # Capture a screenshot for visual debugging\r\n+            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+            driver.save_screenshot(screenshot_path)\r\n+            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+            print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+# -----------------------------\r\n+# Main Execution Function\r\n+# -----------------------------\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Define the criteria for applying\r\n+            criteria = ['Angular', 'Senior Frontend Developer']\r\n+            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n+                print(f\"Applying to job: {job_title}\")\r\n+                logging.info(f\"Applying to job: {job_title}\")\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+                logging.info(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726894757854,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,398 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+# chrome_options.add_argument('--ignore-certificate-errors')\r\n+# chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        # Handle cases where 'aria-checked' might be missing or None\r\n+        if aria_checked is None:\r\n+            # Determine if the filter is active based on other attributes or states\r\n+            # For example, check if the icon has a 'selected' class\r\n+            try:\r\n+                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n+                class_attribute = icon.get_attribute('class')\r\n+                if 'selected' not in class_attribute:\r\n+                    easy_apply_filter_button.click()\r\n+                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n+                else:\r\n+                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n+                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n+            except NoSuchElementException:\r\n+                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+        else:\r\n+            if aria_checked.lower() != 'true':\r\n+                easy_apply_filter_button.click()\r\n+                logging.info('\"Easy Apply\" filter activated.')\r\n+                print('\"Easy Apply\" filter activated.')\r\n+                # Wait for the page to refresh after applying the filter\r\n+                time.sleep(3)  # Adjust as needed based on network speed\r\n+            else:\r\n+                logging.info('\"Easy Apply\" filter is already active.')\r\n+                print('\"Easy Apply\" filter is already active.')\r\n+\r\n+    def has_apply_now(job_card):\r\n+        \"\"\"\r\n+        Checks if a job card contains an \"Apply now\" button.\r\n+        Returns True if present, False otherwise.\r\n+        \"\"\"\r\n+        try:\r\n+            apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+            return True\r\n+        except NoSuchElementException:\r\n+            return False\r\n+\r\n+    def log_available_buttons(job_card, job_title):\r\n+        \"\"\"\r\n+        Logs all available buttons within a job card for debugging purposes.\r\n+        \"\"\"\r\n+        try:\r\n+            buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+            button_texts = [button.text for button in buttons]\r\n+            logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+            print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+            # Capture a screenshot for visual debugging\r\n+            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+            driver.save_screenshot(screenshot_path)\r\n+            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+            print(f'Screenshot saved to {screenshot_path}')\r\n+        except Exception as e:\r\n+            logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+            print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+    def apply_to_job(job_card, job_title):\r\n+        \"\"\"\r\n+        Attempts to apply to a job using the \"Easy Apply\" option.\r\n+        Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n+        \"\"\"\r\n+        try:\r\n+            wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+            # Click on the job title to open job details\r\n+            title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+\r\n+            # Wait for the job details panel to load\r\n+            job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+            logging.debug(f'Job details loaded for: {job_title}')\r\n+            print(f'Job details loaded for: {job_title}')\r\n+\r\n+            # Check if 'Apply now' button is present; if so, skip\r\n+            if has_apply_now(job_card):\r\n+                logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+                print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+                return\r\n+\r\n+            # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n+            try:\r\n+                easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+                easy_apply_button.click()\r\n+                logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+                # Wait for the apply modal to appear\r\n+                modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+                logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+                print(f'Apply modal appeared for job: {job_title}')\r\n+\r\n+                # Wait for the resume upload field to be present within the modal\r\n+                upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+                upload_field.send_keys(RESUME_PATH)\r\n+                logging.info(f'Uploaded resume for job: {job_title}')\r\n+                print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+                # Wait for the 'Submit' button to be clickable and click it\r\n+                submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+                submit_button.click()\r\n+                logging.info(f'Successfully applied to {job_title}')\r\n+                print(f\"Successfully applied to {job_title}\")\r\n+\r\n+                # Optional: Wait for a confirmation message or element\r\n+                # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+                # logging.info(f'Application confirmed for job: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                # 'Easy Apply' button not found within job details\r\n+                logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+                print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+\r\n+        except (NoSuchElementException, TimeoutException) as e:\r\n+            logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+            print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+            # Log available buttons and capture a screenshot\r\n+            log_available_buttons(job_card, job_title)\r\n+\r\n+        except Exception as e:\r\n+            logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+            print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+            # Capture a screenshot for visual debugging\r\n+            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+            driver.save_screenshot(screenshot_path)\r\n+            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+            print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+# -----------------------------\r\n+# Main Execution Function\r\n+# -----------------------------\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Define the criteria for applying\r\n+            criteria = ['Angular', 'Senior Frontend Developer']\r\n+            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n+                print(f\"Applying to job: {job_title}\")\r\n+                logging.info(f\"Applying to job: {job_title}\")\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+                logging.info(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726894838446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,12 +311,8 @@\n             driver.save_screenshot(screenshot_path)\r\n             logging.debug(f'Screenshot saved to {screenshot_path}')\r\n             print(f'Screenshot saved to {screenshot_path}')\r\n \r\n-# -----------------------------\r\n-# Main Execution Function\r\n-# -----------------------------\r\n-\r\n def main():\r\n     login_to_dice()\r\n \r\n     try:\r\n@@ -395,1996 +391,4 @@\n # -----------------------------\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-# chrome_options.add_argument('--ignore-certificate-errors')\r\n-# chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        # Handle cases where 'aria-checked' might be missing or None\r\n-        if aria_checked is None:\r\n-            # Determine if the filter is active based on other attributes or states\r\n-            # For example, check if the icon has a 'selected' class\r\n-            try:\r\n-                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n-                class_attribute = icon.get_attribute('class')\r\n-                if 'selected' not in class_attribute:\r\n-                    easy_apply_filter_button.click()\r\n-                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n-                else:\r\n-                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n-                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n-            except NoSuchElementException:\r\n-                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-        else:\r\n-            if aria_checked.lower() != 'true':\r\n-                easy_apply_filter_button.click()\r\n-                logging.info('\"Easy Apply\" filter activated.')\r\n-                print('\"Easy Apply\" filter activated.')\r\n-                # Wait for the page to refresh after applying the filter\r\n-                time.sleep(3)  # Adjust as needed based on network speed\r\n-            else:\r\n-                logging.info('\"Easy Apply\" filter is already active.')\r\n-                print('\"Easy Apply\" filter is already active.')\r\n-\r\n-    def has_apply_now(job_card):\r\n-        \"\"\"\r\n-        Checks if a job card contains an \"Apply now\" button.\r\n-        Returns True if present, False otherwise.\r\n-        \"\"\"\r\n-        try:\r\n-            apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-            return True\r\n-        except NoSuchElementException:\r\n-            return False\r\n-\r\n-    def log_available_buttons(job_card, job_title):\r\n-        \"\"\"\r\n-        Logs all available buttons within a job card for debugging purposes.\r\n-        \"\"\"\r\n-        try:\r\n-            buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-            button_texts = [button.text for button in buttons]\r\n-            logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-            print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-            # Capture a screenshot for visual debugging\r\n-            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-            driver.save_screenshot(screenshot_path)\r\n-            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-            print(f'Screenshot saved to {screenshot_path}')\r\n-        except Exception as e:\r\n-            logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-            print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-    def apply_to_job(job_card, job_title):\r\n-        \"\"\"\r\n-        Attempts to apply to a job using the \"Easy Apply\" option.\r\n-        Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n-        \"\"\"\r\n-        try:\r\n-            wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-            # Click on the job title to open job details\r\n-            title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-\r\n-            # Wait for the job details panel to load\r\n-            job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-            logging.debug(f'Job details loaded for: {job_title}')\r\n-            print(f'Job details loaded for: {job_title}')\r\n-\r\n-            # Check if 'Apply now' button is present; if so, skip\r\n-            if has_apply_now(job_card):\r\n-                logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-                print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-                return\r\n-\r\n-            # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n-            try:\r\n-                easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-                easy_apply_button.click()\r\n-                logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-                # Wait for the apply modal to appear\r\n-                modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-                logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-                print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-                # Wait for the resume upload field to be present within the modal\r\n-                upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-                upload_field.send_keys(RESUME_PATH)\r\n-                logging.info(f'Uploaded resume for job: {job_title}')\r\n-                print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-                # Wait for the 'Submit' button to be clickable and click it\r\n-                submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-                submit_button.click()\r\n-                logging.info(f'Successfully applied to {job_title}')\r\n-                print(f\"Successfully applied to {job_title}\")\r\n-\r\n-                # Optional: Wait for a confirmation message or element\r\n-                # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-                # logging.info(f'Application confirmed for job: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                # 'Easy Apply' button not found within job details\r\n-                logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-                print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-\r\n-        except (NoSuchElementException, TimeoutException) as e:\r\n-            logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-            print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-            # Log available buttons and capture a screenshot\r\n-            log_available_buttons(job_card, job_title)\r\n-\r\n-        except Exception as e:\r\n-            logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-            print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-            # Capture a screenshot for visual debugging\r\n-            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-            driver.save_screenshot(screenshot_path)\r\n-            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-            print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-# -----------------------------\r\n-# Main Execution Function\r\n-# -----------------------------\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Define the criteria for applying\r\n-            criteria = ['Angular', 'Senior Frontend Developer']\r\n-            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n-                print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title}\")\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-                logging.info(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-# chrome_options.add_argument('--ignore-certificate-errors')\r\n-# chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion\r\n-        try:\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked and aria_checked.lower() != 'true':\r\n-            easy_apply_filter_button.click()\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-        else:\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f'Error locating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error locating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_locating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except TimeoutException as e:\r\n-        logging.error(f'Timeout while activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Timeout while activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('timeout_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error in activate_easy_apply_filter(): {e}')\r\n-        print(f'Unexpected error in activate_easy_apply_filter(): {e}')\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(job_card):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Check if 'Apply now' button is present; if so, skip\r\n-        if has_apply_now(job_card):\r\n-            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button within job details\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-            # Wait for the apply modal to appear\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-            # Wait for the resume upload field to be present within the modal\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-            # Optional: Wait for a confirmation message or element\r\n-            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-            # logging.info(f'Application confirmed for job: {job_title}')\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found within job details\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-# -----------------------------\r\n-# Main Execution Function\r\n-# -----------------------------\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Define the criteria for applying\r\n-            criteria = ['Angular', 'Senior Frontend Developer']\r\n-            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n-                print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title}\")\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-                logging.info(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-# chrome_options.add_argument('--ignore-certificate-errors')\r\n-# chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget\r\n-        easy_apply_accordion = filters_widget.find_element(By.XPATH, './/dhi-accordion[@data-cy=\"accordion-easyApply\"]')\r\n-        logging.info('\"Easy Apply\" accordion located.')\r\n-        print('\"Easy Apply\" accordion located.')\r\n-\r\n-        # Within the \"Easy Apply\" accordion, locate the filter button\r\n-        easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-            By.XPATH, './/button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-        )\r\n-        logging.info('\"Easy Apply\" filter button located.')\r\n-        print('\"Easy Apply\" filter button located.')\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked and aria_checked.lower() != 'true':\r\n-            easy_apply_filter_button.click()\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-        else:\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f'Error locating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error locating \"Easy Apply\" filter: {e}')\r\n-        # Capture a screenshot for debugging\r\n-        capture_screenshot('error_locating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except TimeoutException as e:\r\n-        logging.error(f'Timeout while activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Timeout while activating \"Easy Apply\" filter: {e}')\r\n-        # Capture a screenshot for debugging\r\n-        capture_screenshot('timeout_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(job_card):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Check if 'Apply now' button is present; if so, skip\r\n-        if has_apply_now(job_card):\r\n-            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button within job details\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-            # Wait for the apply modal to appear\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-            # Wait for the resume upload field to be present within the modal\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-            # Optional: Wait for a confirmation message or element\r\n-            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-            # logging.info(f'Application confirmed for job: {job_title}')\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found within job details\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-# -----------------------------\r\n-# Main Execution Function\r\n-# -----------------------------\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Define the criteria for applying\r\n-            criteria = ['Angular', 'Senior Frontend Developer']\r\n-            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n-                print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title}\")\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-                logging.info(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    InvalidArgumentException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# Load configuration\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize window\r\n-driver.maximize_window()\r\n-\r\n-def has_apply_now(job_card):\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-    button_texts = [button.text for button in buttons]\r\n-    logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-    print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-    # Capture a screenshot for visual debugging\r\n-    sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-    screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-    driver.save_screenshot(screenshot_path)\r\n-    logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-    print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-def apply_to_job(job_card, job_title):\r\n-    try:\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load (adjust the XPath based on actual DOM)\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Check if 'Apply now' button is present; if so, skip\r\n-        if has_apply_now(job_card):\r\n-            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button using the revised selector\r\n-        try:\r\n-            easy_apply_div = job_details.find_element(By.XPATH, './/div[@data-cy=\"card-easy-apply\"]')\r\n-            # Assuming clicking the div initiates the application\r\n-            easy_apply_div.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-            # Wait for the modal to appear (adjust the XPath based on actual modal structure)\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Modal appeared for job: {job_title}')\r\n-            print(f'Modal appeared for job: {job_title}')\r\n-\r\n-            # Wait for the resume upload field to be present within the modal\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found; likely already applied or not available\r\n-            logging.info(f'\"Easy Apply\" not available for job: {job_title}. It may have already been applied to.')\r\n-            print(f'\"Easy Apply\" not available for job: {job_title}. Skipping application.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')))\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Define the criteria for applying\r\n-            criteria = ['Angular', 'Senior Frontend Developer']\r\n-            if all(keyword in job_title for keyword in criteria):\r\n-                print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title}\")\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-                logging.info(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    InvalidArgumentException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# Load configuration\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize window\r\n-driver.maximize_window()\r\n-\r\n-def login_to_dice():\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-\r\n-        # Wait until dashboard loads by checking URL or specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def apply_to_job(job_card, job_title):\r\n-    try:\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button\r\n-        try:\r\n-            apply_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Easy Apply\")]')\r\n-            apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-            # Proceed with uploading resume and submitting application\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found; likely already applied\r\n-            logging.info(f'\"Easy Apply\" not available for job: {job_title}. It may have already been applied to.')\r\n-            print(f'\"Easy Apply\" not available for job: {job_title}. Skipping application.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Debugging: Print all available buttons' texts within the job details\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')))\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-                \r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Define the criteria for applying\r\n-            criteria = ['Angular', 'Senior Frontend Developer']\r\n-            if all(keyword in job_title for keyword in criteria):\r\n-                print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title}\")\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-                logging.info(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    InvalidArgumentException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# Load configuration\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize window\r\n-driver.maximize_window()\r\n-\r\n-def login_to_dice():\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-\r\n-        # Wait until dashboard loads by checking URL or specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def apply_to_job(job_card, job_title):\r\n-    try:\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n-\r\n-        # Find and click the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load (update XPath as necessary)\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Find and click the 'Easy Apply' button within the job details\r\n-        apply_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Easy Apply\")]')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-        print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-        # Wait for the modal to appear (update XPath based on actual modal structure)\r\n-        modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-        logging.debug(f'Modal appeared for job: {job_title}')\r\n-        print(f'Modal appeared for job: {job_title}')\r\n-\r\n-        # Wait for the resume upload field to be present within the modal\r\n-        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-        upload_field.send_keys(RESUME_PATH)\r\n-        logging.info(f'Uploaded resume for job: {job_title}')\r\n-        print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-        submit_button.click()\r\n-        logging.info(f'Successfully applied to {job_title}')\r\n-        print(f\"Successfully applied to {job_title}\")\r\n-\r\n-        # Optionally, wait for a confirmation message or element\r\n-        # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-        # logging.info(f'Application confirmed for job: {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Debugging: Print all available buttons' texts within the job details\r\n-        buttons = driver.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 15)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')))\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-                \r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Define the criteria for applying\r\n-            criteria = ['Angular', 'Senior Frontend Developer']\r\n-            if all(keyword in job_title for keyword in criteria):\r\n-                print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title}\")\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-                logging.info(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    InvalidArgumentException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# Load configuration\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Check if resume exists\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize window\r\n-driver.maximize_window()\r\n-\r\n-def login_to_dice():\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 10)\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-\r\n-        # Wait until dashboard loads by checking URL or specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def apply_to_job(job_card, job_title):\r\n-    try:\r\n-        wait = WebDriverWait(driver, 10)\r\n-        \r\n-        # Find and click the 'Easy Apply' button within the job card\r\n-        apply_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Easy Apply\")]')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-        print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-        \r\n-        # Wait for the resume upload field to be present\r\n-        upload_field = wait.until(EC.presence_of_element_located((By.NAME, 'resume')))\r\n-        upload_field.send_keys(RESUME_PATH)\r\n-        logging.info(f'Uploaded resume for job: {job_title}')\r\n-        print(f'Uploaded resume for job: {job_title}')\r\n-        \r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Submit\")]')))\r\n-        submit_button.click()\r\n-        logging.info(f'Successfully applied to {job_title}')\r\n-        print(f\"Successfully applied to {job_title}\")\r\n-        \r\n-        # Optionally, wait for a confirmation message or element\r\n-        # wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-        \r\n-    except NoSuchElementException as e:\r\n-        logging.error(f'Element not found while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not found while applying to \"{job_title}\": {e}')\r\n-    except TimeoutException as e:\r\n-        logging.error(f'Timeout while applying to \"{job_title}\": {e}')\r\n-        print(f'Timeout while applying to \"{job_title}\": {e}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 10)\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card search-card\")]')))\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title\r\n-                title_element = job_card.find_element(By.XPATH, './/h5/a[@class=\"card-title-link normal viewed\"]')\r\n-                job_title = title_element.text.strip()\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Check if the job title contains both \"Angular\" and \"Senior Frontend Developer\"\r\n-            if 'Angular' in job_title and 'Senior Frontend Developer' in job_title:\r\n-                print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title}\")\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-                logging.info(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n"
                },
                {
                    "date": 1726895328039,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,115 +203,121 @@\n                 time.sleep(3)  # Adjust as needed based on network speed\r\n             else:\r\n                 logging.info('\"Easy Apply\" filter is already active.')\r\n                 print('\"Easy Apply\" filter is already active.')\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n \r\n-    def has_apply_now(job_card):\r\n-        \"\"\"\r\n-        Checks if a job card contains an \"Apply now\" button.\r\n-        Returns True if present, False otherwise.\r\n-        \"\"\"\r\n-        try:\r\n-            apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-            return True\r\n-        except NoSuchElementException:\r\n-            return False\r\n+def has_apply_now(job_card):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n \r\n-    def log_available_buttons(job_card, job_title):\r\n-        \"\"\"\r\n-        Logs all available buttons within a job card for debugging purposes.\r\n-        \"\"\"\r\n-        try:\r\n-            buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-            button_texts = [button.text for button in buttons]\r\n-            logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-            print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n \r\n-            # Capture a screenshot for visual debugging\r\n-            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-            driver.save_screenshot(screenshot_path)\r\n-            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-            print(f'Screenshot saved to {screenshot_path}')\r\n-        except Exception as e:\r\n-            logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-            print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n \r\n-    def apply_to_job(job_card, job_title):\r\n-        \"\"\"\r\n-        Attempts to apply to a job using the \"Easy Apply\" option.\r\n-        Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n-        \"\"\"\r\n-        try:\r\n-            wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+def apply_to_job(job_card, job_title):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n \r\n-            # Click on the job title to open job details\r\n-            title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n \r\n-            # Wait for the job details panel to load\r\n-            job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-            logging.debug(f'Job details loaded for: {job_title}')\r\n-            print(f'Job details loaded for: {job_title}')\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n \r\n-            # Check if 'Apply now' button is present; if so, skip\r\n-            if has_apply_now(job_card):\r\n-                logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-                print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-                return\r\n+        # Check if 'Apply now' button is present; if so, skip\r\n+        if has_apply_now(job_card):\r\n+            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            return\r\n \r\n-            # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n-            try:\r\n-                easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-                easy_apply_button.click()\r\n-                logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n \r\n-                # Wait for the apply modal to appear\r\n-                modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-                logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-                print(f'Apply modal appeared for job: {job_title}')\r\n+            # Wait for the apply modal to appear\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n \r\n-                # Wait for the resume upload field to be present within the modal\r\n-                upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-                upload_field.send_keys(RESUME_PATH)\r\n-                logging.info(f'Uploaded resume for job: {job_title}')\r\n-                print(f'Uploaded resume for job: {job_title}')\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n \r\n-                # Wait for the 'Submit' button to be clickable and click it\r\n-                submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-                submit_button.click()\r\n-                logging.info(f'Successfully applied to {job_title}')\r\n-                print(f\"Successfully applied to {job_title}\")\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n \r\n-                # Optional: Wait for a confirmation message or element\r\n-                # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-                # logging.info(f'Application confirmed for job: {job_title}')\r\n+            # Optional: Wait for a confirmation message or element\r\n+            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+            # logging.info(f'Application confirmed for job: {job_title}')\r\n \r\n-            except NoSuchElementException:\r\n-                # 'Easy Apply' button not found within job details\r\n-                logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-                print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found within job details\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n \r\n-        except (NoSuchElementException, TimeoutException) as e:\r\n-            logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-            print(f'Error applying to \"{job_title}\": {e}')\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n \r\n-            # Log available buttons and capture a screenshot\r\n-            log_available_buttons(job_card, job_title)\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n \r\n-        except Exception as e:\r\n-            logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-            print(f'Failed to apply to \"{job_title}\": {e}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n \r\n-            # Capture a screenshot for visual debugging\r\n-            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-            driver.save_screenshot(screenshot_path)\r\n-            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-            print(f'Screenshot saved to {screenshot_path}')\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n \r\n def main():\r\n     login_to_dice()\r\n \r\n"
                },
                {
                    "date": 1726895566977,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,11 +8,14 @@\n from selenium.common.exceptions import (\r\n     NoSuchElementException,\r\n     WebDriverException,\r\n     TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n )\r\n from selenium.webdriver.support.ui import WebDriverWait\r\n from selenium.webdriver.support import expected_conditions as EC\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n \r\n # -----------------------------\r\n # Configuration and Setup\r\n # -----------------------------\r\n@@ -104,8 +107,9 @@\n         print(\"Successfully logged into Dice.\")\r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error during login: {e}')\r\n         print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n def capture_screenshot(name):\r\n@@ -121,11 +125,30 @@\n     except Exception as e:\r\n         logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n         print(f'Failed to capture screenshot \"{name}\": {e}')\r\n \r\n+def close_popup():\r\n+    \"\"\"\r\n+    Closes any pop-up or overlay that might be blocking elements.\r\n+    \"\"\"\r\n+    try:\r\n+        # Example XPath for a generic close button (update based on actual pop-up)\r\n+        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n+        popup_close_button.click()\r\n+        logging.info('Closed pop-up successfully.')\r\n+        print('Closed pop-up successfully.')\r\n+        time.sleep(2)  # Wait for the pop-up to close\r\n+    except NoSuchElementException:\r\n+        logging.info('No pop-up to close.')\r\n+        print('No pop-up to close.')\r\n+    except Exception as e:\r\n+        logging.error(f'Error closing pop-up: {e}')\r\n+        print(f'Error closing pop-up: {e}')\r\n+\r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n     \"\"\"\r\n     try:\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n \r\n@@ -170,8 +193,20 @@\n             capture_screenshot('missing_easy_apply_filter_button')\r\n             driver.quit()\r\n             exit(1)\r\n \r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n         # Check if the \"Easy Apply\" filter is already active\r\n         aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n         logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n         print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n@@ -183,9 +218,13 @@\n             try:\r\n                 icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n                 class_attribute = icon.get_attribute('class')\r\n                 if 'selected' not in class_attribute:\r\n-                    easy_apply_filter_button.click()\r\n+                    # Attempt to close any pop-up before clicking\r\n+                    close_popup()\r\n+\r\n+                    # Click using ActionChains to ensure the element is in view\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n                     logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n                     print('\"Easy Apply\" filter activated (based on icon class).')\r\n                     time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n                 else:\r\n@@ -195,9 +234,21 @@\n                 logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n                 print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n         else:\r\n             if aria_checked.lower() != 'true':\r\n-                easy_apply_filter_button.click()\r\n+                # Attempt to close any pop-up before clicking\r\n+                close_popup()\r\n+\r\n+                # Click using ActionChains to ensure the element is in view\r\n+                try:\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                except ElementClickInterceptedException:\r\n+                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+                except ElementNotInteractableException:\r\n+                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n                 logging.info('\"Easy Apply\" filter activated.')\r\n                 print('\"Easy Apply\" filter activated.')\r\n                 # Wait for the page to refresh after applying the filter\r\n                 time.sleep(3)  # Adjust as needed based on network speed\r\n@@ -209,8 +260,14 @@\n         print(f\"Error activating 'Easy Apply' filter: {e}\")\r\n         capture_screenshot('error_activating_easy_apply_filter')\r\n         driver.quit()\r\n         exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n \r\n def has_apply_now(job_card):\r\n     \"\"\"\r\n     Checks if a job card contains an \"Apply now\" button.\r\n@@ -306,8 +363,16 @@\n \r\n         # Log available buttons and capture a screenshot\r\n         log_available_buttons(job_card, job_title)\r\n \r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n     except Exception as e:\r\n         logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n         print(f'Failed to apply to \"{job_title}\": {e}')\r\n \r\n"
                },
                {
                    "date": 1726895781944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -254,212 +254,216 @@\n                 time.sleep(3)  # Adjust as needed based on network speed\r\n             else:\r\n                 logging.info('\"Easy Apply\" filter is already active.')\r\n                 print('\"Easy Apply\" filter is already active.')\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n \r\n-def has_apply_now(job_card):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'pageSize=100&filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL or re-apply the filter\r\n+            # For example:\r\n+            # driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n+            # time.sleep(3)\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n \r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+    def has_apply_now(job_card):\r\n+        \"\"\"\r\n+        Checks if a job card contains an \"Apply now\" button.\r\n+        Returns True if present, False otherwise.\r\n+        \"\"\"\r\n+        try:\r\n+            apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+            return True\r\n+        except NoSuchElementException:\r\n+            return False\r\n \r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+    def log_available_buttons(job_card, job_title):\r\n+        \"\"\"\r\n+        Logs all available buttons within a job card for debugging purposes.\r\n+        \"\"\"\r\n+        try:\r\n+            buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+            button_texts = [button.text for button in buttons]\r\n+            logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+            print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n \r\n-def apply_to_job(job_card, job_title):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+            # Capture a screenshot for visual debugging\r\n+            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+            driver.save_screenshot(screenshot_path)\r\n+            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+            print(f'Screenshot saved to {screenshot_path}')\r\n+        except Exception as e:\r\n+            logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+            print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n \r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n+    def apply_to_job(job_card, job_title):\r\n+        \"\"\"\r\n+        Attempts to apply to a job using the \"Easy Apply\" option.\r\n+        Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n+        \"\"\"\r\n+        try:\r\n+            wait = WebDriverWait(driver, 20)  # Increased timeout\r\n \r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n+            # Click on the job title to open job details\r\n+            title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n \r\n-        # Check if 'Apply now' button is present; if so, skip\r\n-        if has_apply_now(job_card):\r\n-            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            return\r\n+            # Wait for the job details panel to load\r\n+            job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+            logging.debug(f'Job details loaded for: {job_title}')\r\n+            print(f'Job details loaded for: {job_title}')\r\n \r\n-        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            # Check if 'Apply now' button is present; if so, skip\r\n+            if has_apply_now(job_card):\r\n+                logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+                print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+                return\r\n \r\n-            # Wait for the apply modal to appear\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n+            # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n+            try:\r\n+                easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+                easy_apply_button.click()\r\n+                logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n \r\n-            # Wait for the resume upload field to be present within the modal\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n+                # Wait for the apply modal to appear\r\n+                modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+                logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+                print(f'Apply modal appeared for job: {job_title}')\r\n \r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n+                # Wait for the resume upload field to be present within the modal\r\n+                upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+                upload_field.send_keys(RESUME_PATH)\r\n+                logging.info(f'Uploaded resume for job: {job_title}')\r\n+                print(f'Uploaded resume for job: {job_title}')\r\n \r\n-            # Optional: Wait for a confirmation message or element\r\n-            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-            # logging.info(f'Application confirmed for job: {job_title}')\r\n+                # Wait for the 'Submit' button to be clickable and click it\r\n+                submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+                submit_button.click()\r\n+                logging.info(f'Successfully applied to {job_title}')\r\n+                print(f\"Successfully applied to {job_title}\")\r\n \r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found within job details\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+                # Optional: Wait for a confirmation message or element\r\n+                # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+                # logging.info(f'Application confirmed for job: {job_title}')\r\n \r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n+            except NoSuchElementException:\r\n+                # 'Easy Apply' button not found within job details\r\n+                logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+                print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n \r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n+        except (NoSuchElementException, TimeoutException) as e:\r\n+            logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+            print(f'Error applying to \"{job_title}\": {e}')\r\n \r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+            # Log available buttons and capture a screenshot\r\n+            log_available_buttons(job_card, job_title)\r\n \r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n+        except ElementClickInterceptedException as e:\r\n+            logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+            print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+            capture_screenshot('click_intercepted')\r\n \r\n-def main():\r\n-    login_to_dice()\r\n+        except ElementNotInteractableException as e:\r\n+            logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+            print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+            capture_screenshot('element_not_interactable')\r\n \r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+        except Exception as e:\r\n+            logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+            print(f'Failed to apply to \"{job_title}\": {e}')\r\n \r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n+            # Capture a screenshot for visual debugging\r\n+            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+            driver.save_screenshot(screenshot_path)\r\n+            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+            print(f'Screenshot saved to {screenshot_path}')\r\n \r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n+    def main():\r\n+        login_to_dice()\r\n \r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n+        try:\r\n+            # Enter search criteria\r\n+            driver.get('https://www.dice.com/')\r\n+            wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+            search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+            search_field.clear()\r\n+            search_field.send_keys(SEARCH_TERMS)\r\n+            logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+            print(f'Entered search terms: {SEARCH_TERMS}')\r\n \r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n+            search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+            search_button.click()\r\n+            logging.info('Clicked search button.')\r\n+            print('Clicked search button.')\r\n \r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n+            # Activate the \"Easy Apply\" filter\r\n+            activate_easy_apply_filter()\r\n \r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n+            # Wait until job listings are loaded\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Job listings loaded.')\r\n+            print('Job listings loaded.')\r\n \r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n+            # Get the list of job postings\r\n+            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            logging.info(f'Found {len(job_cards)} job postings.')\r\n+            print(f'Found {len(job_cards)} job postings.')\r\n \r\n-            # Define the criteria for applying\r\n-            criteria = ['Angular', 'Senior Frontend Developer']\r\n-            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n-                print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title}\")\r\n-                apply_to_job(job_card, job_title)\r\n+            for index, job_card in enumerate(job_cards, start=1):\r\n+                try:\r\n+                    # Extract the job title using data-cy attribute\r\n+                    title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                    job_title = title_element.text.strip()\r\n+                except NoSuchElementException:\r\n+                    logging.warning(f'Job {index}: Title element not found.')\r\n+                    print(f'Job {index}: Title element not found.')\r\n \r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-                logging.info(f\"Skipping job: {job_title}\")\r\n+                    # Debugging: Print the outer HTML of the job card\r\n+                    job_card_html = job_card.get_attribute('outerHTML')\r\n+                    logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                    print(f'Job {index} HTML: {job_card_html}')\r\n+                    continue\r\n \r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n+                # Debugging: Log job titles\r\n+                logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+                print(f'Job {index}: Title=\"{job_title}\"')\r\n \r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n+                # Define the criteria for applying\r\n+                criteria = ['Angular', 'Senior Frontend Developer']\r\n+                if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n+                    print(f\"Applying to job: {job_title}\")\r\n+                    logging.info(f\"Applying to job: {job_title}\")\r\n+                    apply_to_job(job_card, job_title)\r\n \r\n-if __name__ == '__main__':\r\n-    main()\r\n+                    # Pause for specified duration before the next application\r\n+                    print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                    time.sleep(PAUSE_DURATION)\r\n+                else:\r\n+                    print(f\"Skipping job: {job_title}\")\r\n+                    logging.info(f\"Skipping job: {job_title}\")\r\n+\r\n+            print(\"Job application process completed.\")\r\n+            logging.info(\"Job application process completed.\")\r\n+        except Exception as e:\r\n+            logging.error(f'An error occurred in main(): {e}')\r\n+            print(f\"An error occurred in main(): {e}\")\r\n+        finally:\r\n+            driver.quit()\r\n+\r\n+    # -----------------------------\r\n+    # Entry Point\r\n+    # -----------------------------\r\n+\r\n+    if __name__ == '__main__':\r\n+        main()\r\n"
                },
                {
                    "date": 1726896087387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -254,216 +254,212 @@\n                 time.sleep(3)  # Adjust as needed based on network speed\r\n             else:\r\n                 logging.info('\"Easy Apply\" filter is already active.')\r\n                 print('\"Easy Apply\" filter is already active.')\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n \r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'pageSize=100&filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL or re-apply the filter\r\n-            # For example:\r\n-            # driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n-            # time.sleep(3)\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n+def has_apply_now(job_card):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n \r\n-    def has_apply_now(job_card):\r\n-        \"\"\"\r\n-        Checks if a job card contains an \"Apply now\" button.\r\n-        Returns True if present, False otherwise.\r\n-        \"\"\"\r\n-        try:\r\n-            apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-            return True\r\n-        except NoSuchElementException:\r\n-            return False\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n \r\n-    def log_available_buttons(job_card, job_title):\r\n-        \"\"\"\r\n-        Logs all available buttons within a job card for debugging purposes.\r\n-        \"\"\"\r\n-        try:\r\n-            buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-            button_texts = [button.text for button in buttons]\r\n-            logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-            print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n \r\n-            # Capture a screenshot for visual debugging\r\n-            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-            driver.save_screenshot(screenshot_path)\r\n-            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-            print(f'Screenshot saved to {screenshot_path}')\r\n-        except Exception as e:\r\n-            logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-            print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+def apply_to_job(job_card, job_title):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n \r\n-    def apply_to_job(job_card, job_title):\r\n-        \"\"\"\r\n-        Attempts to apply to a job using the \"Easy Apply\" option.\r\n-        Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n-        \"\"\"\r\n-        try:\r\n-            wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n \r\n-            # Click on the job title to open job details\r\n-            title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n \r\n-            # Wait for the job details panel to load\r\n-            job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-            logging.debug(f'Job details loaded for: {job_title}')\r\n-            print(f'Job details loaded for: {job_title}')\r\n+        # Check if 'Apply now' button is present; if so, skip\r\n+        if has_apply_now(job_card):\r\n+            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            return\r\n \r\n-            # Check if 'Apply now' button is present; if so, skip\r\n-            if has_apply_now(job_card):\r\n-                logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-                print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-                return\r\n+        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n \r\n-            # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n-            try:\r\n-                easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-                easy_apply_button.click()\r\n-                logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            # Wait for the apply modal to appear\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n \r\n-                # Wait for the apply modal to appear\r\n-                modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-                logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-                print(f'Apply modal appeared for job: {job_title}')\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n \r\n-                # Wait for the resume upload field to be present within the modal\r\n-                upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-                upload_field.send_keys(RESUME_PATH)\r\n-                logging.info(f'Uploaded resume for job: {job_title}')\r\n-                print(f'Uploaded resume for job: {job_title}')\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n \r\n-                # Wait for the 'Submit' button to be clickable and click it\r\n-                submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-                submit_button.click()\r\n-                logging.info(f'Successfully applied to {job_title}')\r\n-                print(f\"Successfully applied to {job_title}\")\r\n+            # Optional: Wait for a confirmation message or element\r\n+            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+            # logging.info(f'Application confirmed for job: {job_title}')\r\n \r\n-                # Optional: Wait for a confirmation message or element\r\n-                # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-                # logging.info(f'Application confirmed for job: {job_title}')\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found within job details\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n \r\n-            except NoSuchElementException:\r\n-                # 'Easy Apply' button not found within job details\r\n-                logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-                print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n \r\n-        except (NoSuchElementException, TimeoutException) as e:\r\n-            logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-            print(f'Error applying to \"{job_title}\": {e}')\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n \r\n-            # Log available buttons and capture a screenshot\r\n-            log_available_buttons(job_card, job_title)\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n \r\n-        except ElementClickInterceptedException as e:\r\n-            logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-            print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-            capture_screenshot('click_intercepted')\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n \r\n-        except ElementNotInteractableException as e:\r\n-            logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-            print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-            capture_screenshot('element_not_interactable')\r\n+def main():\r\n+    login_to_dice()\r\n \r\n-        except Exception as e:\r\n-            logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-            print(f'Failed to apply to \"{job_title}\": {e}')\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n \r\n-            # Capture a screenshot for visual debugging\r\n-            sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-            screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-            driver.save_screenshot(screenshot_path)\r\n-            logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-            print(f'Screenshot saved to {screenshot_path}')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n \r\n-    def main():\r\n-        login_to_dice()\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n \r\n-        try:\r\n-            # Enter search criteria\r\n-            driver.get('https://www.dice.com/')\r\n-            wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-            search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-            search_field.clear()\r\n-            search_field.send_keys(SEARCH_TERMS)\r\n-            logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-            print(f'Entered search terms: {SEARCH_TERMS}')\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n \r\n-            search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-            search_button.click()\r\n-            logging.info('Clicked search button.')\r\n-            print('Clicked search button.')\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n \r\n-            # Activate the \"Easy Apply\" filter\r\n-            activate_easy_apply_filter()\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n \r\n-            # Wait until job listings are loaded\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Job listings loaded.')\r\n-            print('Job listings loaded.')\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n \r\n-            # Get the list of job postings\r\n-            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            logging.info(f'Found {len(job_cards)} job postings.')\r\n-            print(f'Found {len(job_cards)} job postings.')\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n \r\n-            for index, job_card in enumerate(job_cards, start=1):\r\n-                try:\r\n-                    # Extract the job title using data-cy attribute\r\n-                    title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                    job_title = title_element.text.strip()\r\n-                except NoSuchElementException:\r\n-                    logging.warning(f'Job {index}: Title element not found.')\r\n-                    print(f'Job {index}: Title element not found.')\r\n+            # Define the criteria for applying\r\n+            criteria = ['Angular', 'Senior Frontend Developer']\r\n+            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n+                print(f\"Applying to job: {job_title}\")\r\n+                logging.info(f\"Applying to job: {job_title}\")\r\n+                apply_to_job(job_card, job_title)\r\n \r\n-                    # Debugging: Print the outer HTML of the job card\r\n-                    job_card_html = job_card.get_attribute('outerHTML')\r\n-                    logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                    print(f'Job {index} HTML: {job_card_html}')\r\n-                    continue\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+                logging.info(f\"Skipping job: {job_title}\")\r\n \r\n-                # Debugging: Log job titles\r\n-                logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-                print(f'Job {index}: Title=\"{job_title}\"')\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n \r\n-                # Define the criteria for applying\r\n-                criteria = ['Angular', 'Senior Frontend Developer']\r\n-                if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n-                    print(f\"Applying to job: {job_title}\")\r\n-                    logging.info(f\"Applying to job: {job_title}\")\r\n-                    apply_to_job(job_card, job_title)\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n \r\n-                    # Pause for specified duration before the next application\r\n-                    print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                    time.sleep(PAUSE_DURATION)\r\n-                else:\r\n-                    print(f\"Skipping job: {job_title}\")\r\n-                    logging.info(f\"Skipping job: {job_title}\")\r\n-\r\n-            print(\"Job application process completed.\")\r\n-            logging.info(\"Job application process completed.\")\r\n-        except Exception as e:\r\n-            logging.error(f'An error occurred in main(): {e}')\r\n-            print(f\"An error occurred in main(): {e}\")\r\n-        finally:\r\n-            driver.quit()\r\n-\r\n-    # -----------------------------\r\n-    # Entry Point\r\n-    # -----------------------------\r\n-\r\n-    if __name__ == '__main__':\r\n-        main()\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726896348621,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -254,11 +254,30 @@\n                 time.sleep(3)  # Adjust as needed based on network speed\r\n             else:\r\n                 logging.info('\"Easy Apply\" filter is already active.')\r\n                 print('\"Easy Apply\" filter is already active.')\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'pageSize=100&filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Error activating 'Easy Apply' filter: {e}\")\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n         capture_screenshot('error_activating_easy_apply_filter')\r\n         driver.quit()\r\n         exit(1)\r\n     except Exception as e:\r\n@@ -267,8 +286,9 @@\n         capture_screenshot('unexpected_error_easy_apply_filter')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n+\r\n def has_apply_now(job_card):\r\n     \"\"\"\r\n     Checks if a job card contains an \"Apply now\" button.\r\n     Returns True if present, False otherwise.\r\n@@ -367,12 +387,14 @@\n     except ElementClickInterceptedException as e:\r\n         logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n         print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n         capture_screenshot('click_intercepted')\r\n+\r\n     except ElementNotInteractableException as e:\r\n         logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n         print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n         capture_screenshot('element_not_interactable')\r\n+\r\n     except Exception as e:\r\n         logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n         print(f'Failed to apply to \"{job_title}\": {e}')\r\n \r\n"
                },
                {
                    "date": 1726897004841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,10 +48,10 @@\n # Uncomment the following line to run the browser in headless mode\r\n # chrome_options.add_argument('--headless')\r\n \r\n # Optional: Ignore SSL certificate errors (Use with caution)\r\n-# chrome_options.add_argument('--ignore-certificate-errors')\r\n-# chrome_options.add_argument('--ignore-ssl-errors')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n \r\n # Initialize the WebDriver\r\n try:\r\n     driver = webdriver.Chrome(options=chrome_options)\r\n@@ -424,9 +424,38 @@\n         print('Clicked search button.')\r\n \r\n         # Activate the \"Easy Apply\" filter\r\n         activate_easy_apply_filter()\r\n+        # -----------------------------\r\n+        # **New Step: Click Search Button Again**\r\n+        # -----------------------------\r\n+        # This step refreshes the job listings based on the applied filter.\r\n+        try:\r\n+            # Wait until the search button is clickable again\r\n+            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n+            search_button.click()\r\n+            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n \r\n+            # Wait until job listings are loaded again\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Job listings reloaded after applying filter.')\r\n+            print('Job listings reloaded after applying filter.')\r\n+\r\n+            # Get the updated list of job postings\r\n+            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n+            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n+\r\n+        except (NoSuchElementException, TimeoutException) as e:\r\n+            logging.error(f'Error clicking search button again: {e}')\r\n+            print(f'Error clicking search button again: {e}')\r\n+            capture_screenshot('error_clicking_search_again')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n         # Wait until job listings are loaded\r\n         wait.until(EC.presence_of_all_elements_located(\r\n             (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n         ))\r\n"
                },
                {
                    "date": 1726897444791,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,623 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def close_popup():\r\n+    \"\"\"\r\n+    Closes any pop-up or overlay that might be blocking elements.\r\n+    \"\"\"\r\n+    try:\r\n+        # Example XPath for a generic close button (update based on actual pop-up)\r\n+        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n+        popup_close_button.click()\r\n+        logging.info('Closed pop-up successfully.')\r\n+        print('Closed pop-up successfully.')\r\n+        time.sleep(2)  # Wait for the pop-up to close\r\n+    except NoSuchElementException:\r\n+        logging.info('No pop-up to close.')\r\n+        print('No pop-up to close.')\r\n+    except Exception as e:\r\n+        logging.error(f'Error closing pop-up: {e}')\r\n+        print(f'Error closing pop-up: {e}')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        # Handle cases where 'aria-checked' might be missing or None\r\n+        if aria_checked is None:\r\n+            # Determine if the filter is active based on other attributes or states\r\n+            # For example, check if the icon has a 'selected' class\r\n+            try:\r\n+                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n+                class_attribute = icon.get_attribute('class')\r\n+                if 'selected' not in class_attribute:\r\n+                    # Attempt to close any pop-up before clicking\r\n+                    close_popup()\r\n+\r\n+                    # Click using ActionChains to ensure the element is in view\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n+                else:\r\n+                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n+                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n+            except NoSuchElementException:\r\n+                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+        else:\r\n+            if aria_checked.lower() != 'true':\r\n+                # Attempt to close any pop-up before clicking\r\n+                close_popup()\r\n+\r\n+                # Click using ActionChains to ensure the element is in view\r\n+                try:\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                except ElementClickInterceptedException:\r\n+                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+                except ElementNotInteractableException:\r\n+                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+                logging.info('\"Easy Apply\" filter activated.')\r\n+                print('\"Easy Apply\" filter activated.')\r\n+                # Wait for the page to refresh after applying the filter\r\n+                time.sleep(3)  # Adjust as needed based on network speed\r\n+            else:\r\n+                logging.info('\"Easy Apply\" filter is already active.')\r\n+                print('\"Easy Apply\" filter is already active.')\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'pageSize=100&filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+\r\n+def has_apply_now(job_card):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Check if 'Apply now' button is present; if so, skip\r\n+        if has_apply_now(job_card):\r\n+            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+            # Wait for the apply modal to appear\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+\r\n+            # Optional: Wait for a confirmation message or element\r\n+            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+            # logging.info(f'Application confirmed for job: {job_title}')\r\n+\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found within job details\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Ensure the page is fully loaded before attempting to click the search button again\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # -----------------------------\r\n+        # **New Step: Click Search Button Again**\r\n+        # -----------------------------\r\n+        try:\r\n+            # Wait until the search button is present and clickable\r\n+            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n+            \r\n+            # Attempt to click the search button using ActionChains\r\n+            ActionChains(driver).move_to_element(search_button).click().perform()\r\n+            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+\r\n+            # Wait until job listings are loaded again\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Job listings reloaded after applying filter.')\r\n+            print('Job listings reloaded after applying filter.')\r\n+\r\n+            # Get the updated list of job postings\r\n+            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n+            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n+\r\n+        except (NoSuchElementException, TimeoutException) as e:\r\n+            logging.error(f'Error clicking search button again: {e}')\r\n+            print(f'Error clicking search button again: {e}')\r\n+            capture_screenshot('error_clicking_search_again')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Define the criteria for applying\r\n+            criteria = ['Angular', 'Senior Frontend Developer']\r\n+            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n+                print(f\"Applying to job: {job_title}\")\r\n+                logging.info(f\"Applying to job: {job_title}\")\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+                logging.info(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+        # -----------------------------\r\n+        # **New Step: Click Search Button Again**\r\n+        # -----------------------------\r\n+        # This step refreshes the job listings based on the applied filter.\r\n+        try:\r\n+            # Wait until the search button is clickable again\r\n+            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n+            search_button.click()\r\n+            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+\r\n+            # Wait until job listings are loaded again\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Job listings reloaded after applying filter.')\r\n+            print('Job listings reloaded after applying filter.')\r\n+\r\n+            # Get the updated list of job postings\r\n+            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n+            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n+\r\n+        except (NoSuchElementException, TimeoutException) as e:\r\n+            logging.error(f'Error clicking search button again: {e}')\r\n+            print(f'Error clicking search button again: {e}')\r\n+            capture_screenshot('error_clicking_search_again')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Define the criteria for applying\r\n+            criteria = ['Angular', 'Senior Frontend Developer']\r\n+            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n+                print(f\"Applying to job: {job_title}\")\r\n+                logging.info(f\"Applying to job: {job_title}\")\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+                logging.info(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726897604140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -491,9 +491,9 @@\n             logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n             print(f'Job {index}: Title=\"{job_title}\"')\r\n \r\n             # Define the criteria for applying\r\n-            criteria = ['Angular', 'Senior Frontend Developer']\r\n+            criteria = ['Angular', 'Lead', 'Senior', 'Frontend', 'Developer']\r\n             if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n                 print(f\"Applying to job: {job_title}\")\r\n                 logging.info(f\"Applying to job: {job_title}\")\r\n                 apply_to_job(job_card, job_title)\r\n"
                },
                {
                    "date": 1726897743566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -476,110 +476,11 @@\n             try:\r\n                 # Extract the job title using data-cy attribute\r\n                 title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n                 job_title = title_element.text.strip()\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n \r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Define the criteria for applying\r\n-            criteria = ['Angular', 'Lead', 'Senior', 'Frontend', 'Developer']\r\n-            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n-                print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title}\")\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-                logging.info(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-        # -----------------------------\r\n-        # **New Step: Click Search Button Again**\r\n-        # -----------------------------\r\n-        # This step refreshes the job listings based on the applied filter.\r\n-        try:\r\n-            # Wait until the search button is clickable again\r\n-            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n-            search_button.click()\r\n-            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-\r\n-            # Wait until job listings are loaded again\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Job listings reloaded after applying filter.')\r\n-            print('Job listings reloaded after applying filter.')\r\n-\r\n-            # Get the updated list of job postings\r\n-            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n-            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n-\r\n-        except (NoSuchElementException, TimeoutException) as e:\r\n-            logging.error(f'Error clicking search button again: {e}')\r\n-            print(f'Error clicking search button again: {e}')\r\n-            capture_screenshot('error_clicking_search_again')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n             except NoSuchElementException:\r\n                 logging.warning(f'Job {index}: Title element not found.')\r\n                 print(f'Job {index}: Title element not found.')\r\n \r\n@@ -592,21 +493,20 @@\n             # Debugging: Log job titles\r\n             logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n             print(f'Job {index}: Title=\"{job_title}\"')\r\n \r\n-            # Define the criteria for applying\r\n-            criteria = ['Angular', 'Senior Frontend Developer']\r\n-            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n-                print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title}\")\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n                 apply_to_job(job_card, job_title)\r\n \r\n                 # Pause for specified duration before the next application\r\n                 print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n                 time.sleep(PAUSE_DURATION)\r\n             else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n                 print(f\"Skipping job: {job_title}\")\r\n-                logging.info(f\"Skipping job: {job_title}\")\r\n \r\n         print(\"Job application process completed.\")\r\n         logging.info(\"Job application process completed.\")\r\n     except Exception as e:\r\n"
                },
                {
                    "date": 1726898071886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -337,8 +337,72 @@\n         job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         logging.debug(f'Job details loaded for: {job_title}')\r\n         print(f'Job details loaded for: {job_title}')\r\n \r\n+        # Wait an additional 10 seconds to allow the \"Apply now\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Check if 'Apply now' button is present; if so, click it\r\n+        if has_apply_now(job_details):\r\n+            apply_now_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+            apply_now_button.click()\r\n+            logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+            # Optional: Additional steps to complete the application process\r\n+\r\n+            return\r\n+        else:\r\n+            logging.info(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n         # Check if 'Apply now' button is present; if so, skip\r\n         if has_apply_now(job_card):\r\n             logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n             print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n"
                },
                {
                    "date": 1726898330498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,644 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def close_popup():\r\n+    \"\"\"\r\n+    Closes any pop-up or overlay that might be blocking elements.\r\n+    \"\"\"\r\n+    try:\r\n+        # Example XPath for a generic close button (update based on actual pop-up)\r\n+        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n+        popup_close_button.click()\r\n+        logging.info('Closed pop-up successfully.')\r\n+        print('Closed pop-up successfully.')\r\n+        time.sleep(2)  # Wait for the pop-up to close\r\n+    except NoSuchElementException:\r\n+        logging.info('No pop-up to close.')\r\n+        print('No pop-up to close.')\r\n+    except Exception as e:\r\n+        logging.error(f'Error closing pop-up: {e}')\r\n+        print(f'Error closing pop-up: {e}')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        # Handle cases where 'aria-checked' might be missing or None\r\n+        if aria_checked is None:\r\n+            # Determine if the filter is active based on other attributes or states\r\n+            # For example, check if the icon has a 'selected' class\r\n+            try:\r\n+                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n+                class_attribute = icon.get_attribute('class')\r\n+                if 'selected' not in class_attribute:\r\n+                    # Attempt to close any pop-up before clicking\r\n+                    close_popup()\r\n+\r\n+                    # Click using ActionChains to ensure the element is in view\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n+                else:\r\n+                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n+                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n+            except NoSuchElementException:\r\n+                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+        else:\r\n+            if aria_checked.lower() != 'true':\r\n+                # Attempt to close any pop-up before clicking\r\n+                close_popup()\r\n+\r\n+                # Click using ActionChains to ensure the element is in view\r\n+                try:\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                except ElementClickInterceptedException:\r\n+                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+                except ElementNotInteractableException:\r\n+                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+                logging.info('\"Easy Apply\" filter activated.')\r\n+                print('\"Easy Apply\" filter activated.')\r\n+                # Wait for the page to refresh after applying the filter\r\n+                time.sleep(3)  # Adjust as needed based on network speed\r\n+            else:\r\n+                logging.info('\"Easy Apply\" filter is already active.')\r\n+                print('\"Easy Apply\" filter is already active.')\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'pageSize=100&filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+\r\n+def has_apply_now(job_card):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Easy Apply\" or \"Apply now\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Attempt to locate either the \"Easy Apply\" or \"Apply now\" button\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\") or contains(@aria-label, \"Apply now\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n+            print(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n+            \r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+        \r\n+        except NoSuchElementException:\r\n+            logging.info(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n+            print(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply now\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Check if 'Apply now' button is present; if so, click it\r\n+        if has_apply_now(job_details):\r\n+            apply_now_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+            apply_now_button.click()\r\n+            logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+            # Optional: Additional steps to complete the application process\r\n+\r\n+            return\r\n+        else:\r\n+            logging.info(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n+    \r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+            # Wait for the apply modal to appear\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+\r\n+            # Optional: Wait for a confirmation message or element\r\n+            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+            # logging.info(f'Application confirmed for job: {job_title}')\r\n+\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found within job details\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Ensure the page is fully loaded before attempting to click the search button again\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # -----------------------------\r\n+        # **New Step: Click Search Button Again**\r\n+        # -----------------------------\r\n+        try:\r\n+            # Wait until the search button is present and clickable\r\n+            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n+            \r\n+            # Attempt to click the search button using ActionChains\r\n+            ActionChains(driver).move_to_element(search_button).click().perform()\r\n+            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+\r\n+            # Wait until job listings are loaded again\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Job listings reloaded after applying filter.')\r\n+            print('Job listings reloaded after applying filter.')\r\n+\r\n+            # Get the updated list of job postings\r\n+            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n+            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n+\r\n+        except (NoSuchElementException, TimeoutException) as e:\r\n+            logging.error(f'Error clicking search button again: {e}')\r\n+            print(f'Error clicking search button again: {e}')\r\n+            capture_screenshot('error_clicking_search_again')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726898708484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -320,8 +320,71 @@\n         print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n \r\n def apply_to_job(job_card, job_title):\r\n     \"\"\"\r\n+    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Attempt to locate the <apply-button-wc> element\r\n+        try:\r\n+            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n+            apply_button_element.click()\r\n+            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply\" for job: {job_title}')\r\n+            \r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+        \r\n+        except NoSuchElementException:\r\n+            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n     Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n     \"\"\"\r\n     try:\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout\r\n@@ -383,10 +446,9 @@\n         logging.debug(f'Screenshot saved to {screenshot_path}')\r\n         print(f'Screenshot saved to {screenshot_path}')\r\n \r\n     \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n+    Attempts to apply to a job using the \"Easy Apply\",\"Apply now\"\r\n     \"\"\"\r\n     try:\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout\r\n \r\n"
                },
                {
                    "date": 1726899015427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,15 +104,67 @@\n         # Wait until dashboard loads by checking URL or a specific element\r\n         wait.until(EC.url_contains('/dashboard'))\r\n         logging.info('Successfully logged into Dice.')\r\n         print(\"Successfully logged into Dice.\")\r\n+\r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error during login: {e}')\r\n         print(f\"Error during login: {e}\")\r\n         capture_screenshot('login_error')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n def capture_screenshot(name):\r\n     \"\"\"\r\n     Captures a screenshot with the given name.\r\n     \"\"\"\r\n@@ -339,8 +391,72 @@\n \r\n         # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n         time.sleep(10)\r\n \r\n+        # Attempt to locate and click the <apply-button-wc> element\r\n+        try:\r\n+            # Directly target the custom element\r\n+            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n+            apply_button_element.click()\r\n+            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply\" for job: {job_title}')\r\n+\r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+\r\n+        except NoSuchElementException:\r\n+            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n+        time.sleep(10)\r\n+\r\n         # Attempt to locate the <apply-button-wc> element\r\n         try:\r\n             apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n             apply_button_element.click()\r\n"
                },
                {
                    "date": 1726899271527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,935 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def close_popup():\r\n+    \"\"\"\r\n+    Closes any pop-up or overlay that might be blocking elements.\r\n+    \"\"\"\r\n+    try:\r\n+        # Example XPath for a generic close button (update based on actual pop-up)\r\n+        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n+        popup_close_button.click()\r\n+        logging.info('Closed pop-up successfully.')\r\n+        print('Closed pop-up successfully.')\r\n+        time.sleep(2)  # Wait for the pop-up to close\r\n+    except NoSuchElementException:\r\n+        logging.info('No pop-up to close.')\r\n+        print('No pop-up to close.')\r\n+    except Exception as e:\r\n+        logging.error(f'Error closing pop-up: {e}')\r\n+        print(f'Error closing pop-up: {e}')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        # Handle cases where 'aria-checked' might be missing or None\r\n+        if aria_checked is None:\r\n+            # Determine if the filter is active based on other attributes or states\r\n+            # For example, check if the icon has a 'selected' class\r\n+            try:\r\n+                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n+                class_attribute = icon.get_attribute('class')\r\n+                if 'selected' not in class_attribute:\r\n+                    # Attempt to close any pop-up before clicking\r\n+                    close_popup()\r\n+\r\n+                    # Click using ActionChains to ensure the element is in view\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n+                else:\r\n+                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n+                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n+            except NoSuchElementException:\r\n+                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+        else:\r\n+            if aria_checked.lower() != 'true':\r\n+                # Attempt to close any pop-up before clicking\r\n+                close_popup()\r\n+\r\n+                # Click using ActionChains to ensure the element is in view\r\n+                try:\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                except ElementClickInterceptedException:\r\n+                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+                except ElementNotInteractableException:\r\n+                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+                logging.info('\"Easy Apply\" filter activated.')\r\n+                print('\"Easy Apply\" filter activated.')\r\n+                # Wait for the page to refresh after applying the filter\r\n+                time.sleep(3)  # Adjust as needed based on network speed\r\n+            else:\r\n+                logging.info('\"Easy Apply\" filter is already active.')\r\n+                print('\"Easy Apply\" filter is already active.')\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'pageSize=100&filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+\r\n+def has_apply_now(job_card):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait explicitly for the \"Apply now\" button to appear\r\n+        apply_now_button = wait.until(\r\n+            EC.presence_of_element_located((By.XPATH, './/apply-button-wc | .//button[contains(text(), \"Apply now\")]'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Click the \"Apply now\" button\r\n+        apply_now_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Attempt to locate and click the <apply-button-wc> element\r\n+        try:\r\n+            # Directly target the custom element\r\n+            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n+            apply_button_element.click()\r\n+            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply\" for job: {job_title}')\r\n+\r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+\r\n+        except NoSuchElementException:\r\n+            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Attempt to locate the <apply-button-wc> element\r\n+        try:\r\n+            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n+            apply_button_element.click()\r\n+            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply\" for job: {job_title}')\r\n+            \r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+        \r\n+        except NoSuchElementException:\r\n+            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Easy Apply\" or \"Apply now\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Attempt to locate either the \"Easy Apply\" or \"Apply now\" button\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\") or contains(@aria-label, \"Apply now\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n+            print(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n+            \r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+        \r\n+        except NoSuchElementException:\r\n+            logging.info(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n+            print(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\",\"Apply now\"\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply now\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Check if 'Apply now' button is present; if so, click it\r\n+        if has_apply_now(job_details):\r\n+            apply_now_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+            apply_now_button.click()\r\n+            logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+            # Optional: Additional steps to complete the application process\r\n+\r\n+            return\r\n+        else:\r\n+            logging.info(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n+    \r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+            # Wait for the apply modal to appear\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+\r\n+            # Optional: Wait for a confirmation message or element\r\n+            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+            # logging.info(f'Application confirmed for job: {job_title}')\r\n+\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found within job details\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Ensure the page is fully loaded before attempting to click the search button again\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # -----------------------------\r\n+        # **New Step: Click Search Button Again**\r\n+        # -----------------------------\r\n+        try:\r\n+            # Wait until the search button is present and clickable\r\n+            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n+            \r\n+            # Attempt to click the search button using ActionChains\r\n+            ActionChains(driver).move_to_element(search_button).click().perform()\r\n+            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+\r\n+            # Wait until job listings are loaded again\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Job listings reloaded after applying filter.')\r\n+            print('Job listings reloaded after applying filter.')\r\n+\r\n+            # Get the updated list of job postings\r\n+            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n+            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n+\r\n+        except (NoSuchElementException, TimeoutException) as e:\r\n+            logging.error(f'Error clicking search button again: {e}')\r\n+            print(f'Error clicking search button again: {e}')\r\n+            capture_screenshot('error_clicking_search_again')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726899443792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -389,8 +389,50 @@\n         logging.debug(f'Job details loaded for: {job_title}')\r\n         print(f'Job details loaded for: {job_title}')\r\n \r\n         # Wait explicitly for the \"Apply now\" button to appear\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Attempt to click the button within the <apply-button-wc> custom element\r\n+        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait explicitly for the \"Apply now\" button to appear\r\n         apply_now_button = wait.until(\r\n             EC.presence_of_element_located((By.XPATH, './/apply-button-wc | .//button[contains(text(), \"Apply now\")]'))\r\n         )\r\n         logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n"
                },
                {
                    "date": 1726899606279,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -372,8 +372,81 @@\n         print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n \r\n def apply_to_job(job_card, job_title):\r\n     \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handle\r\n+        original_window = driver.current_window_handle\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to it\r\n+        wait.until(EC.number_of_windows_to_be(2))\r\n+        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait explicitly for the \"Apply now\" button to appear\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Attempt to click the button within the <apply-button-wc> custom element\r\n+        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+        # Close the new tab and switch back to the original window\r\n+        driver.close()\r\n+        driver.switch_to.window(original_window)\r\n+        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+\r\n+    \"\"\"\r\n     Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n     \"\"\"\r\n     try:\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout\r\n"
                },
                {
                    "date": 1726899803273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -399,8 +399,83 @@\n         job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         logging.debug(f'Job details loaded for: {job_title}')\r\n         print(f'Job details loaded for: {job_title}')\r\n \r\n+        # Wait explicitly for the \"Apply now\" button within the shadow DOM to appear\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Interact with the shadow DOM to click the button\r\n+        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n+        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+        # Close the new tab and switch back to the original window\r\n+        driver.close()\r\n+        driver.switch_to.window(original_window)\r\n+        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handle\r\n+        original_window = driver.current_window_handle\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to it\r\n+        wait.until(EC.number_of_windows_to_be(2))\r\n+        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n         # Wait explicitly for the \"Apply now\" button to appear\r\n         apply_button_element = wait.until(\r\n             EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n         )\r\n"
                },
                {
                    "date": 1726899819724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1122,1929 +1122,4 @@\n # -----------------------------\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-def close_popup():\r\n-    \"\"\"\r\n-    Closes any pop-up or overlay that might be blocking elements.\r\n-    \"\"\"\r\n-    try:\r\n-        # Example XPath for a generic close button (update based on actual pop-up)\r\n-        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n-        popup_close_button.click()\r\n-        logging.info('Closed pop-up successfully.')\r\n-        print('Closed pop-up successfully.')\r\n-        time.sleep(2)  # Wait for the pop-up to close\r\n-    except NoSuchElementException:\r\n-        logging.info('No pop-up to close.')\r\n-        print('No pop-up to close.')\r\n-    except Exception as e:\r\n-        logging.error(f'Error closing pop-up: {e}')\r\n-        print(f'Error closing pop-up: {e}')\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        # Handle cases where 'aria-checked' might be missing or None\r\n-        if aria_checked is None:\r\n-            # Determine if the filter is active based on other attributes or states\r\n-            # For example, check if the icon has a 'selected' class\r\n-            try:\r\n-                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n-                class_attribute = icon.get_attribute('class')\r\n-                if 'selected' not in class_attribute:\r\n-                    # Attempt to close any pop-up before clicking\r\n-                    close_popup()\r\n-\r\n-                    # Click using ActionChains to ensure the element is in view\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n-                else:\r\n-                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n-                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n-            except NoSuchElementException:\r\n-                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-        else:\r\n-            if aria_checked.lower() != 'true':\r\n-                # Attempt to close any pop-up before clicking\r\n-                close_popup()\r\n-\r\n-                # Click using ActionChains to ensure the element is in view\r\n-                try:\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                except ElementClickInterceptedException:\r\n-                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-                except ElementNotInteractableException:\r\n-                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-                logging.info('\"Easy Apply\" filter activated.')\r\n-                print('\"Easy Apply\" filter activated.')\r\n-                # Wait for the page to refresh after applying the filter\r\n-                time.sleep(3)  # Adjust as needed based on network speed\r\n-            else:\r\n-                logging.info('\"Easy Apply\" filter is already active.')\r\n-                print('\"Easy Apply\" filter is already active.')\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'pageSize=100&filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-\r\n-def has_apply_now(job_card):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate and click the <apply-button-wc> element\r\n-        try:\r\n-            # Directly target the custom element\r\n-            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n-            apply_button_element.click()\r\n-            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply\" for job: {job_title}')\r\n-\r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-\r\n-        except NoSuchElementException:\r\n-            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate the <apply-button-wc> element\r\n-        try:\r\n-            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n-            apply_button_element.click()\r\n-            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply\" for job: {job_title}')\r\n-            \r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-        \r\n-        except NoSuchElementException:\r\n-            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Easy Apply\" or \"Apply now\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate either the \"Easy Apply\" or \"Apply now\" button\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\") or contains(@aria-label, \"Apply now\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n-            print(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n-            \r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-        \r\n-        except NoSuchElementException:\r\n-            logging.info(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n-            print(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\",\"Apply now\"\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply now\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Check if 'Apply now' button is present; if so, click it\r\n-        if has_apply_now(job_details):\r\n-            apply_now_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-            apply_now_button.click()\r\n-            logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-            # Optional: Additional steps to complete the application process\r\n-\r\n-            return\r\n-        else:\r\n-            logging.info(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n-    \r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-            # Wait for the apply modal to appear\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-            # Wait for the resume upload field to be present within the modal\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-            # Optional: Wait for a confirmation message or element\r\n-            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-            # logging.info(f'Application confirmed for job: {job_title}')\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found within job details\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Ensure the page is fully loaded before attempting to click the search button again\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # -----------------------------\r\n-        # **New Step: Click Search Button Again**\r\n-        # -----------------------------\r\n-        try:\r\n-            # Wait until the search button is present and clickable\r\n-            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n-            \r\n-            # Attempt to click the search button using ActionChains\r\n-            ActionChains(driver).move_to_element(search_button).click().perform()\r\n-            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-\r\n-            # Wait until job listings are loaded again\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Job listings reloaded after applying filter.')\r\n-            print('Job listings reloaded after applying filter.')\r\n-\r\n-            # Get the updated list of job postings\r\n-            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n-            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n-\r\n-        except (NoSuchElementException, TimeoutException) as e:\r\n-            logging.error(f'Error clicking search button again: {e}')\r\n-            print(f'Error clicking search button again: {e}')\r\n-            capture_screenshot('error_clicking_search_again')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-def close_popup():\r\n-    \"\"\"\r\n-    Closes any pop-up or overlay that might be blocking elements.\r\n-    \"\"\"\r\n-    try:\r\n-        # Example XPath for a generic close button (update based on actual pop-up)\r\n-        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n-        popup_close_button.click()\r\n-        logging.info('Closed pop-up successfully.')\r\n-        print('Closed pop-up successfully.')\r\n-        time.sleep(2)  # Wait for the pop-up to close\r\n-    except NoSuchElementException:\r\n-        logging.info('No pop-up to close.')\r\n-        print('No pop-up to close.')\r\n-    except Exception as e:\r\n-        logging.error(f'Error closing pop-up: {e}')\r\n-        print(f'Error closing pop-up: {e}')\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        # Handle cases where 'aria-checked' might be missing or None\r\n-        if aria_checked is None:\r\n-            # Determine if the filter is active based on other attributes or states\r\n-            # For example, check if the icon has a 'selected' class\r\n-            try:\r\n-                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n-                class_attribute = icon.get_attribute('class')\r\n-                if 'selected' not in class_attribute:\r\n-                    # Attempt to close any pop-up before clicking\r\n-                    close_popup()\r\n-\r\n-                    # Click using ActionChains to ensure the element is in view\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n-                else:\r\n-                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n-                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n-            except NoSuchElementException:\r\n-                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-        else:\r\n-            if aria_checked.lower() != 'true':\r\n-                # Attempt to close any pop-up before clicking\r\n-                close_popup()\r\n-\r\n-                # Click using ActionChains to ensure the element is in view\r\n-                try:\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                except ElementClickInterceptedException:\r\n-                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-                except ElementNotInteractableException:\r\n-                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-                logging.info('\"Easy Apply\" filter activated.')\r\n-                print('\"Easy Apply\" filter activated.')\r\n-                # Wait for the page to refresh after applying the filter\r\n-                time.sleep(3)  # Adjust as needed based on network speed\r\n-            else:\r\n-                logging.info('\"Easy Apply\" filter is already active.')\r\n-                print('\"Easy Apply\" filter is already active.')\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'pageSize=100&filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-\r\n-def has_apply_now(job_card):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply now\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Check if 'Apply now' button is present; if so, click it\r\n-        if has_apply_now(job_details):\r\n-            apply_now_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-            apply_now_button.click()\r\n-            logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-            # Optional: Additional steps to complete the application process\r\n-\r\n-            return\r\n-        else:\r\n-            logging.info(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Check if 'Apply now' button is present; if so, skip\r\n-        if has_apply_now(job_card):\r\n-            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-            # Wait for the apply modal to appear\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-            # Wait for the resume upload field to be present within the modal\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-            # Optional: Wait for a confirmation message or element\r\n-            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-            # logging.info(f'Application confirmed for job: {job_title}')\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found within job details\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Ensure the page is fully loaded before attempting to click the search button again\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # -----------------------------\r\n-        # **New Step: Click Search Button Again**\r\n-        # -----------------------------\r\n-        try:\r\n-            # Wait until the search button is present and clickable\r\n-            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n-            \r\n-            # Attempt to click the search button using ActionChains\r\n-            ActionChains(driver).move_to_element(search_button).click().perform()\r\n-            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-\r\n-            # Wait until job listings are loaded again\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Job listings reloaded after applying filter.')\r\n-            print('Job listings reloaded after applying filter.')\r\n-\r\n-            # Get the updated list of job postings\r\n-            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n-            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n-\r\n-        except (NoSuchElementException, TimeoutException) as e:\r\n-            logging.error(f'Error clicking search button again: {e}')\r\n-            print(f'Error clicking search button again: {e}')\r\n-            capture_screenshot('error_clicking_search_again')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-def close_popup():\r\n-    \"\"\"\r\n-    Closes any pop-up or overlay that might be blocking elements.\r\n-    \"\"\"\r\n-    try:\r\n-        # Example XPath for a generic close button (update based on actual pop-up)\r\n-        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n-        popup_close_button.click()\r\n-        logging.info('Closed pop-up successfully.')\r\n-        print('Closed pop-up successfully.')\r\n-        time.sleep(2)  # Wait for the pop-up to close\r\n-    except NoSuchElementException:\r\n-        logging.info('No pop-up to close.')\r\n-        print('No pop-up to close.')\r\n-    except Exception as e:\r\n-        logging.error(f'Error closing pop-up: {e}')\r\n-        print(f'Error closing pop-up: {e}')\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        # Handle cases where 'aria-checked' might be missing or None\r\n-        if aria_checked is None:\r\n-            # Determine if the filter is active based on other attributes or states\r\n-            # For example, check if the icon has a 'selected' class\r\n-            try:\r\n-                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n-                class_attribute = icon.get_attribute('class')\r\n-                if 'selected' not in class_attribute:\r\n-                    # Attempt to close any pop-up before clicking\r\n-                    close_popup()\r\n-\r\n-                    # Click using ActionChains to ensure the element is in view\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n-                else:\r\n-                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n-                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n-            except NoSuchElementException:\r\n-                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-        else:\r\n-            if aria_checked.lower() != 'true':\r\n-                # Attempt to close any pop-up before clicking\r\n-                close_popup()\r\n-\r\n-                # Click using ActionChains to ensure the element is in view\r\n-                try:\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                except ElementClickInterceptedException:\r\n-                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-                except ElementNotInteractableException:\r\n-                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-                logging.info('\"Easy Apply\" filter activated.')\r\n-                print('\"Easy Apply\" filter activated.')\r\n-                # Wait for the page to refresh after applying the filter\r\n-                time.sleep(3)  # Adjust as needed based on network speed\r\n-            else:\r\n-                logging.info('\"Easy Apply\" filter is already active.')\r\n-                print('\"Easy Apply\" filter is already active.')\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'pageSize=100&filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-\r\n-def has_apply_now(job_card):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    Skips if \"Apply now\" is present or \"Easy Apply\" is unavailable.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Check if 'Apply now' button is present; if so, skip\r\n-        if has_apply_now(job_card):\r\n-            logging.info(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            print(f'\"Apply now\" button present for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-            # Wait for the apply modal to appear\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-            # Wait for the resume upload field to be present within the modal\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-            # Optional: Wait for a confirmation message or element\r\n-            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-            # logging.info(f'Application confirmed for job: {job_title}')\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found within job details\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-        # -----------------------------\r\n-        # **New Step: Click Search Button Again**\r\n-        # -----------------------------\r\n-        # This step refreshes the job listings based on the applied filter.\r\n-        try:\r\n-            # Wait until the search button is clickable again\r\n-            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n-            search_button.click()\r\n-            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-\r\n-            # Wait until job listings are loaded again\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Job listings reloaded after applying filter.')\r\n-            print('Job listings reloaded after applying filter.')\r\n-\r\n-            # Get the updated list of job postings\r\n-            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n-            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n-\r\n-        except (NoSuchElementException, TimeoutException) as e:\r\n-            logging.error(f'Error clicking search button again: {e}')\r\n-            print(f'Error clicking search button again: {e}')\r\n-            capture_screenshot('error_clicking_search_again')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Define the criteria for applying\r\n-            criteria = ['Angular', 'Senior Frontend Developer']\r\n-            if all(keyword.lower() in job_title.lower() for keyword in criteria):\r\n-                print(f\"Applying to job: {job_title}\")\r\n-                logging.info(f\"Applying to job: {job_title}\")\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-                logging.info(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n"
                },
                {
                    "date": 1726899959877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1201 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def close_popup():\r\n+    \"\"\"\r\n+    Closes any pop-up or overlay that might be blocking elements.\r\n+    \"\"\"\r\n+    try:\r\n+        # Example XPath for a generic close button (update based on actual pop-up)\r\n+        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n+        popup_close_button.click()\r\n+        logging.info('Closed pop-up successfully.')\r\n+        print('Closed pop-up successfully.')\r\n+        time.sleep(2)  # Wait for the pop-up to close\r\n+    except NoSuchElementException:\r\n+        logging.info('No pop-up to close.')\r\n+        print('No pop-up to close.')\r\n+    except Exception as e:\r\n+        logging.error(f'Error closing pop-up: {e}')\r\n+        print(f'Error closing pop-up: {e}')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        # Handle cases where 'aria-checked' might be missing or None\r\n+        if aria_checked is None:\r\n+            # Determine if the filter is active based on other attributes or states\r\n+            # For example, check if the icon has a 'selected' class\r\n+            try:\r\n+                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n+                class_attribute = icon.get_attribute('class')\r\n+                if 'selected' not in class_attribute:\r\n+                    # Attempt to close any pop-up before clicking\r\n+                    close_popup()\r\n+\r\n+                    # Click using ActionChains to ensure the element is in view\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n+                else:\r\n+                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n+                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n+            except NoSuchElementException:\r\n+                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+        else:\r\n+            if aria_checked.lower() != 'true':\r\n+                # Attempt to close any pop-up before clicking\r\n+                close_popup()\r\n+\r\n+                # Click using ActionChains to ensure the element is in view\r\n+                try:\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                except ElementClickInterceptedException:\r\n+                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+                except ElementNotInteractableException:\r\n+                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+                logging.info('\"Easy Apply\" filter activated.')\r\n+                print('\"Easy Apply\" filter activated.')\r\n+                # Wait for the page to refresh after applying the filter\r\n+                time.sleep(3)  # Adjust as needed based on network speed\r\n+            else:\r\n+                logging.info('\"Easy Apply\" filter is already active.')\r\n+                print('\"Easy Apply\" filter is already active.')\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'pageSize=100&filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+\r\n+def has_apply_now(job_card):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handles before clicking the job\r\n+        original_window = driver.current_window_handle\r\n+        original_windows = driver.window_handles\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to the last one\r\n+        wait.until(EC.new_window_is_opened(original_windows))\r\n+        new_window = driver.window_handles[-1]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate and click the \"Apply now\" button within the shadow DOM\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Interact with the shadow DOM to click the button\r\n+        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n+        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+        # Close the new tab and switch back to the original window\r\n+        driver.close()\r\n+        driver.switch_to.window(original_window)\r\n+        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handle\r\n+        original_window = driver.current_window_handle\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to it\r\n+        wait.until(EC.number_of_windows_to_be(2))\r\n+        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait explicitly for the \"Apply now\" button within the shadow DOM to appear\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Interact with the shadow DOM to click the button\r\n+        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n+        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+        # Close the new tab and switch back to the original window\r\n+        driver.close()\r\n+        driver.switch_to.window(original_window)\r\n+        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handle\r\n+        original_window = driver.current_window_handle\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to it\r\n+        wait.until(EC.number_of_windows_to_be(2))\r\n+        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait explicitly for the \"Apply now\" button to appear\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Attempt to click the button within the <apply-button-wc> custom element\r\n+        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+        # Close the new tab and switch back to the original window\r\n+        driver.close()\r\n+        driver.switch_to.window(original_window)\r\n+        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait explicitly for the \"Apply now\" button to appear\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Attempt to click the button within the <apply-button-wc> custom element\r\n+        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait explicitly for the \"Apply now\" button to appear\r\n+        apply_now_button = wait.until(\r\n+            EC.presence_of_element_located((By.XPATH, './/apply-button-wc | .//button[contains(text(), \"Apply now\")]'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Click the \"Apply now\" button\r\n+        apply_now_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Attempt to locate and click the <apply-button-wc> element\r\n+        try:\r\n+            # Directly target the custom element\r\n+            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n+            apply_button_element.click()\r\n+            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply\" for job: {job_title}')\r\n+\r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+\r\n+        except NoSuchElementException:\r\n+            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Attempt to locate the <apply-button-wc> element\r\n+        try:\r\n+            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n+            apply_button_element.click()\r\n+            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply\" for job: {job_title}')\r\n+            \r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+        \r\n+        except NoSuchElementException:\r\n+            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Easy Apply\" or \"Apply now\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Attempt to locate either the \"Easy Apply\" or \"Apply now\" button\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\") or contains(@aria-label, \"Apply now\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n+            print(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n+            \r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+        \r\n+        except NoSuchElementException:\r\n+            logging.info(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n+            print(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\",\"Apply now\"\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply now\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Check if 'Apply now' button is present; if so, click it\r\n+        if has_apply_now(job_details):\r\n+            apply_now_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+            apply_now_button.click()\r\n+            logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+            # Optional: Additional steps to complete the application process\r\n+\r\n+            return\r\n+        else:\r\n+            logging.info(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n+    \r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+            # Wait for the apply modal to appear\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+\r\n+            # Optional: Wait for a confirmation message or element\r\n+            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+            # logging.info(f'Application confirmed for job: {job_title}')\r\n+\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found within job details\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+def main():\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Ensure the page is fully loaded before attempting to click the search button again\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # -----------------------------\r\n+        # **New Step: Click Search Button Again**\r\n+        # -----------------------------\r\n+        try:\r\n+            # Wait until the search button is present and clickable\r\n+            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n+            \r\n+            # Attempt to click the search button using ActionChains\r\n+            ActionChains(driver).move_to_element(search_button).click().perform()\r\n+            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+\r\n+            # Wait until job listings are loaded again\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Job listings reloaded after applying filter.')\r\n+            print('Job listings reloaded after applying filter.')\r\n+\r\n+            # Get the updated list of job postings\r\n+            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n+            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n+\r\n+        except (NoSuchElementException, TimeoutException) as e:\r\n+            logging.error(f'Error clicking search button again: {e}')\r\n+            print(f'Error clicking search button again: {e}')\r\n+            capture_screenshot('error_clicking_search_again')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726900293227,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -400,8 +400,87 @@\n         job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         logging.debug(f'Job details loaded for: {job_title}')\r\n         print(f'Job details loaded for: {job_title}')\r\n \r\n+        # Attempt to locate the custom <apply-button> element\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Interact with the Shadow DOM to click the button\r\n+        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n+        if shadow_root is None:\r\n+            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n+        \r\n+        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+        # Close the new tab and switch back to the original window\r\n+        driver.close()\r\n+        driver.switch_to.window(original_window)\r\n+        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handles before clicking the job\r\n+        original_window = driver.current_window_handle\r\n+        original_windows = driver.window_handles\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to the last one\r\n+        wait.until(EC.new_window_is_opened(original_windows))\r\n+        new_window = driver.window_handles[-1]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n         # Attempt to locate and click the \"Apply now\" button within the shadow DOM\r\n         apply_button_element = wait.until(\r\n             EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n         )\r\n"
                },
                {
                    "date": 1726900445415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -419,8 +419,76 @@\n         print(f'Clicked \"Apply now\" for job: {job_title}')\r\n \r\n         # Optional: Additional steps to complete the application process\r\n \r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+    finally:\r\n+        # Ensure that the new tab is closed and switch back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new tab and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new tab and switched back to original window after processing {job_title}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handles before clicking the job\r\n+        original_window = driver.current_window_handle\r\n+        original_windows = driver.window_handles\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to the last one\r\n+        wait.until(EC.new_window_is_opened(original_windows))\r\n+        new_window = driver.window_handles[-1]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the custom <apply-button> element\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Interact with the Shadow DOM to click the button\r\n+        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n+        if shadow_root is None:\r\n+            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n+        \r\n+        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n         # Close the new tab and switch back to the original window\r\n         driver.close()\r\n         driver.switch_to.window(original_window)\r\n         logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n"
                },
                {
                    "date": 1726900659811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1493 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def close_popup():\r\n+    \"\"\"\r\n+    Closes any pop-up or overlay that might be blocking elements.\r\n+    \"\"\"\r\n+    try:\r\n+        # Example XPath for a generic close button (update based on actual pop-up)\r\n+        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n+        popup_close_button.click()\r\n+        logging.info('Closed pop-up successfully.')\r\n+        print('Closed pop-up successfully.')\r\n+        time.sleep(2)  # Wait for the pop-up to close\r\n+    except NoSuchElementException:\r\n+        logging.info('No pop-up to close.')\r\n+        print('No pop-up to close.')\r\n+    except Exception as e:\r\n+        logging.error(f'Error closing pop-up: {e}')\r\n+        print(f'Error closing pop-up: {e}')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        # Handle cases where 'aria-checked' might be missing or None\r\n+        if aria_checked is None:\r\n+            # Determine if the filter is active based on other attributes or states\r\n+            # For example, check if the icon has a 'selected' class\r\n+            try:\r\n+                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n+                class_attribute = icon.get_attribute('class')\r\n+                if 'selected' not in class_attribute:\r\n+                    # Attempt to close any pop-up before clicking\r\n+                    close_popup()\r\n+\r\n+                    # Click using ActionChains to ensure the element is in view\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n+                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n+                else:\r\n+                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n+                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n+            except NoSuchElementException:\r\n+                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n+        else:\r\n+            if aria_checked.lower() != 'true':\r\n+                # Attempt to close any pop-up before clicking\r\n+                close_popup()\r\n+\r\n+                # Click using ActionChains to ensure the element is in view\r\n+                try:\r\n+                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                except ElementClickInterceptedException:\r\n+                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+                except ElementNotInteractableException:\r\n+                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+                logging.info('\"Easy Apply\" filter activated.')\r\n+                print('\"Easy Apply\" filter activated.')\r\n+                # Wait for the page to refresh after applying the filter\r\n+                time.sleep(3)  # Adjust as needed based on network speed\r\n+            else:\r\n+                logging.info('\"Easy Apply\" filter is already active.')\r\n+                print('\"Easy Apply\" filter is already active.')\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'pageSize=100&filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+\r\n+def has_apply_now(job_card):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handles before clicking the job\r\n+        original_window = driver.current_window_handle\r\n+        original_windows = driver.window_handles\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to the last one\r\n+        wait.until(EC.new_window_is_opened(original_windows))\r\n+        new_window = driver.window_handles[-1]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the custom <apply-button> element\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Interact with the Shadow DOM to click the button\r\n+        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n+        if shadow_root is None:\r\n+            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n+        \r\n+        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        applied_jobs.add(job_title)  # Add the job to the set of applied jobs\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+    finally:\r\n+        # Ensure that the new tab is closed and switch back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new tab and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new tab and switched back to original window after processing {job_title}')\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handles before clicking the job\r\n+        original_window = driver.current_window_handle\r\n+        original_windows = driver.window_handles\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to the last one\r\n+        wait.until(EC.new_window_is_opened(original_windows))\r\n+        new_window = driver.window_handles[-1]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the custom <apply-button> element\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Interact with the Shadow DOM to click the button\r\n+        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n+        if shadow_root is None:\r\n+            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n+        \r\n+        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+    finally:\r\n+        # Ensure that the new tab is closed and switch back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new tab and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new tab and switched back to original window after processing {job_title}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handles before clicking the job\r\n+        original_window = driver.current_window_handle\r\n+        original_windows = driver.window_handles\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to the last one\r\n+        wait.until(EC.new_window_is_opened(original_windows))\r\n+        new_window = driver.window_handles[-1]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the custom <apply-button> element\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Interact with the Shadow DOM to click the button\r\n+        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n+        if shadow_root is None:\r\n+            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n+        \r\n+        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+        # Close the new tab and switch back to the original window\r\n+        driver.close()\r\n+        driver.switch_to.window(original_window)\r\n+        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handles before clicking the job\r\n+        original_window = driver.current_window_handle\r\n+        original_windows = driver.window_handles\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to the last one\r\n+        wait.until(EC.new_window_is_opened(original_windows))\r\n+        new_window = driver.window_handles[-1]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate and click the \"Apply now\" button within the shadow DOM\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Interact with the shadow DOM to click the button\r\n+        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n+        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+        # Close the new tab and switch back to the original window\r\n+        driver.close()\r\n+        driver.switch_to.window(original_window)\r\n+        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handle\r\n+        original_window = driver.current_window_handle\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to it\r\n+        wait.until(EC.number_of_windows_to_be(2))\r\n+        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait explicitly for the \"Apply now\" button within the shadow DOM to appear\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Interact with the shadow DOM to click the button\r\n+        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n+        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+        # Close the new tab and switch back to the original window\r\n+        driver.close()\r\n+        driver.switch_to.window(original_window)\r\n+        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handle\r\n+        original_window = driver.current_window_handle\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to it\r\n+        wait.until(EC.number_of_windows_to_be(2))\r\n+        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait explicitly for the \"Apply now\" button to appear\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Attempt to click the button within the <apply-button-wc> custom element\r\n+        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+        # Close the new tab and switch back to the original window\r\n+        driver.close()\r\n+        driver.switch_to.window(original_window)\r\n+        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+        # Make sure to close the new tab and switch back if necessary\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait explicitly for the \"Apply now\" button to appear\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Attempt to click the button within the <apply-button-wc> custom element\r\n+        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait explicitly for the \"Apply now\" button to appear\r\n+        apply_now_button = wait.until(\r\n+            EC.presence_of_element_located((By.XPATH, './/apply-button-wc | .//button[contains(text(), \"Apply now\")]'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Click the \"Apply now\" button\r\n+        apply_now_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        # Optional: Additional steps to complete the application process\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Attempt to locate and click the <apply-button-wc> element\r\n+        try:\r\n+            # Directly target the custom element\r\n+            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n+            apply_button_element.click()\r\n+            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply\" for job: {job_title}')\r\n+\r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+\r\n+        except NoSuchElementException:\r\n+            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Attempt to locate the <apply-button-wc> element\r\n+        try:\r\n+            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n+            apply_button_element.click()\r\n+            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply\" for job: {job_title}')\r\n+            \r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+        \r\n+        except NoSuchElementException:\r\n+            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Easy Apply\" or \"Apply now\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Attempt to locate either the \"Easy Apply\" or \"Apply now\" button\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\") or contains(@aria-label, \"Apply now\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n+            print(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n+            \r\n+            # Optional: Additional steps to complete the application process\r\n+            return\r\n+        \r\n+        except NoSuchElementException:\r\n+            logging.info(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n+            print(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\",\"Apply now\"\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Wait an additional 10 seconds to allow the \"Apply now\" button to load\r\n+        time.sleep(10)\r\n+\r\n+        # Check if 'Apply now' button is present; if so, click it\r\n+        if has_apply_now(job_details):\r\n+            apply_now_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+            apply_now_button.click()\r\n+            logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+            print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+            # Optional: Additional steps to complete the application process\r\n+\r\n+            return\r\n+        else:\r\n+            logging.info(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n+            return\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n+    \r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+            # Wait for the apply modal to appear\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+\r\n+            # Optional: Wait for a confirmation message or element\r\n+            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+            # logging.info(f'Application confirmed for job: {job_title}')\r\n+\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found within job details\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Ensure the page is fully loaded before attempting to click the search button again\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # -----------------------------\r\n+        # **New Step: Click Search Button Again**\r\n+        # -----------------------------\r\n+        try:\r\n+            # Wait until the search button is present and clickable\r\n+            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n+            \r\n+            # Attempt to click the search button using ActionChains\r\n+            ActionChains(driver).move_to_element(search_button).click().perform()\r\n+            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n+\r\n+            # Wait until job listings are loaded again\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Job listings reloaded after applying filter.')\r\n+            print('Job listings reloaded after applying filter.')\r\n+\r\n+            # Get the updated list of job postings\r\n+            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n+            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n+\r\n+        except (NoSuchElementException, TimeoutException) as e:\r\n+            logging.error(f'Error clicking search button again: {e}')\r\n+            print(f'Error clicking search button again: {e}')\r\n+            capture_screenshot('error_clicking_search_again')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until job listings are loaded\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726900902948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -404,8 +404,79 @@\n         job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         logging.debug(f'Job details loaded for: {job_title}')\r\n         print(f'Job details loaded for: {job_title}')\r\n \r\n+        # Attempt to locate the \"Apply now\" button\r\n+        apply_button_element = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n+        )\r\n+        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n+        print(f'\"Apply now\" button found for job: {job_title}')\r\n+\r\n+        # Interact with the Shadow DOM to click the button\r\n+        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n+        if shadow_root is None:\r\n+            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n+        \r\n+        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        apply_button.click()\r\n+        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n+        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n+\r\n+        applied_jobs.add(job_title)  # Add the job to the set of applied jobs\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n+        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n+    except (NoSuchElementException, WebDriverException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'apply_error_{job_title}')\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n+    finally:\r\n+        # Ensure that the new tab is closed and switch back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new tab and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new tab and switched back to original window after processing {job_title}')\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n+    handling the scenario where the job details open in a new tab.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Get the current window handles before clicking the job\r\n+        original_window = driver.current_window_handle\r\n+        original_windows = driver.window_handles\r\n+\r\n+        # Click on the job title to open job details (which might open in a new tab)\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the new tab to open and switch to the last one\r\n+        wait.until(EC.new_window_is_opened(original_windows))\r\n+        new_window = driver.window_handles[-1]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new tab for job: {job_title}')\r\n+        print(f'Switched to new tab for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load in the new tab\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n         # Attempt to locate the custom <apply-button> element\r\n         apply_button_element = wait.until(\r\n             EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n         )\r\n@@ -1305,8 +1376,10 @@\n         logging.error(f'An error occurred in main(): {e}')\r\n         print(f\"An error occurred in main(): {e}\")\r\n     finally:\r\n         driver.quit()\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n     login_to_dice()\r\n \r\n     try:\r\n         # Enter search criteria\r\n@@ -1359,8 +1432,78 @@\n             # Simplified criteria for applying\r\n             if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n                 logging.info(f'Job {index}: Applying to job: {job_title}')\r\n                 print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n                 apply_to_job(job_card, job_title)\r\n \r\n                 # Pause for specified duration before the next application\r\n                 print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n"
                },
                {
                    "date": 1726901265445,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,468 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def close_popup():\r\n+    \"\"\"\r\n+    Closes any pop-up or overlay that might be blocking elements.\r\n+    \"\"\"\r\n+    try:\r\n+        # Example XPath for a generic close button (update based on actual pop-up)\r\n+        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n+        popup_close_button.click()\r\n+        logging.info('Closed pop-up successfully.')\r\n+        print('Closed pop-up successfully.')\r\n+        time.sleep(2)  # Wait for the pop-up to close\r\n+    except NoSuchElementException:\r\n+        logging.info('No pop-up to close.')\r\n+        print('No pop-up to close.')\r\n+    except Exception as e:\r\n+        logging.error(f'Error closing pop-up: {e}')\r\n+        print(f'Error closing pop-up: {e}')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked.lower() != 'true':\r\n+            # Attempt to close any pop-up before clicking\r\n+            close_popup()\r\n+\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException):\r\n+                logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+        else:\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(job_card):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button within job details\r\n+        try:\r\n+            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+            # Wait for the apply modal to appear\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+\r\n+            # Add the job to the set of applied jobs\r\n+            applied_jobs.add(job_title)\r\n+\r\n+            # Optional: Wait for a confirmation message or element\r\n+            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n+            # logging.info(f'Application confirmed for job: {job_title}')\r\n+\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found within job details\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except ElementClickInterceptedException as e:\r\n+        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('click_intercepted')\r\n+\r\n+    except ElementNotInteractableException as e:\r\n+        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n+        capture_screenshot('element_not_interactable')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726901493276,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -151,9 +151,9 @@\n     except Exception as e:\r\n         logging.error(f'Error closing pop-up: {e}')\r\n         print(f'Error closing pop-up: {e}')\r\n \r\n-def activate_easy_apply_filter():\r\n+defdef activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     Ensures that the filter button is clickable and not obscured by overlays.\r\n     \"\"\"\r\n@@ -218,8 +218,125 @@\n         aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n         logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n         print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n \r\n+        # Adjusted condition to handle NoneType\r\n+        if aria_checked == 'true':\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Attempt to close any pop-up before clicking\r\n+            close_popup()\r\n+\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException):\r\n+                logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n         if aria_checked.lower() != 'true':\r\n             # Attempt to close any pop-up before clicking\r\n             close_popup()\r\n \r\n"
                },
                {
                    "date": 1726901511746,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -151,9 +151,9 @@\n     except Exception as e:\r\n         logging.error(f'Error closing pop-up: {e}')\r\n         print(f'Error closing pop-up: {e}')\r\n \r\n-defdef activate_easy_apply_filter():\r\n+def activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     Ensures that the filter button is clickable and not obscured by overlays.\r\n     \"\"\"\r\n"
                },
                {
                    "date": 1726901770118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -427,10 +427,121 @@\n             return  # Skip if we've already applied to this job\r\n \r\n         wait = WebDriverWait(driver, 20)  # Increased timeout\r\n \r\n+        # Scroll the job card into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n         # Click on the job title to open job details\r\n         title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button within job details\r\n+        try:\r\n+            # The 'Easy Apply' button might be within a shadow DOM or have dynamic attributes\r\n+            # First, try to find it directly\r\n+            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(@aria-label, \"Easy Apply\")]')\r\n+            easy_apply_button.click()\r\n+            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+\r\n+            # Wait for the apply modal to appear\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+\r\n+            # Wait for the resume upload field to be present within the modal\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+            # Wait for the 'Submit' button to be clickable and click it\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+\r\n+            # Add the job to the set of applied jobs\r\n+            applied_jobs.add(job_title)\r\n+\r\n+        except NoSuchElementException:\r\n+            # 'Easy Apply' button not found within job details\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Click on the job title to open job details\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n         title_element.click()\r\n         logging.info(f'Clicked on job title: {job_title}')\r\n         print(f'Clicked on job title: {job_title}')\r\n \r\n"
                },
                {
                    "date": 1726901975349,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,38 +71,44 @@\n     \"\"\"\r\n     Logs into Dice.com using the provided email and password.\r\n     \"\"\"\r\n     try:\r\n+        logging.info('Navigating to Dice login page.')\r\n         driver.get('https://www.dice.com/dashboard/login')\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n \r\n         # Wait for the email field to be present\r\n+        logging.info('Waiting for email field.')\r\n         email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n         email_field.clear()\r\n         email_field.send_keys(EMAIL)\r\n         logging.info('Entered email.')\r\n         print('Entered email.')\r\n \r\n         # Locate and click the \"Continue\" button\r\n+        logging.info('Locating \"Continue\" button.')\r\n         continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n         continue_button.click()\r\n         logging.info('Clicked \"Continue\" button.')\r\n         print('Clicked \"Continue\" button.')\r\n \r\n         # Wait for the password field to be present\r\n+        logging.info('Waiting for password field.')\r\n         password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n         password_field.clear()\r\n         password_field.send_keys(PASSWORD)\r\n         logging.info('Entered password.')\r\n         print('Entered password.')\r\n \r\n         # Locate and click the \"Sign In\" button\r\n+        logging.info('Locating \"Sign In\" button.')\r\n         sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n         sign_in_button.click()\r\n         logging.info('Clicked \"Sign In\" button.')\r\n         print('Clicked \"Sign In\" button.')\r\n \r\n         # Wait until dashboard loads by checking URL or a specific element\r\n+        logging.info('Waiting for dashboard to load.')\r\n         wait.until(EC.url_contains('/dashboard'))\r\n         logging.info('Successfully logged into Dice.')\r\n         print(\"Successfully logged into Dice.\")\r\n \r\n@@ -139,9 +145,9 @@\n     Closes any pop-up or overlay that might be blocking elements.\r\n     \"\"\"\r\n     try:\r\n         # Example XPath for a generic close button (update based on actual pop-up)\r\n-        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n+        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button\")]')\r\n         popup_close_button.click()\r\n         logging.info('Closed pop-up successfully.')\r\n         print('Closed pop-up successfully.')\r\n         time.sleep(2)  # Wait for the pop-up to close\r\n@@ -151,8 +157,24 @@\n     except Exception as e:\r\n         logging.error(f'Error closing pop-up: {e}')\r\n         print(f'Error closing pop-up: {e}')\r\n \r\n+def close_fixed_elements():\r\n+    \"\"\"\r\n+    Closes or hides fixed elements like headers or footers that might block clicks.\r\n+    \"\"\"\r\n+    try:\r\n+        # Example: Hide a fixed header if it's blocking clicks\r\n+        driver.execute_script(\"\"\"\r\n+            var header = document.querySelector('header');\r\n+            if (header) {\r\n+                header.style.position = 'static';\r\n+            }\r\n+        \"\"\")\r\n+        logging.info('Adjusted fixed elements.')\r\n+    except Exception as e:\r\n+        logging.error(f'Error adjusting fixed elements: {e}')\r\n+\r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     Ensures that the filter button is clickable and not obscured by overlays.\r\n@@ -160,8 +182,9 @@\n     try:\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n \r\n         # Wait for the filters widget to load\r\n+        logging.info('Waiting for filters widget.')\r\n         filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n         logging.info('Filters widget located.')\r\n         print('Filters widget located.')\r\n \r\n@@ -171,8 +194,9 @@\n         print('Logged filters widget inner HTML for debugging.')\r\n \r\n         # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n         try:\r\n+            logging.info('Locating \"Easy Apply\" accordion.')\r\n             easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n                 EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n             )\r\n             logging.info('\"Easy Apply\" accordion located.')\r\n@@ -189,8 +213,9 @@\n         time.sleep(1)  # Wait for scrolling animation\r\n \r\n         # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n         try:\r\n+            logging.info('Locating \"Easy Apply\" filter button.')\r\n             easy_apply_filter_button = easy_apply_accordion.find_element(\r\n                 By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n             )\r\n             logging.info('\"Easy Apply\" filter button located.')\r\n@@ -203,8 +228,9 @@\n             exit(1)\r\n \r\n         # Wait until the \"Easy Apply\" filter button is clickable\r\n         try:\r\n+            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n             easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n                 EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n             )\r\n         except TimeoutException:\r\n@@ -218,21 +244,22 @@\n         aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n         logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n         print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n \r\n-        # Adjusted condition to handle NoneType\r\n         if aria_checked == 'true':\r\n             logging.info('\"Easy Apply\" filter is already active.')\r\n             print('\"Easy Apply\" filter is already active.')\r\n         else:\r\n             # Attempt to close any pop-up before clicking\r\n             close_popup()\r\n+            close_fixed_elements()\r\n \r\n             # Click using ActionChains to ensure the element is in view\r\n             try:\r\n+                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n                 ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException):\r\n-                logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n                 driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n \r\n             logging.info('\"Easy Apply\" filter activated.')\r\n             print('\"Easy Apply\" filter activated.')\r\n@@ -269,124 +296,8 @@\n         capture_screenshot('unexpected_error_easy_apply_filter')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked.lower() != 'true':\r\n-            # Attempt to close any pop-up before clicking\r\n-            close_popup()\r\n-\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException):\r\n-                logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-        else:\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n def has_apply_now(job_card):\r\n     \"\"\"\r\n     Checks if a job card contains an \"Apply now\" button.\r\n     Returns True if present, False otherwise.\r\n@@ -428,18 +339,26 @@\n \r\n         wait = WebDriverWait(driver, 20)  # Increased timeout\r\n \r\n         # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n         driver.execute_script(\"arguments[0].scrollIntoView(true);\", job_card)\r\n         time.sleep(1)  # Wait for scrolling animation\r\n \r\n+        # Close any pop-ups or fixed elements\r\n+        close_popup()\r\n+        close_fixed_elements()\r\n+\r\n         # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n         title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n \r\n         # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n         wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n \r\n         try:\r\n+            logging.info(f'Attempting to click on job title: {job_title}')\r\n             title_element.click()\r\n             logging.info(f'Clicked on job title: {job_title}')\r\n             print(f'Clicked on job title: {job_title}')\r\n         except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n@@ -459,33 +378,48 @@\n             logging.info(f'Job details opened in the same window for job: {job_title}')\r\n             print(f'Job details opened in the same window for job: {job_title}')\r\n \r\n         # Wait for the job details panel to load\r\n+        logging.info(f'Waiting for job details to load for: {job_title}')\r\n         job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         logging.debug(f'Job details loaded for: {job_title}')\r\n         print(f'Job details loaded for: {job_title}')\r\n \r\n         # Attempt to locate the 'Easy Apply' button within job details\r\n         try:\r\n+            logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n             # The 'Easy Apply' button might be within a shadow DOM or have dynamic attributes\r\n-            # First, try to find it directly\r\n+            # Try different methods to locate it\r\n+\r\n+            # Method 1: Directly find the button\r\n             easy_apply_button = driver.find_element(By.XPATH, '//button[contains(@aria-label, \"Easy Apply\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            logging.info(f'\"Easy Apply\" button found for job: {job_title}')\r\n+            print(f'\"Easy Apply\" button found for job: {job_title}')\r\n \r\n+            # Click the \"Easy Apply\" button\r\n+            try:\r\n+                easy_apply_button.click()\r\n+                logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n+\r\n             # Wait for the apply modal to appear\r\n+            logging.info(f'Waiting for apply modal for job: {job_title}')\r\n             modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n             logging.debug(f'Apply modal appeared for job: {job_title}')\r\n             print(f'Apply modal appeared for job: {job_title}')\r\n \r\n             # Wait for the resume upload field to be present within the modal\r\n+            logging.info(f'Locating resume upload field for job: {job_title}')\r\n             upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n             upload_field.send_keys(RESUME_PATH)\r\n             logging.info(f'Uploaded resume for job: {job_title}')\r\n             print(f'Uploaded resume for job: {job_title}')\r\n \r\n             # Wait for the 'Submit' button to be clickable and click it\r\n+            logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n             submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n             submit_button.click()\r\n             logging.info(f'Successfully applied to {job_title}')\r\n             print(f\"Successfully applied to {job_title}\")\r\n@@ -519,8 +453,9 @@\n \r\n     except Exception as e:\r\n         logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n         print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{job_title}')\r\n \r\n     finally:\r\n         # Ensure that any new window is closed and focus is back to the original window\r\n         if len(driver.window_handles) > 1:\r\n@@ -528,108 +463,26 @@\n             driver.switch_to.window(original_window)\r\n             logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n             print(f'Closed new window and switched back to original window after processing {job_title}')\r\n \r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button within job details\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-            # Wait for the apply modal to appear\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-            # Wait for the resume upload field to be present within the modal\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-            # Add the job to the set of applied jobs\r\n-            applied_jobs.add(job_title)\r\n-\r\n-            # Optional: Wait for a confirmation message or element\r\n-            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-            # logging.info(f'Application confirmed for job: {job_title}')\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found within job details\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n def main():\r\n     applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n     login_to_dice()\r\n \r\n     try:\r\n+        logging.info('Navigating to Dice homepage.')\r\n         # Enter search criteria\r\n         driver.get('https://www.dice.com/')\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n         search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n         search_field.clear()\r\n         search_field.send_keys(SEARCH_TERMS)\r\n         logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n         print(f'Entered search terms: {SEARCH_TERMS}')\r\n \r\n+        logging.info('Locating search button.')\r\n         search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n         search_button.click()\r\n         logging.info('Clicked search button.')\r\n         print('Clicked search button.')\r\n@@ -640,15 +493,17 @@\n         # Wait for job listings to load\r\n         time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n \r\n         # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n         job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n         logging.info(f'Found {len(job_cards)} job postings.')\r\n         print(f'Found {len(job_cards)} job postings.')\r\n \r\n         for index, job_card in enumerate(job_cards, start=1):\r\n             try:\r\n                 # Extract the job title using data-cy attribute\r\n+                logging.info(f'Processing job {index}.')\r\n                 title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n                 job_title = title_element.text.strip()\r\n                 logging.info(f'Job {index}: Found title: {job_title}')\r\n                 print(f'Job {index}: Found title: {job_title}')\r\n"
                },
                {
                    "date": 1726901977627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -548,4113 +548,4 @@\n # -----------------------------\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-def close_popup():\r\n-    \"\"\"\r\n-    Closes any pop-up or overlay that might be blocking elements.\r\n-    \"\"\"\r\n-    try:\r\n-        # Example XPath for a generic close button (update based on actual pop-up)\r\n-        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n-        popup_close_button.click()\r\n-        logging.info('Closed pop-up successfully.')\r\n-        print('Closed pop-up successfully.')\r\n-        time.sleep(2)  # Wait for the pop-up to close\r\n-    except NoSuchElementException:\r\n-        logging.info('No pop-up to close.')\r\n-        print('No pop-up to close.')\r\n-    except Exception as e:\r\n-        logging.error(f'Error closing pop-up: {e}')\r\n-        print(f'Error closing pop-up: {e}')\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        # Handle cases where 'aria-checked' might be missing or None\r\n-        if aria_checked is None:\r\n-            # Determine if the filter is active based on other attributes or states\r\n-            # For example, check if the icon has a 'selected' class\r\n-            try:\r\n-                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n-                class_attribute = icon.get_attribute('class')\r\n-                if 'selected' not in class_attribute:\r\n-                    # Attempt to close any pop-up before clicking\r\n-                    close_popup()\r\n-\r\n-                    # Click using ActionChains to ensure the element is in view\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n-                else:\r\n-                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n-                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n-            except NoSuchElementException:\r\n-                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-        else:\r\n-            if aria_checked.lower() != 'true':\r\n-                # Attempt to close any pop-up before clicking\r\n-                close_popup()\r\n-\r\n-                # Click using ActionChains to ensure the element is in view\r\n-                try:\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                except ElementClickInterceptedException:\r\n-                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-                except ElementNotInteractableException:\r\n-                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-                logging.info('\"Easy Apply\" filter activated.')\r\n-                print('\"Easy Apply\" filter activated.')\r\n-                # Wait for the page to refresh after applying the filter\r\n-                time.sleep(3)  # Adjust as needed based on network speed\r\n-            else:\r\n-                logging.info('\"Easy Apply\" filter is already active.')\r\n-                print('\"Easy Apply\" filter is already active.')\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'pageSize=100&filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-\r\n-def has_apply_now(job_card):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handles before clicking the job\r\n-        original_window = driver.current_window_handle\r\n-        original_windows = driver.window_handles\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to the last one\r\n-        wait.until(EC.new_window_is_opened(original_windows))\r\n-        new_window = driver.window_handles[-1]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the \"Apply now\" button\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Interact with the Shadow DOM to click the button\r\n-        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n-        if shadow_root is None:\r\n-            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n-        \r\n-        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        applied_jobs.add(job_title)  # Add the job to the set of applied jobs\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-    finally:\r\n-        # Ensure that the new tab is closed and switch back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new tab and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new tab and switched back to original window after processing {job_title}')\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handles before clicking the job\r\n-        original_window = driver.current_window_handle\r\n-        original_windows = driver.window_handles\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to the last one\r\n-        wait.until(EC.new_window_is_opened(original_windows))\r\n-        new_window = driver.window_handles[-1]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the custom <apply-button> element\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Interact with the Shadow DOM to click the button\r\n-        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n-        if shadow_root is None:\r\n-            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n-        \r\n-        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        applied_jobs.add(job_title)  # Add the job to the set of applied jobs\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-    finally:\r\n-        # Ensure that the new tab is closed and switch back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new tab and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new tab and switched back to original window after processing {job_title}')\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handles before clicking the job\r\n-        original_window = driver.current_window_handle\r\n-        original_windows = driver.window_handles\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to the last one\r\n-        wait.until(EC.new_window_is_opened(original_windows))\r\n-        new_window = driver.window_handles[-1]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the custom <apply-button> element\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Interact with the Shadow DOM to click the button\r\n-        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n-        if shadow_root is None:\r\n-            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n-        \r\n-        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-    finally:\r\n-        # Ensure that the new tab is closed and switch back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new tab and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new tab and switched back to original window after processing {job_title}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handles before clicking the job\r\n-        original_window = driver.current_window_handle\r\n-        original_windows = driver.window_handles\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to the last one\r\n-        wait.until(EC.new_window_is_opened(original_windows))\r\n-        new_window = driver.window_handles[-1]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the custom <apply-button> element\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Interact with the Shadow DOM to click the button\r\n-        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n-        if shadow_root is None:\r\n-            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n-        \r\n-        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-        # Close the new tab and switch back to the original window\r\n-        driver.close()\r\n-        driver.switch_to.window(original_window)\r\n-        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handles before clicking the job\r\n-        original_window = driver.current_window_handle\r\n-        original_windows = driver.window_handles\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to the last one\r\n-        wait.until(EC.new_window_is_opened(original_windows))\r\n-        new_window = driver.window_handles[-1]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate and click the \"Apply now\" button within the shadow DOM\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Interact with the shadow DOM to click the button\r\n-        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n-        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-        # Close the new tab and switch back to the original window\r\n-        driver.close()\r\n-        driver.switch_to.window(original_window)\r\n-        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handle\r\n-        original_window = driver.current_window_handle\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to it\r\n-        wait.until(EC.number_of_windows_to_be(2))\r\n-        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button within the shadow DOM to appear\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Interact with the shadow DOM to click the button\r\n-        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n-        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-        # Close the new tab and switch back to the original window\r\n-        driver.close()\r\n-        driver.switch_to.window(original_window)\r\n-        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handle\r\n-        original_window = driver.current_window_handle\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to it\r\n-        wait.until(EC.number_of_windows_to_be(2))\r\n-        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button to appear\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Attempt to click the button within the <apply-button-wc> custom element\r\n-        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-        # Close the new tab and switch back to the original window\r\n-        driver.close()\r\n-        driver.switch_to.window(original_window)\r\n-        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button to appear\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Attempt to click the button within the <apply-button-wc> custom element\r\n-        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button to appear\r\n-        apply_now_button = wait.until(\r\n-            EC.presence_of_element_located((By.XPATH, './/apply-button-wc | .//button[contains(text(), \"Apply now\")]'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Click the \"Apply now\" button\r\n-        apply_now_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate and click the <apply-button-wc> element\r\n-        try:\r\n-            # Directly target the custom element\r\n-            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n-            apply_button_element.click()\r\n-            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply\" for job: {job_title}')\r\n-\r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-\r\n-        except NoSuchElementException:\r\n-            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate the <apply-button-wc> element\r\n-        try:\r\n-            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n-            apply_button_element.click()\r\n-            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply\" for job: {job_title}')\r\n-            \r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-        \r\n-        except NoSuchElementException:\r\n-            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Easy Apply\" or \"Apply now\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate either the \"Easy Apply\" or \"Apply now\" button\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\") or contains(@aria-label, \"Apply now\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n-            print(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n-            \r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-        \r\n-        except NoSuchElementException:\r\n-            logging.info(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n-            print(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\",\"Apply now\"\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply now\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Check if 'Apply now' button is present; if so, click it\r\n-        if has_apply_now(job_details):\r\n-            apply_now_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-            apply_now_button.click()\r\n-            logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-            # Optional: Additional steps to complete the application process\r\n-\r\n-            return\r\n-        else:\r\n-            logging.info(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n-    \r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-            # Wait for the apply modal to appear\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-            # Wait for the resume upload field to be present within the modal\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-            # Optional: Wait for a confirmation message or element\r\n-            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-            # logging.info(f'Application confirmed for job: {job_title}')\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found within job details\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Ensure the page is fully loaded before attempting to click the search button again\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # -----------------------------\r\n-        # **New Step: Click Search Button Again**\r\n-        # -----------------------------\r\n-        try:\r\n-            # Wait until the search button is present and clickable\r\n-            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n-            \r\n-            # Attempt to click the search button using ActionChains\r\n-            ActionChains(driver).move_to_element(search_button).click().perform()\r\n-            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-\r\n-            # Wait until job listings are loaded again\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Job listings reloaded after applying filter.')\r\n-            print('Job listings reloaded after applying filter.')\r\n-\r\n-            # Get the updated list of job postings\r\n-            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n-            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n-\r\n-        except (NoSuchElementException, TimeoutException) as e:\r\n-            logging.error(f'Error clicking search button again: {e}')\r\n-            print(f'Error clicking search button again: {e}')\r\n-            capture_screenshot('error_clicking_search_again')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-def close_popup():\r\n-    \"\"\"\r\n-    Closes any pop-up or overlay that might be blocking elements.\r\n-    \"\"\"\r\n-    try:\r\n-        # Example XPath for a generic close button (update based on actual pop-up)\r\n-        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n-        popup_close_button.click()\r\n-        logging.info('Closed pop-up successfully.')\r\n-        print('Closed pop-up successfully.')\r\n-        time.sleep(2)  # Wait for the pop-up to close\r\n-    except NoSuchElementException:\r\n-        logging.info('No pop-up to close.')\r\n-        print('No pop-up to close.')\r\n-    except Exception as e:\r\n-        logging.error(f'Error closing pop-up: {e}')\r\n-        print(f'Error closing pop-up: {e}')\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        # Handle cases where 'aria-checked' might be missing or None\r\n-        if aria_checked is None:\r\n-            # Determine if the filter is active based on other attributes or states\r\n-            # For example, check if the icon has a 'selected' class\r\n-            try:\r\n-                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n-                class_attribute = icon.get_attribute('class')\r\n-                if 'selected' not in class_attribute:\r\n-                    # Attempt to close any pop-up before clicking\r\n-                    close_popup()\r\n-\r\n-                    # Click using ActionChains to ensure the element is in view\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n-                else:\r\n-                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n-                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n-            except NoSuchElementException:\r\n-                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-        else:\r\n-            if aria_checked.lower() != 'true':\r\n-                # Attempt to close any pop-up before clicking\r\n-                close_popup()\r\n-\r\n-                # Click using ActionChains to ensure the element is in view\r\n-                try:\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                except ElementClickInterceptedException:\r\n-                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-                except ElementNotInteractableException:\r\n-                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-                logging.info('\"Easy Apply\" filter activated.')\r\n-                print('\"Easy Apply\" filter activated.')\r\n-                # Wait for the page to refresh after applying the filter\r\n-                time.sleep(3)  # Adjust as needed based on network speed\r\n-            else:\r\n-                logging.info('\"Easy Apply\" filter is already active.')\r\n-                print('\"Easy Apply\" filter is already active.')\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'pageSize=100&filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-\r\n-def has_apply_now(job_card):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handles before clicking the job\r\n-        original_window = driver.current_window_handle\r\n-        original_windows = driver.window_handles\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to the last one\r\n-        wait.until(EC.new_window_is_opened(original_windows))\r\n-        new_window = driver.window_handles[-1]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the custom <apply-button> element\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Interact with the Shadow DOM to click the button\r\n-        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n-        if shadow_root is None:\r\n-            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n-        \r\n-        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-    finally:\r\n-        # Ensure that the new tab is closed and switch back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new tab and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new tab and switched back to original window after processing {job_title}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handles before clicking the job\r\n-        original_window = driver.current_window_handle\r\n-        original_windows = driver.window_handles\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to the last one\r\n-        wait.until(EC.new_window_is_opened(original_windows))\r\n-        new_window = driver.window_handles[-1]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the custom <apply-button> element\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button.job-app'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Interact with the Shadow DOM to click the button\r\n-        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n-        if shadow_root is None:\r\n-            raise Exception(\"Unable to find shadow root for apply-button element.\")\r\n-        \r\n-        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-        # Close the new tab and switch back to the original window\r\n-        driver.close()\r\n-        driver.switch_to.window(original_window)\r\n-        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handles before clicking the job\r\n-        original_window = driver.current_window_handle\r\n-        original_windows = driver.window_handles\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to the last one\r\n-        wait.until(EC.new_window_is_opened(original_windows))\r\n-        new_window = driver.window_handles[-1]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate and click the \"Apply now\" button within the shadow DOM\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Interact with the shadow DOM to click the button\r\n-        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n-        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-        # Close the new tab and switch back to the original window\r\n-        driver.close()\r\n-        driver.switch_to.window(original_window)\r\n-        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handle\r\n-        original_window = driver.current_window_handle\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to it\r\n-        wait.until(EC.number_of_windows_to_be(2))\r\n-        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button within the shadow DOM to appear\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Interact with the shadow DOM to click the button\r\n-        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n-        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-        # Close the new tab and switch back to the original window\r\n-        driver.close()\r\n-        driver.switch_to.window(original_window)\r\n-        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handle\r\n-        original_window = driver.current_window_handle\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to it\r\n-        wait.until(EC.number_of_windows_to_be(2))\r\n-        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button to appear\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Attempt to click the button within the <apply-button-wc> custom element\r\n-        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-        # Close the new tab and switch back to the original window\r\n-        driver.close()\r\n-        driver.switch_to.window(original_window)\r\n-        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button to appear\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Attempt to click the button within the <apply-button-wc> custom element\r\n-        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button to appear\r\n-        apply_now_button = wait.until(\r\n-            EC.presence_of_element_located((By.XPATH, './/apply-button-wc | .//button[contains(text(), \"Apply now\")]'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Click the \"Apply now\" button\r\n-        apply_now_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate and click the <apply-button-wc> element\r\n-        try:\r\n-            # Directly target the custom element\r\n-            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n-            apply_button_element.click()\r\n-            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply\" for job: {job_title}')\r\n-\r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-\r\n-        except NoSuchElementException:\r\n-            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate the <apply-button-wc> element\r\n-        try:\r\n-            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n-            apply_button_element.click()\r\n-            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply\" for job: {job_title}')\r\n-            \r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-        \r\n-        except NoSuchElementException:\r\n-            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Easy Apply\" or \"Apply now\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate either the \"Easy Apply\" or \"Apply now\" button\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\") or contains(@aria-label, \"Apply now\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n-            print(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n-            \r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-        \r\n-        except NoSuchElementException:\r\n-            logging.info(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n-            print(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\",\"Apply now\"\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply now\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Check if 'Apply now' button is present; if so, click it\r\n-        if has_apply_now(job_details):\r\n-            apply_now_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-            apply_now_button.click()\r\n-            logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-            # Optional: Additional steps to complete the application process\r\n-\r\n-            return\r\n-        else:\r\n-            logging.info(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n-    \r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-            # Wait for the apply modal to appear\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-            # Wait for the resume upload field to be present within the modal\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-            # Optional: Wait for a confirmation message or element\r\n-            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-            # logging.info(f'Application confirmed for job: {job_title}')\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found within job details\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Ensure the page is fully loaded before attempting to click the search button again\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # -----------------------------\r\n-        # **New Step: Click Search Button Again**\r\n-        # -----------------------------\r\n-        try:\r\n-            # Wait until the search button is present and clickable\r\n-            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n-            \r\n-            # Attempt to click the search button using ActionChains\r\n-            ActionChains(driver).move_to_element(search_button).click().perform()\r\n-            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-\r\n-            # Wait until job listings are loaded again\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Job listings reloaded after applying filter.')\r\n-            print('Job listings reloaded after applying filter.')\r\n-\r\n-            # Get the updated list of job postings\r\n-            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n-            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n-\r\n-        except (NoSuchElementException, TimeoutException) as e:\r\n-            logging.error(f'Error clicking search button again: {e}')\r\n-            print(f'Error clicking search button again: {e}')\r\n-            capture_screenshot('error_clicking_search_again')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-def close_popup():\r\n-    \"\"\"\r\n-    Closes any pop-up or overlay that might be blocking elements.\r\n-    \"\"\"\r\n-    try:\r\n-        # Example XPath for a generic close button (update based on actual pop-up)\r\n-        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button-class\")]')\r\n-        popup_close_button.click()\r\n-        logging.info('Closed pop-up successfully.')\r\n-        print('Closed pop-up successfully.')\r\n-        time.sleep(2)  # Wait for the pop-up to close\r\n-    except NoSuchElementException:\r\n-        logging.info('No pop-up to close.')\r\n-        print('No pop-up to close.')\r\n-    except Exception as e:\r\n-        logging.error(f'Error closing pop-up: {e}')\r\n-        print(f'Error closing pop-up: {e}')\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        # Handle cases where 'aria-checked' might be missing or None\r\n-        if aria_checked is None:\r\n-            # Determine if the filter is active based on other attributes or states\r\n-            # For example, check if the icon has a 'selected' class\r\n-            try:\r\n-                icon = easy_apply_filter_button.find_element(By.TAG_NAME, 'i')\r\n-                class_attribute = icon.get_attribute('class')\r\n-                if 'selected' not in class_attribute:\r\n-                    # Attempt to close any pop-up before clicking\r\n-                    close_popup()\r\n-\r\n-                    # Click using ActionChains to ensure the element is in view\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                    logging.info('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    print('\"Easy Apply\" filter activated (based on icon class).')\r\n-                    time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n-                else:\r\n-                    logging.info('\"Easy Apply\" filter is already active (based on icon class).')\r\n-                    print('\"Easy Apply\" filter is already active (based on icon class).')\r\n-            except NoSuchElementException:\r\n-                logging.warning('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-                print('\"Easy Apply\" icon not found. Assuming filter is active.')\r\n-        else:\r\n-            if aria_checked.lower() != 'true':\r\n-                # Attempt to close any pop-up before clicking\r\n-                close_popup()\r\n-\r\n-                # Click using ActionChains to ensure the element is in view\r\n-                try:\r\n-                    ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                except ElementClickInterceptedException:\r\n-                    logging.warning('\"Easy Apply\" filter button click intercepted. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-                except ElementNotInteractableException:\r\n-                    logging.warning('\"Easy Apply\" filter button not interactable. Attempting JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-                logging.info('\"Easy Apply\" filter activated.')\r\n-                print('\"Easy Apply\" filter activated.')\r\n-                # Wait for the page to refresh after applying the filter\r\n-                time.sleep(3)  # Adjust as needed based on network speed\r\n-            else:\r\n-                logging.info('\"Easy Apply\" filter is already active.')\r\n-                print('\"Easy Apply\" filter is already active.')\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'pageSize=100&filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&pageSize=100&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-\r\n-def has_apply_now(job_card):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handle\r\n-        original_window = driver.current_window_handle\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to it\r\n-        wait.until(EC.number_of_windows_to_be(2))\r\n-        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button within the shadow DOM to appear\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Interact with the shadow DOM to click the button\r\n-        shadow_root = driver.execute_script(\"return arguments[0].shadowRoot\", apply_button_element)\r\n-        apply_button = shadow_root.find_element(By.CSS_SELECTOR, 'button')\r\n-        apply_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-        # Close the new tab and switch back to the original window\r\n-        driver.close()\r\n-        driver.switch_to.window(original_window)\r\n-        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element,\r\n-    handling the scenario where the job details open in a new tab.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Get the current window handle\r\n-        original_window = driver.current_window_handle\r\n-\r\n-        # Click on the job title to open job details (which might open in a new tab)\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the new tab to open and switch to it\r\n-        wait.until(EC.number_of_windows_to_be(2))\r\n-        new_window = [window for window in driver.window_handles if window != original_window][0]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new tab for job: {job_title}')\r\n-        print(f'Switched to new tab for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load in the new tab\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button to appear\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Attempt to click the button within the <apply-button-wc> custom element\r\n-        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-        # Close the new tab and switch back to the original window\r\n-        driver.close()\r\n-        driver.switch_to.window(original_window)\r\n-        logging.info(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-        print(f'Closed new tab and switched back to original window after applying to {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-        # Make sure to close the new tab and switch back if necessary\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button to appear\r\n-        apply_button_element = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'apply-button-wc'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Attempt to click the button within the <apply-button-wc> custom element\r\n-        driver.execute_script(\"arguments[0].shadowRoot.querySelector('button').click();\", apply_button_element)\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply now\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait explicitly for the \"Apply now\" button to appear\r\n-        apply_now_button = wait.until(\r\n-            EC.presence_of_element_located((By.XPATH, './/apply-button-wc | .//button[contains(text(), \"Apply now\")]'))\r\n-        )\r\n-        logging.info(f'\"Apply now\" button found for job: {job_title}')\r\n-        print(f'\"Apply now\" button found for job: {job_title}')\r\n-\r\n-        # Click the \"Apply now\" button\r\n-        apply_now_button.click()\r\n-        logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-        print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-        # Optional: Additional steps to complete the application process\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        print(f'Error: \"Apply now\" button not found for \"{job_title}\" after waiting.')\r\n-        capture_screenshot(f'apply_now_button_missing_{job_title}')\r\n-    except (NoSuchElementException, WebDriverException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'apply_error_{job_title}')\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        print(f'Unexpected error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'unexpected_apply_error_{job_title}')\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate and click the <apply-button-wc> element\r\n-        try:\r\n-            # Directly target the custom element\r\n-            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n-            apply_button_element.click()\r\n-            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply\" for job: {job_title}')\r\n-\r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-\r\n-        except NoSuchElementException:\r\n-            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Apply\" button inside the <apply-button-wc> element.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate the <apply-button-wc> element\r\n-        try:\r\n-            apply_button_element = job_details.find_element(By.XPATH, './/apply-button-wc')\r\n-            apply_button_element.click()\r\n-            logging.info(f'Clicked \"Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply\" for job: {job_title}')\r\n-            \r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-        \r\n-        except NoSuchElementException:\r\n-            logging.info(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            print(f'<apply-button-wc> element not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Easy Apply\" or \"Apply now\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Attempt to locate either the \"Easy Apply\" or \"Apply now\" button\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\") or contains(@aria-label, \"Apply now\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n-            print(f'Clicked \"{easy_apply_button.get_attribute(\"aria-label\")}\" for job: {job_title}')\r\n-            \r\n-            # Optional: Additional steps to complete the application process\r\n-            return\r\n-        \r\n-        except NoSuchElementException:\r\n-            logging.info(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n-            print(f'Neither \"Easy Apply\" nor \"Apply now\" button found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\",\"Apply now\"\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Wait an additional 10 seconds to allow the \"Apply now\" button to load\r\n-        time.sleep(10)\r\n-\r\n-        # Check if 'Apply now' button is present; if so, click it\r\n-        if has_apply_now(job_details):\r\n-            apply_now_button = job_details.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-            apply_now_button.click()\r\n-            logging.info(f'Clicked \"Apply now\" for job: {job_title}')\r\n-            print(f'Clicked \"Apply now\" for job: {job_title}')\r\n-\r\n-            # Optional: Additional steps to complete the application process\r\n-\r\n-            return\r\n-        else:\r\n-            logging.info(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Apply now\" button not found for job: {job_title}. Skipping application.')\r\n-            return\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" or \"Apply now\" option.\r\n-    \r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Click on the job title to open job details\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button within job details using a precise selector\r\n-        try:\r\n-            easy_apply_button = job_details.find_element(By.XPATH, './/button[contains(@aria-label, \"Easy Apply\")]')\r\n-            easy_apply_button.click()\r\n-            logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-\r\n-            # Wait for the apply modal to appear\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-            # Wait for the resume upload field to be present within the modal\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-            # Optional: Wait for a confirmation message or element\r\n-            # confirmation = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(text(), \"Application submitted\")]')))\r\n-            # logging.info(f'Application confirmed for job: {job_title}')\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found within job details\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except ElementClickInterceptedException as e:\r\n-        logging.error(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        print(f'Click intercepted while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('click_intercepted')\r\n-\r\n-    except ElementNotInteractableException as e:\r\n-        logging.error(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        print(f'Element not interactable while applying to \"{job_title}\": {e}')\r\n-        capture_screenshot('element_not_interactable')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}_error.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-\r\n-def main():\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Ensure the page is fully loaded before attempting to click the search button again\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # -----------------------------\r\n-        # **New Step: Click Search Button Again**\r\n-        # -----------------------------\r\n-        try:\r\n-            # Wait until the search button is present and clickable\r\n-            search_button = wait.until(EC.element_to_be_clickable((By.ID, 'submitSearch-button')))\r\n-            \r\n-            # Attempt to click the search button using ActionChains\r\n-            ActionChains(driver).move_to_element(search_button).click().perform()\r\n-            logging.info('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-            print('Clicked search button again after applying \"Easy Apply\" filter.')\r\n-\r\n-            # Wait until job listings are loaded again\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Job listings reloaded after applying filter.')\r\n-            print('Job listings reloaded after applying filter.')\r\n-\r\n-            # Get the updated list of job postings\r\n-            job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            logging.info(f'Found {len(job_cards)} job postings after applying filter.')\r\n-            print(f'Found {len(job_cards)} job postings after applying filter.')\r\n-\r\n-        except (NoSuchElementException, TimeoutException) as e:\r\n-            logging.error(f'Error clicking search button again: {e}')\r\n-            print(f'Error clicking search button again: {e}')\r\n-            capture_screenshot('error_clicking_search_again')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until job listings are loaded\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n-\r\n-        # Get the list of job postings\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n"
                },
                {
                    "date": 1726902302702,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -139,42 +139,8 @@\n     except Exception as e:\r\n         logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n         print(f'Failed to capture screenshot \"{name}\": {e}')\r\n \r\n-def close_popup():\r\n-    \"\"\"\r\n-    Closes any pop-up or overlay that might be blocking elements.\r\n-    \"\"\"\r\n-    try:\r\n-        # Example XPath for a generic close button (update based on actual pop-up)\r\n-        popup_close_button = driver.find_element(By.XPATH, '//button[contains(@class, \"close-button\")]')\r\n-        popup_close_button.click()\r\n-        logging.info('Closed pop-up successfully.')\r\n-        print('Closed pop-up successfully.')\r\n-        time.sleep(2)  # Wait for the pop-up to close\r\n-    except NoSuchElementException:\r\n-        logging.info('No pop-up to close.')\r\n-        print('No pop-up to close.')\r\n-    except Exception as e:\r\n-        logging.error(f'Error closing pop-up: {e}')\r\n-        print(f'Error closing pop-up: {e}')\r\n-\r\n-def close_fixed_elements():\r\n-    \"\"\"\r\n-    Closes or hides fixed elements like headers or footers that might block clicks.\r\n-    \"\"\"\r\n-    try:\r\n-        # Example: Hide a fixed header if it's blocking clicks\r\n-        driver.execute_script(\"\"\"\r\n-            var header = document.querySelector('header');\r\n-            if (header) {\r\n-                header.style.position = 'static';\r\n-            }\r\n-        \"\"\")\r\n-        logging.info('Adjusted fixed elements.')\r\n-    except Exception as e:\r\n-        logging.error(f'Error adjusting fixed elements: {e}')\r\n-\r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     Ensures that the filter button is clickable and not obscured by overlays.\r\n@@ -248,12 +214,8 @@\n         if aria_checked == 'true':\r\n             logging.info('\"Easy Apply\" filter is already active.')\r\n             print('\"Easy Apply\" filter is already active.')\r\n         else:\r\n-            # Attempt to close any pop-up before clicking\r\n-            close_popup()\r\n-            close_fixed_elements()\r\n-\r\n             # Click using ActionChains to ensure the element is in view\r\n             try:\r\n                 logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n                 ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n@@ -340,15 +302,11 @@\n         wait = WebDriverWait(driver, 20)  # Increased timeout\r\n \r\n         # Scroll the job card into view\r\n         logging.info(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", job_card)\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n         time.sleep(1)  # Wait for scrolling animation\r\n \r\n-        # Close any pop-ups or fixed elements\r\n-        close_popup()\r\n-        close_fixed_elements()\r\n-\r\n         # Click on the job title to open job details\r\n         logging.info(f'Locating job title link for: {job_title}')\r\n         title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n \r\n@@ -379,60 +337,61 @@\n             print(f'Job details opened in the same window for job: {job_title}')\r\n \r\n         # Wait for the job details panel to load\r\n         logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        job_details = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n         logging.debug(f'Job details loaded for: {job_title}')\r\n         print(f'Job details loaded for: {job_title}')\r\n \r\n-        # Attempt to locate the 'Easy Apply' button within job details\r\n+        # Attempt to locate the 'Easy Apply' button\r\n         try:\r\n             logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n-            # The 'Easy Apply' button might be within a shadow DOM or have dynamic attributes\r\n-            # Try different methods to locate it\r\n+            # Update the selector based on the actual button\r\n+            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n+            if easy_apply_button.is_displayed():\r\n+                # Scroll the button into view\r\n+                driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_button)\r\n+                time.sleep(0.5)\r\n+                try:\r\n+                    easy_apply_button.click()\r\n+                    logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                    print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                    logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n+            else:\r\n+                logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n+                print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n+                return  # Exit if the button is not visible\r\n+        except NoSuchElementException:\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            return  # Exit if the button is not found\r\n \r\n-            # Method 1: Directly find the button\r\n-            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(@aria-label, \"Easy Apply\")]')\r\n-            logging.info(f'\"Easy Apply\" button found for job: {job_title}')\r\n-            print(f'\"Easy Apply\" button found for job: {job_title}')\r\n+        # Wait for the apply modal to appear\r\n+        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n+        modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+        logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+        print(f'Apply modal appeared for job: {job_title}')\r\n \r\n-            # Click the \"Easy Apply\" button\r\n-            try:\r\n-                easy_apply_button.click()\r\n-                logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n+        # Wait for the resume upload field to be present within the modal\r\n+        logging.info(f'Locating resume upload field for job: {job_title}')\r\n+        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+        upload_field.send_keys(RESUME_PATH)\r\n+        logging.info(f'Uploaded resume for job: {job_title}')\r\n+        print(f'Uploaded resume for job: {job_title}')\r\n \r\n-            # Wait for the apply modal to appear\r\n-            logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n+        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+        submit_button.click()\r\n+        logging.info(f'Successfully applied to {job_title}')\r\n+        print(f\"Successfully applied to {job_title}\")\r\n \r\n-            # Wait for the resume upload field to be present within the modal\r\n-            logging.info(f'Locating resume upload field for job: {job_title}')\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n \r\n-            # Wait for the 'Submit' button to be clickable and click it\r\n-            logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-\r\n-            # Add the job to the set of applied jobs\r\n-            applied_jobs.add(job_title)\r\n-\r\n-        except NoSuchElementException:\r\n-            # 'Easy Apply' button not found within job details\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-\r\n         # Close the new window or navigate back\r\n         if len(driver.window_handles) > 1:\r\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n"
                },
                {
                    "date": 1726902566606,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,406 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info('Navigating to Dice login page.')\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        logging.info('Waiting for email field.')\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        logging.info('Locating \"Continue\" button.')\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        logging.info('Waiting for password field.')\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        logging.info('Locating \"Sign In\" button.')\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        logging.info('Waiting for dashboard to load.')\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def sanitize_filename(filename):\r\n+    # Remove invalid characters from filename\r\n+    return \"\".join([c if c.isalnum() or c in (' ', '_') else '_' for c in filename]).rstrip()\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Navigates directly to the search results with \"Easy Apply\" filter applied.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Navigate directly to the URL with the \"Easy Apply\" filter applied\r\n+        search_terms_encoded = SEARCH_TERMS.replace(' ', '+')\r\n+        filtered_url = f'https://www.dice.com/jobs?q={search_terms_encoded}&filters.easyApply=true'\r\n+        driver.get(filtered_url)\r\n+        logging.info(f'Navigated to filtered URL: {filtered_url}')\r\n+        print(f'Navigated to filtered URL: {filtered_url}')\r\n+\r\n+        # Wait for job listings to load\r\n+        wait.until(EC.presence_of_all_elements_located(\r\n+            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        ))\r\n+        logging.info('Job listings loaded with \"Easy Apply\" filter applied.')\r\n+        print('Job listings loaded with \"Easy Apply\" filter applied.')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Error navigating to filtered URL: {e}')\r\n+        print(f'Error navigating to filtered URL: {e}')\r\n+        capture_screenshot('error_navigating_filtered_url')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_easy_apply(job_card):\r\n+    \"\"\"\r\n+    Checks if the job card indicates that it is an \"Easy Apply\" job.\r\n+    \"\"\"\r\n+    try:\r\n+        # Look for an element in the job card that indicates \"Easy Apply\"\r\n+        easy_apply_indicator = job_card.find_element(By.XPATH, './/span[contains(text(), \"Easy Apply\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_filename(job_title)\r\n+        screenshot_path = f'screenshot_job_{sanitized_title}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            logging.info(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Log the current URL\r\n+        current_url = driver.current_url\r\n+        logging.info(f'Current URL after switching to job details: {current_url}')\r\n+        print(f'Current URL after switching to job details: {current_url}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        logging.info(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button\r\n+        try:\r\n+            logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n+            # Update the selector based on the actual button\r\n+            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n+            if easy_apply_button.is_displayed():\r\n+                # Scroll the button into view\r\n+                driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_button)\r\n+                time.sleep(0.5)\r\n+                try:\r\n+                    easy_apply_button.click()\r\n+                    logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                    print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                    logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n+            else:\r\n+                logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n+                print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n+                # Capture screenshot\r\n+                capture_screenshot(f'easy_apply_not_visible_{sanitize_filename(job_title)}')\r\n+                return  # Exit if the button is not visible\r\n+        except NoSuchElementException:\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            # Log current URL\r\n+            current_url = driver.current_url\r\n+            logging.info(f'Current URL when \"Easy Apply\" not found: {current_url}')\r\n+            print(f'Current URL when \"Easy Apply\" not found: {current_url}')\r\n+            # Capture screenshot\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_filename(job_title)}')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # The rest of the code for uploading resume and submitting application remains the same\r\n+        # ...\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_filename(job_title)}')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        logging.info('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        logging.info('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                logging.info(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                # Check if the job card has an \"Easy Apply\" indicator\r\n+                if has_easy_apply(job_card):\r\n+                    logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                    print(f'Applying to job: {job_title}')\r\n+                    apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                    # Pause for specified duration before the next application\r\n+                    print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                    time.sleep(PAUSE_DURATION)\r\n+                else:\r\n+                    logging.info(f'Job {index}: Job \"{job_title}\" does not have \"Easy Apply\". Skipping.')\r\n+                    print(f'Job \"{job_title}\" does not have \"Easy Apply\". Skipping.')\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726902650041,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -139,47 +139,134 @@\n     except Exception as e:\r\n         logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n         print(f'Failed to capture screenshot \"{name}\": {e}')\r\n \r\n-def sanitize_filename(filename):\r\n-    # Remove invalid characters from filename\r\n-    return \"\".join([c if c.isalnum() or c in (' ', '_') else '_' for c in filename]).rstrip()\r\n-\r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n-    Navigates directly to the search results with \"Easy Apply\" filter applied.\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n     \"\"\"\r\n     try:\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n \r\n-        # Navigate directly to the URL with the \"Easy Apply\" filter applied\r\n-        search_terms_encoded = SEARCH_TERMS.replace(' ', '+')\r\n-        filtered_url = f'https://www.dice.com/jobs?q={search_terms_encoded}&filters.easyApply=true'\r\n-        driver.get(filtered_url)\r\n-        logging.info(f'Navigated to filtered URL: {filtered_url}')\r\n-        print(f'Navigated to filtered URL: {filtered_url}')\r\n+        # Wait for the filters widget to load\r\n+        logging.info('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n \r\n-        # Wait for job listings to load\r\n-        wait.until(EC.presence_of_all_elements_located(\r\n-            (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        ))\r\n-        logging.info('Job listings loaded with \"Easy Apply\" filter applied.')\r\n-        print('Job listings loaded with \"Easy Apply\" filter applied.')\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n \r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n     except Exception as e:\r\n-        logging.error(f'Error navigating to filtered URL: {e}')\r\n-        print(f'Error navigating to filtered URL: {e}')\r\n-        capture_screenshot('error_navigating_filtered_url')\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n-def has_easy_apply(job_card):\r\n+def has_apply_now(job_card):\r\n     \"\"\"\r\n-    Checks if the job card indicates that it is an \"Easy Apply\" job.\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n     \"\"\"\r\n     try:\r\n-        # Look for an element in the job card that indicates \"Easy Apply\"\r\n-        easy_apply_indicator = job_card.find_element(By.XPATH, './/span[contains(text(), \"Easy Apply\")]')\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n         return True\r\n     except NoSuchElementException:\r\n         return False\r\n \r\n@@ -193,10 +280,10 @@\n         logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n         print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n \r\n         # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_filename(job_title)\r\n-        screenshot_path = f'screenshot_job_{sanitized_title}.png'\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n         driver.save_screenshot(screenshot_path)\r\n         logging.debug(f'Screenshot saved to {screenshot_path}')\r\n         print(f'Screenshot saved to {screenshot_path}')\r\n     except Exception as e:\r\n@@ -248,13 +335,8 @@\n             # Job details opened in the same window\r\n             logging.info(f'Job details opened in the same window for job: {job_title}')\r\n             print(f'Job details opened in the same window for job: {job_title}')\r\n \r\n-        # Log the current URL\r\n-        current_url = driver.current_url\r\n-        logging.info(f'Current URL after switching to job details: {current_url}')\r\n-        print(f'Current URL after switching to job details: {current_url}')\r\n-\r\n         # Wait for the job details panel to load\r\n         logging.info(f'Waiting for job details to load for: {job_title}')\r\n         wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n@@ -279,25 +361,49 @@\n                     driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n             else:\r\n                 logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n                 print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n-                # Capture screenshot\r\n-                capture_screenshot(f'easy_apply_not_visible_{sanitize_filename(job_title)}')\r\n                 return  # Exit if the button is not visible\r\n         except NoSuchElementException:\r\n             logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            # Log current URL\r\n-            current_url = driver.current_url\r\n-            logging.info(f'Current URL when \"Easy Apply\" not found: {current_url}')\r\n-            print(f'Current URL when \"Easy Apply\" not found: {current_url}')\r\n-            # Capture screenshot\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_filename(job_title)}')\r\n             return  # Exit if the button is not found\r\n \r\n-        # The rest of the code for uploading resume and submitting application remains the same\r\n-        # ...\r\n+        # Wait for the apply modal to appear\r\n+        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n+        modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+        logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+        print(f'Apply modal appeared for job: {job_title}')\r\n \r\n+        # Wait for the resume upload field to be present within the modal\r\n+        logging.info(f'Locating resume upload field for job: {job_title}')\r\n+        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+        upload_field.send_keys(RESUME_PATH)\r\n+        logging.info(f'Uploaded resume for job: {job_title}')\r\n+        print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n+        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+        submit_button.click()\r\n+        logging.info(f'Successfully applied to {job_title}')\r\n+        print(f\"Successfully applied to {job_title}\")\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error applying to \"{job_title}\": {e}')\r\n         print(f'Error applying to \"{job_title}\": {e}')\r\n \r\n@@ -306,9 +412,9 @@\n \r\n     except Exception as e:\r\n         logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n         print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_filename(job_title)}')\r\n+        capture_screenshot(f'error_applying_{job_title}')\r\n \r\n     finally:\r\n         # Ensure that any new window is closed and focus is back to the original window\r\n         if len(driver.window_handles) > 1:\r\n@@ -342,8 +448,11 @@\n \r\n         # Activate the \"Easy Apply\" filter\r\n         activate_easy_apply_filter()\r\n \r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n         # Get the list of job postings\r\n         logging.info('Locating job cards.')\r\n         job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n         logging.info(f'Found {len(job_cards)} job postings.')\r\n@@ -373,20 +482,15 @@\n             print(f'Job {index}: Title=\"{job_title}\"')\r\n \r\n             # Simplified criteria for applying\r\n             if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                # Check if the job card has an \"Easy Apply\" indicator\r\n-                if has_easy_apply(job_card):\r\n-                    logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                    print(f'Applying to job: {job_title}')\r\n-                    apply_to_job(job_card, job_title, applied_jobs)\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n \r\n-                    # Pause for specified duration before the next application\r\n-                    print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                    time.sleep(PAUSE_DURATION)\r\n-                else:\r\n-                    logging.info(f'Job {index}: Job \"{job_title}\" does not have \"Easy Apply\". Skipping.')\r\n-                    print(f'Job \"{job_title}\" does not have \"Easy Apply\". Skipping.')\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n             else:\r\n                 logging.info(f'Job {index}: Skipping job: {job_title}')\r\n                 print(f\"Skipping job: {job_title}\")\r\n \r\n"
                },
                {
                    "date": 1726902749431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,445 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s',\r\n+    handlers=[\r\n+        logging.FileHandler('application_log.txt'),\r\n+        logging.StreamHandler()  # This will output logs to the console\r\n+    ]\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info('Navigating to Dice login page.')\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        logging.info('Waiting for email field.')\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        logging.info('Locating \"Continue\" button.')\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        logging.info('Waiting for password field.')\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        logging.info('Locating \"Sign In\" button.')\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        logging.info('Waiting for dashboard to load.')\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def sanitize_filename(filename):\r\n+    # Remove invalid characters from filename\r\n+    return \"\".join([c if c.isalnum() or c in (' ', '_') else '_' for c in filename]).rstrip()\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter by interacting with the UI elements.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters panel to load\r\n+        logging.info('Waiting for filters panel.')\r\n+        wait.until(EC.presence_of_element_located((By.ID, 'filter-toggle')))\r\n+        logging.info('Filters panel is present.')\r\n+\r\n+        # Open filters panel if not already open\r\n+        filter_toggle = driver.find_element(By.ID, 'filter-toggle')\r\n+        if 'expanded' not in filter_toggle.get_attribute('class'):\r\n+            logging.info('Opening filters panel.')\r\n+            filter_toggle.click()\r\n+            time.sleep(1)\r\n+\r\n+        # Wait for \"Easy Apply\" filter checkbox\r\n+        logging.info('Waiting for \"Easy Apply\" filter checkbox.')\r\n+        easy_apply_checkbox = wait.until(EC.element_to_be_clickable((By.XPATH, '//input[@id=\"easyApply\"]')))\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_checkbox)\r\n+        time.sleep(1)\r\n+\r\n+        if not easy_apply_checkbox.is_selected():\r\n+            easy_apply_checkbox.click()\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            time.sleep(3)\r\n+        else:\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+    except Exception as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_easy_apply(job_card):\r\n+    \"\"\"\r\n+    Checks if the job card indicates that it is an \"Easy Apply\" job.\r\n+    \"\"\"\r\n+    try:\r\n+        # Update the XPath based on the actual \"Easy Apply\" indicator on the job card\r\n+        # For example, look for a specific class or icon that represents \"Easy Apply\"\r\n+        easy_apply_indicator = job_card.find_element(By.XPATH, './/span[contains(@class, \"icon-easy-apply\")]')\r\n+        logging.debug('Found \"Easy Apply\" indicator on job card.')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        logging.debug('No \"Easy Apply\" indicator found on job card.')\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_filename(job_title)\r\n+        screenshot_path = f'screenshot_job_{sanitized_title}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            logging.info(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Log the current URL\r\n+        current_url = driver.current_url\r\n+        logging.info(f'Current URL after switching to job details: {current_url}')\r\n+        print(f'Current URL after switching to job details: {current_url}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        logging.info(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button\r\n+        try:\r\n+            logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n+            # Update the selector based on the actual button\r\n+            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n+            if easy_apply_button.is_displayed():\r\n+                # Scroll the button into view\r\n+                driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_button)\r\n+                time.sleep(0.5)\r\n+                try:\r\n+                    easy_apply_button.click()\r\n+                    logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                    print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                    logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n+            else:\r\n+                logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n+                print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n+                # Capture screenshot\r\n+                capture_screenshot(f'easy_apply_not_visible_{sanitize_filename(job_title)}')\r\n+                return  # Exit if the button is not visible\r\n+        except NoSuchElementException:\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            # Log current URL\r\n+            current_url = driver.current_url\r\n+            logging.info(f'Current URL when \"Easy Apply\" not found: {current_url}')\r\n+            print(f'Current URL when \"Easy Apply\" not found: {current_url}')\r\n+            # Capture screenshot\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_filename(job_title)}')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Continue with the application process\r\n+        # (Assuming there are steps to upload a resume and submit the application)\r\n+        # ...\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_filename(job_title)}')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        logging.info('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        logging.info('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')))\r\n+        logging.info('Job listings loaded.')\r\n+        print('Job listings loaded.')\r\n+\r\n+        # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                logging.info(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                # Check if the job card has an \"Easy Apply\" indicator\r\n+                if has_easy_apply(job_card):\r\n+                    logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                    print(f'Applying to job: {job_title}')\r\n+                    apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                    # Pause for specified duration before the next application\r\n+                    print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                    time.sleep(PAUSE_DURATION)\r\n+                else:\r\n+                    logging.info(f'Job {index}: Job \"{job_title}\" does not have \"Easy Apply\". Skipping.')\r\n+                    print(f'Job \"{job_title}\" does not have \"Easy Apply\". Skipping.')\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726902807222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,510 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info('Navigating to Dice login page.')\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        logging.info('Waiting for email field.')\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        logging.info('Locating \"Continue\" button.')\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        logging.info('Waiting for password field.')\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        logging.info('Locating \"Sign In\" button.')\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        logging.info('Waiting for dashboard to load.')\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def capture_screenshot(name):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        logging.info('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(job_card):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        return True\r\n+    except NoSuchElementException:\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n+        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            logging.info(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        logging.info(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button\r\n+        try:\r\n+            logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n+            # Update the selector based on the actual button\r\n+            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n+            if easy_apply_button.is_displayed():\r\n+                # Scroll the button into view\r\n+                driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_button)\r\n+                time.sleep(0.5)\r\n+                try:\r\n+                    easy_apply_button.click()\r\n+                    logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                    print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                    logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n+            else:\r\n+                logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n+                print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n+                return  # Exit if the button is not visible\r\n+        except NoSuchElementException:\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Wait for the apply modal to appear\r\n+        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n+        modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+        logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+        print(f'Apply modal appeared for job: {job_title}')\r\n+\r\n+        # Wait for the resume upload field to be present within the modal\r\n+        logging.info(f'Locating resume upload field for job: {job_title}')\r\n+        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+        upload_field.send_keys(RESUME_PATH)\r\n+        logging.info(f'Uploaded resume for job: {job_title}')\r\n+        print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n+        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+        submit_button.click()\r\n+        logging.info(f'Successfully applied to {job_title}')\r\n+        print(f\"Successfully applied to {job_title}\")\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{job_title}')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        logging.info('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        logging.info('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                logging.info(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726903969280,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,963 +63,45 @@\n # Maximize browser window\r\n driver.maximize_window()\r\n \r\n # -----------------------------\r\n-# Function Definitions\r\n+# Utility Functions\r\n # -----------------------------\r\n \r\n-def login_to_dice():\r\n+def sanitize_title(title):\r\n     \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n+    Sanitizes the job title to create a safe filename.\r\n     \"\"\"\r\n-    try:\r\n-        logging.info('Navigating to Dice login page.')\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n \r\n-        # Wait for the email field to be present\r\n-        logging.info('Waiting for email field.')\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        logging.info('Locating \"Continue\" button.')\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        logging.info('Waiting for password field.')\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        logging.info('Locating \"Sign In\" button.')\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        logging.info('Waiting for dashboard to load.')\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def capture_screenshot(name):\r\n+def create_directory(path):\r\n     \"\"\"\r\n-    Captures a screenshot with the given name.\r\n+    Creates a directory if it doesn't exist.\r\n     \"\"\"\r\n     try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n+        os.makedirs(path, exist_ok=True)\r\n     except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        logging.error(f'Failed to create directory {path}: {e}')\r\n+        print(f'Failed to create directory {path}: {e}')\r\n \r\n-def activate_easy_apply_filter():\r\n+def capture_screenshot(name, subfolder='general'):\r\n     \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n     \"\"\"\r\n     try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        logging.info('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(job_card):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            logging.info(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button\r\n-        try:\r\n-            logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n-            # Update the selector based on the actual button\r\n-            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n-            if easy_apply_button.is_displayed():\r\n-                # Scroll the button into view\r\n-                driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_button)\r\n-                time.sleep(0.5)\r\n-                try:\r\n-                    easy_apply_button.click()\r\n-                    logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                    print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                    logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n-            else:\r\n-                logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n-                print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n-                return  # Exit if the button is not visible\r\n-        except NoSuchElementException:\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Wait for the apply modal to appear\r\n-        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-        logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-        print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-        # Wait for the resume upload field to be present within the modal\r\n-        logging.info(f'Locating resume upload field for job: {job_title}')\r\n-        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-        upload_field.send_keys(RESUME_PATH)\r\n-        logging.info(f'Uploaded resume for job: {job_title}')\r\n-        print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-        submit_button.click()\r\n-        logging.info(f'Successfully applied to {job_title}')\r\n-        print(f\"Successfully applied to {job_title}\")\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{job_title}')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        logging.info('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        logging.info('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                logging.info(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s',\r\n-    handlers=[\r\n-        logging.FileHandler('application_log.txt'),\r\n-        logging.StreamHandler()  # This will output logs to the console\r\n-    ]\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info('Navigating to Dice login page.')\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        logging.info('Waiting for email field.')\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        logging.info('Locating \"Continue\" button.')\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        logging.info('Waiting for password field.')\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        logging.info('Locating \"Sign In\" button.')\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        logging.info('Waiting for dashboard to load.')\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n         timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n         driver.save_screenshot(screenshot_path)\r\n         logging.debug(f'Screenshot saved to {screenshot_path}')\r\n         print(f'Screenshot saved to {screenshot_path}')\r\n     except Exception as e:\r\n         logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n         print(f'Failed to capture screenshot \"{name}\": {e}')\r\n \r\n-def sanitize_filename(filename):\r\n-    # Remove invalid characters from filename\r\n-    return \"\".join([c if c.isalnum() or c in (' ', '_') else '_' for c in filename]).rstrip()\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter by interacting with the UI elements.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters panel to load\r\n-        logging.info('Waiting for filters panel.')\r\n-        wait.until(EC.presence_of_element_located((By.ID, 'filter-toggle')))\r\n-        logging.info('Filters panel is present.')\r\n-\r\n-        # Open filters panel if not already open\r\n-        filter_toggle = driver.find_element(By.ID, 'filter-toggle')\r\n-        if 'expanded' not in filter_toggle.get_attribute('class'):\r\n-            logging.info('Opening filters panel.')\r\n-            filter_toggle.click()\r\n-            time.sleep(1)\r\n-\r\n-        # Wait for \"Easy Apply\" filter checkbox\r\n-        logging.info('Waiting for \"Easy Apply\" filter checkbox.')\r\n-        easy_apply_checkbox = wait.until(EC.element_to_be_clickable((By.XPATH, '//input[@id=\"easyApply\"]')))\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_checkbox)\r\n-        time.sleep(1)\r\n-\r\n-        if not easy_apply_checkbox.is_selected():\r\n-            easy_apply_checkbox.click()\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            time.sleep(3)\r\n-        else:\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-    except Exception as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_easy_apply(job_card):\r\n-    \"\"\"\r\n-    Checks if the job card indicates that it is an \"Easy Apply\" job.\r\n-    \"\"\"\r\n-    try:\r\n-        # Update the XPath based on the actual \"Easy Apply\" indicator on the job card\r\n-        # For example, look for a specific class or icon that represents \"Easy Apply\"\r\n-        easy_apply_indicator = job_card.find_element(By.XPATH, './/span[contains(@class, \"icon-easy-apply\")]')\r\n-        logging.debug('Found \"Easy Apply\" indicator on job card.')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        logging.debug('No \"Easy Apply\" indicator found on job card.')\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_filename(job_title)\r\n-        screenshot_path = f'screenshot_job_{sanitized_title}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            logging.info(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Log the current URL\r\n-        current_url = driver.current_url\r\n-        logging.info(f'Current URL after switching to job details: {current_url}')\r\n-        print(f'Current URL after switching to job details: {current_url}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button\r\n-        try:\r\n-            logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n-            # Update the selector based on the actual button\r\n-            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n-            if easy_apply_button.is_displayed():\r\n-                # Scroll the button into view\r\n-                driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_button)\r\n-                time.sleep(0.5)\r\n-                try:\r\n-                    easy_apply_button.click()\r\n-                    logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                    print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                    logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n-            else:\r\n-                logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n-                print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n-                # Capture screenshot\r\n-                capture_screenshot(f'easy_apply_not_visible_{sanitize_filename(job_title)}')\r\n-                return  # Exit if the button is not visible\r\n-        except NoSuchElementException:\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            # Log current URL\r\n-            current_url = driver.current_url\r\n-            logging.info(f'Current URL when \"Easy Apply\" not found: {current_url}')\r\n-            print(f'Current URL when \"Easy Apply\" not found: {current_url}')\r\n-            # Capture screenshot\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_filename(job_title)}')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Continue with the application process\r\n-        # (Assuming there are steps to upload a resume and submit the application)\r\n-        # ...\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_filename(job_title)}')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        logging.info('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        logging.info('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        wait.until(EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')))\r\n-        logging.info('Job listings loaded.')\r\n-        print('Job listings loaded.')\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                logging.info(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                # Check if the job card has an \"Easy Apply\" indicator\r\n-                if has_easy_apply(job_card):\r\n-                    logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                    print(f'Applying to job: {job_title}')\r\n-                    apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                    # Pause for specified duration before the next application\r\n-                    print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                    time.sleep(PAUSE_DURATION)\r\n-                else:\r\n-                    logging.info(f'Job {index}: Job \"{job_title}\" does not have \"Easy Apply\". Skipping.')\r\n-                    print(f'Job \"{job_title}\" does not have \"Easy Apply\". Skipping.')\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n # -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n # Function Definitions\r\n # -----------------------------\r\n \r\n def login_to_dice():\r\n@@ -1069,33 +151,19 @@\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error during login: {e}')\r\n         print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n+        capture_screenshot('login_error', subfolder='login')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n     except WebDriverException as e:\r\n         logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n         print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error')\r\n+        capture_screenshot('login_redirection_error', subfolder='login')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     Ensures that the filter button is clickable and not obscured by overlays.\r\n@@ -1124,9 +192,9 @@\n             print('\"Easy Apply\" accordion located.')\r\n         except TimeoutException:\r\n             logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n             print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n             driver.quit()\r\n             exit(1)\r\n \r\n         # Scroll the \"Easy Apply\" accordion into view\r\n@@ -1143,9 +211,9 @@\n             print('\"Easy Apply\" filter button located.')\r\n         except NoSuchElementException:\r\n             logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n             print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n             driver.quit()\r\n             exit(1)\r\n \r\n         # Wait until the \"Easy Apply\" filter button is clickable\r\n@@ -1156,9 +224,9 @@\n             )\r\n         except TimeoutException:\r\n             logging.error('\"Easy Apply\" filter button is not clickable.')\r\n             print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n             driver.quit()\r\n             exit(1)\r\n \r\n         # Check if the \"Easy Apply\" filter is already active\r\n@@ -1203,15 +271,15 @@\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n         print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n         driver.quit()\r\n         exit(1)\r\n     except Exception as e:\r\n         logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n         print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n def has_apply_now(job_card):\r\n@@ -1235,10 +303,10 @@\n         logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n         print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n \r\n         # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n         driver.save_screenshot(screenshot_path)\r\n         logging.debug(f'Screenshot saved to {screenshot_path}')\r\n         print(f'Screenshot saved to {screenshot_path}')\r\n     except Exception as e:\r\n@@ -1300,10 +368,10 @@\n \r\n         # Attempt to locate the 'Easy Apply' button\r\n         try:\r\n             logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n-            # Update the selector based on the actual button\r\n-            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n+            # Use a more flexible selector to account for variations\r\n+            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\") or contains(@aria-label, \"Easy Apply\")]')\r\n             if easy_apply_button.is_displayed():\r\n                 # Scroll the button into view\r\n                 driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_button)\r\n                 time.sleep(0.5)\r\n@@ -1316,544 +384,57 @@\n                     driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n             else:\r\n                 logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n                 print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n+                capture_screenshot(f'easy_apply_not_visible_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n                 return  # Exit if the button is not visible\r\n         except NoSuchElementException:\r\n             logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            # Log available buttons and capture screenshot\r\n+            log_available_buttons(job_card, job_title)\r\n+            # Additionally, capture a specific screenshot for missing \"Easy Apply\" button\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return  # Exit if the button is not found\r\n \r\n         # Wait for the apply modal to appear\r\n         logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-        logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-        print(f'Apply modal appeared for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n \r\n         # Wait for the resume upload field to be present within the modal\r\n         logging.info(f'Locating resume upload field for job: {job_title}')\r\n-        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-        upload_field.send_keys(RESUME_PATH)\r\n-        logging.info(f'Uploaded resume for job: {job_title}')\r\n-        print(f'Uploaded resume for job: {job_title}')\r\n+        try:\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Resume upload field not found for job: {job_title}')\r\n+            print(f'Resume upload field not found for job: {job_title}')\r\n+            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n \r\n         # Wait for the 'Submit' button to be clickable and click it\r\n         logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-        submit_button.click()\r\n-        logging.info(f'Successfully applied to {job_title}')\r\n-        print(f\"Successfully applied to {job_title}\")\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{job_title}')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        logging.info('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        logging.info('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                logging.info(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info('Navigating to Dice login page.')\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        logging.info('Waiting for email field.')\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        logging.info('Locating \"Continue\" button.')\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        logging.info('Waiting for password field.')\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        logging.info('Locating \"Sign In\" button.')\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        logging.info('Waiting for dashboard to load.')\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def capture_screenshot(name):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshot_path = f'screenshot_{name}_{timestamp}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        logging.info('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n         try:\r\n-            logging.info('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n         except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion')\r\n-            driver.quit()\r\n-            exit(1)\r\n+            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n \r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(job_card):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n-        return True\r\n-    except NoSuchElementException:\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = \"\".join([c for c in job_title if c.isalnum() or c in (' ', '_')]).rstrip()\r\n-        screenshot_path = f'screenshot_job_{sanitized_title.replace(\" \", \"_\")}.png'\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            logging.info(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button\r\n-        try:\r\n-            logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n-            # Update the selector based on the actual button\r\n-            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n-            if easy_apply_button.is_displayed():\r\n-                # Scroll the button into view\r\n-                driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_button)\r\n-                time.sleep(0.5)\r\n-                try:\r\n-                    easy_apply_button.click()\r\n-                    logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                    print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                    logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n-            else:\r\n-                logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n-                print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n-                return  # Exit if the button is not visible\r\n-        except NoSuchElementException:\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Wait for the apply modal to appear\r\n-        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-        logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-        print(f'Apply modal appeared for job: {job_title}')\r\n-\r\n-        # Wait for the resume upload field to be present within the modal\r\n-        logging.info(f'Locating resume upload field for job: {job_title}')\r\n-        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-        upload_field.send_keys(RESUME_PATH)\r\n-        logging.info(f'Uploaded resume for job: {job_title}')\r\n-        print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-        submit_button.click()\r\n-        logging.info(f'Successfully applied to {job_title}')\r\n-        print(f\"Successfully applied to {job_title}\")\r\n-\r\n         # Add the job to the set of applied jobs\r\n         applied_jobs.add(job_title)\r\n \r\n         # Close the new window or navigate back\r\n@@ -1873,13 +454,14 @@\n         print(f'Error applying to \"{job_title}\": {e}')\r\n \r\n         # Log available buttons and capture a screenshot\r\n         log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n \r\n     except Exception as e:\r\n         logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n         print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{job_title}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n \r\n     finally:\r\n         # Ensure that any new window is closed and focus is back to the original window\r\n         if len(driver.window_handles) > 1:\r\n@@ -1939,8 +521,9 @@\n                 # Debugging: Print the outer HTML of the job card\r\n                 job_card_html = job_card.get_attribute('outerHTML')\r\n                 logging.debug(f'Job {index} HTML: {job_card_html}')\r\n                 print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n                 continue\r\n \r\n             # Debugging: Log job titles\r\n             logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n@@ -1963,8 +546,9 @@\n         logging.info(\"Job application process completed.\")\r\n     except Exception as e:\r\n         logging.error(f'An error occurred in main(): {e}')\r\n         print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n     finally:\r\n         driver.quit()\r\n \r\n # -----------------------------\r\n"
                },
                {
                    "date": 1726904419658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,9 @@\n from selenium.webdriver.chrome.options import Options\r\n from selenium.common.exceptions import (\r\n     NoSuchElementException,\r\n     WebDriverException,\r\n+    JavascriptException,\r\n     TimeoutException,\r\n     ElementClickInterceptedException,\r\n     ElementNotInteractableException\r\n )\r\n@@ -283,15 +284,20 @@\n         exit(1)\r\n \r\n def has_apply_now(job_card):\r\n     \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button.\r\n+    Checks if a job card contains an \"Apply now\" button inside a Shadow DOM.\r\n     Returns True if present, False otherwise.\r\n     \"\"\"\r\n     try:\r\n-        apply_now_button = job_card.find_element(By.XPATH, './/button[contains(text(), \"Apply now\")]')\r\n+        # Access the shadow root\r\n+        shadow_host = job_card.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        shadow_root = shadow_host.shadow_root\r\n+        \r\n+        # Now you can search within the shadow root\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n         return True\r\n-    except NoSuchElementException:\r\n+    except (NoSuchElementException, JavascriptException):\r\n         return False\r\n \r\n def log_available_buttons(job_card, job_title):\r\n     \"\"\"\r\n"
                },
                {
                    "date": 1726904737788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,8 @@\n from selenium.webdriver.chrome.options import Options\r\n from selenium.common.exceptions import (\r\n     NoSuchElementException,\r\n     WebDriverException,\r\n-    JavascriptException,\r\n     TimeoutException,\r\n     ElementClickInterceptedException,\r\n     ElementNotInteractableException\r\n )\r\n@@ -282,10 +281,25 @@\n         capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n-def has_apply_now(job_card):\r\n+def has_apply_now(driver, job_card):\r\n     \"\"\"\r\n+    Checks if a job card contains an \"Apply now\" button within Shadow DOM.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        # Accessing Shadow DOM (if relevant)\r\n+        shadow_host = job_card.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        shadow_root = shadow_host.shadow_root\r\n+        \r\n+        # Searching within the Shadow DOM\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        return True\r\n+    except (TimeoutException, NoSuchElementException):\r\n+        return False\r\n+\r\n+    \"\"\"\r\n     Checks if a job card contains an \"Apply now\" button inside a Shadow DOM.\r\n     Returns True if present, False otherwise.\r\n     \"\"\"\r\n     try:\r\n"
                },
                {
                    "date": 1726905150905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,10 @@\n import os\r\n from selenium import webdriver\r\n from selenium.webdriver.common.by import By\r\n from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.webdriver.common.keys import Keys\r\n from selenium.common.exceptions import (\r\n     NoSuchElementException,\r\n     WebDriverException,\r\n     TimeoutException,\r\n@@ -281,24 +283,52 @@\n         capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n-def has_apply_now(driver, job_card):\r\n+def has_apply_now(driver):\r\n     \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button within Shadow DOM.\r\n+    Checks if a job card contains an \"Easy Apply\" button within the Shadow DOM.\r\n     Returns True if present, False otherwise.\r\n     \"\"\"\r\n     try:\r\n-        # Accessing Shadow DOM (if relevant)\r\n-        shadow_host = job_card.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        shadow_root = shadow_host.shadow_root\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n         \r\n-        # Searching within the Shadow DOM\r\n+        # Access the shadow root\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        \r\n+        # Find the button within the shadow root\r\n         apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        \r\n+        # Interact with the button (click, if desired)\r\n+        apply_now_button.click()\r\n+        \r\n         return True\r\n-    except (TimeoutException, NoSuchElementException):\r\n+    except NoSuchElementException:\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n         return False\r\n \r\n+    # Usage Example:\r\n+    # Assuming `driver` is your WebDriver instance\r\n+    if has_apply_now(driver):\r\n+        print(\"Apply Now button found and clicked.\")\r\n+    else:\r\n+        print(\"Apply Now button not found.\")\r\n+        \"\"\"\r\n+        Checks if a job card contains an \"Apply now\" button within Shadow DOM.\r\n+        Returns True if present, False otherwise.\r\n+        \"\"\"\r\n+        try:\r\n+            # Accessing Shadow DOM (if relevant)\r\n+            shadow_host = job_card.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+            shadow_root = shadow_host.shadow_root\r\n+            \r\n+            # Searching within the Shadow DOM\r\n+            apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+            return True\r\n+        except (TimeoutException, NoSuchElementException):\r\n+            return False\r\n+\r\n     \"\"\"\r\n     Checks if a job card contains an \"Apply now\" button inside a Shadow DOM.\r\n     Returns True if present, False otherwise.\r\n     \"\"\"\r\n"
                },
                {
                    "date": 1726905197860,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -306,29 +306,28 @@\n     except NoSuchElementException:\r\n         driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n         return False\r\n \r\n-    # Usage Example:\r\n-    # Assuming `driver` is your WebDriver instance\r\n-    if has_apply_now(driver):\r\n-        print(\"Apply Now button found and clicked.\")\r\n-    else:\r\n-        print(\"Apply Now button not found.\")\r\n-        \"\"\"\r\n-        Checks if a job card contains an \"Apply now\" button within Shadow DOM.\r\n-        Returns True if present, False otherwise.\r\n-        \"\"\"\r\n-        try:\r\n-            # Accessing Shadow DOM (if relevant)\r\n-            shadow_host = job_card.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-            shadow_root = shadow_host.shadow_root\r\n-            \r\n-            # Searching within the Shadow DOM\r\n-            apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-            return True\r\n-        except (TimeoutException, NoSuchElementException):\r\n-            return False\r\n \r\n+        if has_apply_now(driver):\r\n+            print(\"Apply Now button found and clicked.\")\r\n+        else:\r\n+            print(\"Apply Now button not found.\")\r\n+            \"\"\"\r\n+            Checks if a job card contains an \"Apply now\" button within Shadow DOM.\r\n+            Returns True if present, False otherwise.\r\n+            \"\"\"\r\n+            try:\r\n+                # Accessing Shadow DOM (if relevant)\r\n+                shadow_host = job_card.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+                shadow_root = shadow_host.shadow_root\r\n+                \r\n+                # Searching within the Shadow DOM\r\n+                apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+                return True\r\n+            except (TimeoutException, NoSuchElementException):\r\n+                return False\r\n+\r\n     \"\"\"\r\n     Checks if a job card contains an \"Apply now\" button inside a Shadow DOM.\r\n     Returns True if present, False otherwise.\r\n     \"\"\"\r\n"
                },
                {
                    "date": 1726905283958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,8 +295,31 @@\n         \r\n         # Access the shadow root\r\n         shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n         \r\n+        # Find the \"Easy Apply\" button within the shadow root\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        \r\n+        # Optionally, you could click the button\r\n+        # apply_now_button.click()\r\n+        \r\n+        return True\r\n+    except NoSuchElementException:\r\n+        # Log or take a screenshot for debugging\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        return False\r\n+\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Easy Apply\" button within the Shadow DOM.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        \r\n+        # Access the shadow root\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        \r\n         # Find the button within the shadow root\r\n         apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n         \r\n         # Interact with the button (click, if desired)\r\n"
                },
                {
                    "date": 1726905520058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,577 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.webdriver.common.keys import Keys\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to create directory {path}: {e}')\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info('Navigating to Dice login page.')\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        logging.info('Waiting for email field.')\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        logging.info('Locating \"Continue\" button.')\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        logging.info('Waiting for password field.')\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        logging.info('Locating \"Sign In\" button.')\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        logging.info('Waiting for dashboard to load.')\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        logging.info('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(driver):\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Easy Apply\" button within the Shadow DOM.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        \r\n+        # Access the shadow root\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        \r\n+        # Find the \"Easy Apply\" button within the shadow root\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        \r\n+        # Optionally, you could click the button\r\n+        # apply_now_button.click()\r\n+        \r\n+        return True\r\n+    except NoSuchElementException:\r\n+        # Log or take a screenshot for debugging\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        return False\r\n+\r\n+# You can add more functions or code below without issues from triple quotes\r\n+\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            logging.info(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        logging.info(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Attempt to locate the 'Easy Apply' button\r\n+        try:\r\n+            logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n+            # Use a more flexible selector to account for variations\r\n+            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\") or contains(@aria-label, \"Easy Apply\")]')\r\n+            if easy_apply_button.is_displayed():\r\n+                # Scroll the button into view\r\n+                driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_button)\r\n+                time.sleep(0.5)\r\n+                try:\r\n+                    easy_apply_button.click()\r\n+                    logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                    print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n+                except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                    logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n+                    driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n+            else:\r\n+                logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n+                print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n+                capture_screenshot(f'easy_apply_not_visible_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+                return  # Exit if the button is not visible\r\n+        except NoSuchElementException:\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            # Log available buttons and capture screenshot\r\n+            log_available_buttons(job_card, job_title)\r\n+            # Additionally, capture a specific screenshot for missing \"Easy Apply\" button\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Wait for the apply modal to appear\r\n+        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the resume upload field to be present within the modal\r\n+        logging.info(f'Locating resume upload field for job: {job_title}')\r\n+        try:\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Resume upload field not found for job: {job_title}')\r\n+            print(f'Resume upload field not found for job: {job_title}')\r\n+            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n+        try:\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+        except TimeoutException:\r\n+            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        logging.info('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        logging.info('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                logging.info(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726905782585,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -289,660 +289,40 @@\n     Checks if a job card contains an \"Easy Apply\" button within the Shadow DOM.\r\n     Returns True if present, False otherwise.\r\n     \"\"\"\r\n     try:\r\n+        logging.info(\"Attempting to locate the shadow host element.\")\r\n         # Locate the shadow host element\r\n         shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        \r\n+        logging.info(\"Shadow host element found.\")\r\n+\r\n+        logging.info(\"Accessing the shadow root.\")\r\n         # Access the shadow root\r\n         shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        \r\n+        logging.info(\"Shadow root accessed.\")\r\n+\r\n+        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n         # Find the \"Easy Apply\" button within the shadow root\r\n         apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        \r\n+        logging.info(\"Found the 'Easy Apply' button.\")\r\n+\r\n         # Optionally, you could click the button\r\n         # apply_now_button.click()\r\n         \r\n         return True\r\n-    except NoSuchElementException:\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"NoSuchElementException: {str(e)}\")\r\n         # Log or take a screenshot for debugging\r\n         driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n         return False\r\n-\r\n-# You can add more functions or code below without issues from triple quotes\r\n-\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n     except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            logging.info(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Attempt to locate the 'Easy Apply' button\r\n-        try:\r\n-            logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n-            # Use a more flexible selector to account for variations\r\n-            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\") or contains(@aria-label, \"Easy Apply\")]')\r\n-            if easy_apply_button.is_displayed():\r\n-                # Scroll the button into view\r\n-                driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_button)\r\n-                time.sleep(0.5)\r\n-                try:\r\n-                    easy_apply_button.click()\r\n-                    logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                    print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                    logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n-            else:\r\n-                logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n-                print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n-                capture_screenshot(f'easy_apply_not_visible_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-                return  # Exit if the button is not visible\r\n-        except NoSuchElementException:\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            # Log available buttons and capture screenshot\r\n-            log_available_buttons(job_card, job_title)\r\n-            # Additionally, capture a specific screenshot for missing \"Easy Apply\" button\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Wait for the apply modal to appear\r\n-        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the resume upload field to be present within the modal\r\n-        logging.info(f'Locating resume upload field for job: {job_title}')\r\n-        try:\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Resume upload field not found for job: {job_title}')\r\n-            print(f'Resume upload field not found for job: {job_title}')\r\n-            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-        try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-        except TimeoutException:\r\n-            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        logging.info('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        logging.info('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                logging.info(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.webdriver.common.keys import Keys\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to create directory {path}: {e}')\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info('Navigating to Dice login page.')\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        logging.info('Waiting for email field.')\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        logging.info('Locating \"Continue\" button.')\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        logging.info('Waiting for password field.')\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        logging.info('Locating \"Sign In\" button.')\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        logging.info('Waiting for dashboard to load.')\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        logging.info('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(driver):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Easy Apply\" button within the Shadow DOM.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        \r\n-        # Access the shadow root\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        \r\n-        # Find the \"Easy Apply\" button within the shadow root\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        \r\n-        # Optionally, you could click the button\r\n-        # apply_now_button.click()\r\n-        \r\n-        return True\r\n-    except NoSuchElementException:\r\n-        # Log or take a screenshot for debugging\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n         return False\r\n \r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Easy Apply\" button within the Shadow DOM.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        \r\n-        # Access the shadow root\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        \r\n-        # Find the button within the shadow root\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        \r\n-        # Interact with the button (click, if desired)\r\n-        apply_now_button.click()\r\n-        \r\n-        return True\r\n-    except NoSuchElementException:\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        return False\r\n+# You can add more functions or code below without issues from triple quotes\r\n \r\n \r\n-        if has_apply_now(driver):\r\n-            print(\"Apply Now button found and clicked.\")\r\n-        else:\r\n-            print(\"Apply Now button not found.\")\r\n-            \"\"\"\r\n-            Checks if a job card contains an \"Apply now\" button within Shadow DOM.\r\n-            Returns True if present, False otherwise.\r\n-            \"\"\"\r\n-            try:\r\n-                # Accessing Shadow DOM (if relevant)\r\n-                shadow_host = job_card.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-                shadow_root = shadow_host.shadow_root\r\n-                \r\n-                # Searching within the Shadow DOM\r\n-                apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-                return True\r\n-            except (TimeoutException, NoSuchElementException):\r\n-                return False\r\n-\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Apply now\" button inside a Shadow DOM.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        # Access the shadow root\r\n-        shadow_host = job_card.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        shadow_root = shadow_host.shadow_root\r\n-        \r\n-        # Now you can search within the shadow root\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        return True\r\n-    except (NoSuchElementException, JavascriptException):\r\n-        return False\r\n-\r\n def log_available_buttons(job_card, job_title):\r\n     \"\"\"\r\n     Logs all available buttons within a job card for debugging purposes.\r\n     \"\"\"\r\n"
                },
                {
                    "date": 1726906006904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -292,8 +292,41 @@\n     try:\r\n         logging.info(\"Attempting to locate the shadow host element.\")\r\n         # Locate the shadow host element\r\n         shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n+\r\n+        logging.info(\"Accessing the shadow root.\")\r\n+        # Access the shadow root\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n+\r\n+        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n+        # Find the \"Easy Apply\" button within the shadow root\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n+\r\n+        # Optionally, you could click the button\r\n+        # apply_now_button.click()\r\n+\r\n+        return True\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n+        # Log or take a screenshot for debugging\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        return False\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        return False\r\n+    \"\"\"\r\n+    Checks if a job card contains an \"Easy Apply\" button within the Shadow DOM.\r\n+    Returns True if present, False otherwise.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Attempting to locate the shadow host element.\")\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n         logging.info(\"Shadow host element found.\")\r\n \r\n         logging.info(\"Accessing the shadow root.\")\r\n         # Access the shadow root\r\n"
                },
                {
                    "date": 1726906314885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -427,38 +427,16 @@\n         time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n         logging.debug(f'Job details loaded for: {job_title}')\r\n         print(f'Job details loaded for: {job_title}')\r\n \r\n-        # Attempt to locate the 'Easy Apply' button\r\n-        try:\r\n-            logging.info(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n-            # Use a more flexible selector to account for variations\r\n-            easy_apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\") or contains(@aria-label, \"Easy Apply\")]')\r\n-            if easy_apply_button.is_displayed():\r\n-                # Scroll the button into view\r\n-                driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_button)\r\n-                time.sleep(0.5)\r\n-                try:\r\n-                    easy_apply_button.click()\r\n-                    logging.info(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                    print(f'Clicked \"Easy Apply\" for job: {job_title}')\r\n-                except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                    logging.warning(f'Click intercepted on \"Easy Apply\" button for job: {job_title}. Trying JavaScript click.')\r\n-                    driver.execute_script(\"arguments[0].click();\", easy_apply_button)\r\n-            else:\r\n-                logging.info(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n-                print(f'\"Easy Apply\" button is not visible for job: {job_title}')\r\n-                capture_screenshot(f'easy_apply_not_visible_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-                return  # Exit if the button is not visible\r\n-        except NoSuchElementException:\r\n+        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n             logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            # Log available buttons and capture screenshot\r\n-            log_available_buttons(job_card, job_title)\r\n-            # Additionally, capture a specific screenshot for missing \"Easy Apply\" button\r\n             capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return  # Exit if the button is not found\r\n-\r\n+        \r\n+        # Continue with the application process...\r\n         # Wait for the apply modal to appear\r\n         logging.info(f'Waiting for apply modal for job: {job_title}')\r\n         try:\r\n             modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n@@ -531,8 +509,9 @@\n             driver.switch_to.window(original_window)\r\n             logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n             print(f'Closed new window and switched back to original window after processing {job_title}')\r\n \r\n+\r\n def main():\r\n     applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n     login_to_dice()\r\n"
                },
                {
                    "date": 1726906552896,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -284,74 +284,74 @@\n         driver.quit()\r\n         exit(1)\r\n \r\n def has_apply_now(driver):\r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Easy Apply\" button within the Shadow DOM.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n+    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n+    logging.info(\"Attempting to locate the shadow host element.\")\r\n     try:\r\n-        logging.info(\"Attempting to locate the shadow host element.\")\r\n         # Locate the shadow host element\r\n         shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n         logging.info(\"Shadow host element found: %s\", shadow_host)\r\n+        print(\"Shadow host element found\")  # Debugging print\r\n \r\n         logging.info(\"Accessing the shadow root.\")\r\n-        # Access the shadow root\r\n         shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n         logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n+        print(\"Shadow root accessed\")  # Debugging print\r\n \r\n         logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n-        # Find the \"Easy Apply\" button within the shadow root\r\n         apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n         logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n+        print(\"Easy Apply button found\")  # Debugging print\r\n \r\n-        # Optionally, you could click the button\r\n-        # apply_now_button.click()\r\n-\r\n         return True\r\n     except NoSuchElementException as e:\r\n         logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        # Log or take a screenshot for debugging\r\n         driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        print(\"NoSuchElementException caught\")  # Debugging print\r\n         return False\r\n     except Exception as e:\r\n         logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n         driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        print(\"Unexpected exception caught\")  # Debugging print\r\n         return False\r\n+\r\n     \"\"\"\r\n     Checks if a job card contains an \"Easy Apply\" button within the Shadow DOM.\r\n     Returns True if present, False otherwise.\r\n     \"\"\"\r\n     try:\r\n         logging.info(\"Attempting to locate the shadow host element.\")\r\n         # Locate the shadow host element\r\n         shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        logging.info(\"Shadow host element found.\")\r\n+        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n \r\n         logging.info(\"Accessing the shadow root.\")\r\n         # Access the shadow root\r\n         shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        logging.info(\"Shadow root accessed.\")\r\n+        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n \r\n         logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n         # Find the \"Easy Apply\" button within the shadow root\r\n         apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        logging.info(\"Found the 'Easy Apply' button.\")\r\n+        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n \r\n         # Optionally, you could click the button\r\n         # apply_now_button.click()\r\n-        \r\n+\r\n         return True\r\n     except NoSuchElementException as e:\r\n-        logging.error(f\"NoSuchElementException: {str(e)}\")\r\n+        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n         # Log or take a screenshot for debugging\r\n         driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n         return False\r\n     except Exception as e:\r\n         logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n         driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n         return False\r\n+        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        return False\r\n \r\n # You can add more functions or code below without issues from triple quotes\r\n \r\n \r\n"
                },
                {
                    "date": 1726906951080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,8 +302,23 @@\n         apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n         logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n         print(\"Easy Apply button found\")  # Debugging print\r\n \r\n+        # Scroll the button into view before clicking\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button using JavaScript\r\n+        try:\r\n+            apply_now_button.click()  # Attempt to click the button\r\n+            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n+            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n+        except Exception as e:\r\n+            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n+\r\n         return True\r\n     except NoSuchElementException as e:\r\n         logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n         driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n@@ -314,44 +329,11 @@\n         driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n         print(\"Unexpected exception caught\")  # Debugging print\r\n         return False\r\n \r\n-    \"\"\"\r\n-    Checks if a job card contains an \"Easy Apply\" button within the Shadow DOM.\r\n-    Returns True if present, False otherwise.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Attempting to locate the shadow host element.\")\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n-\r\n-        logging.info(\"Accessing the shadow root.\")\r\n-        # Access the shadow root\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n-\r\n-        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n-        # Find the \"Easy Apply\" button within the shadow root\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n-\r\n-        # Optionally, you could click the button\r\n-        # apply_now_button.click()\r\n-\r\n-        return True\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        # Log or take a screenshot for debugging\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        return False\r\n-    except Exception as e:\r\n         logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n         driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n         return False\r\n-        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        return False\r\n \r\n # You can add more functions or code below without issues from triple quotes\r\n \r\n \r\n"
                },
                {
                    "date": 1726907328706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,8 @@\n import os\r\n from selenium import webdriver\r\n from selenium.webdriver.common.by import By\r\n from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.webdriver.common.keys import Keys\r\n from selenium.common.exceptions import (\r\n     NoSuchElementException,\r\n     WebDriverException,\r\n     TimeoutException,\r\n@@ -15,9 +13,8 @@\n     ElementNotInteractableException\r\n )\r\n from selenium.webdriver.support.ui import WebDriverWait\r\n from selenium.webdriver.support import expected_conditions as EC\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n \r\n # -----------------------------\r\n # Configuration and Setup\r\n # -----------------------------\r\n@@ -164,8 +161,45 @@\n         capture_screenshot('login_redirection_error', subfolder='login')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n+def handle_login_modal():\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)\r\n+        logging.info(\"Checking if login modal is present.\")\r\n+\r\n+        # Wait for the email field to be present in the login modal\r\n+        email_field = wait.until(EC.presence_of_element_located((By.ID, 'username')))\r\n+        logging.info(\"Login modal detected. Entering credentials.\")\r\n+\r\n+        # Enter the email address\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+\r\n+        # Enter the password\r\n+        password_field = driver.find_element(By.ID, 'password')\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+\r\n+        # Click the \"Log in\" button\r\n+        login_button = driver.find_element(By.CSS_SELECTOR, 'login-dhi-button button')\r\n+        login_button.click()\r\n+        logging.info(\"Clicked 'Log in' button.\")\r\n+\r\n+        # Wait for the modal to disappear (indicating a successful login)\r\n+        wait.until(EC.invisibility_of_element_located((By.ID, 'username')))\r\n+        logging.info(\"Successfully logged in via modal.\")\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(\"Login modal did not appear as expected.\")\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"Error finding login modal elements: {e}\")\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+\r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     Ensures that the filter button is clickable and not obscured by overlays.\r\n@@ -329,15 +363,8 @@\n         driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n         print(\"Unexpected exception caught\")  # Debugging print\r\n         return False\r\n \r\n-        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        return False\r\n-\r\n-# You can add more functions or code below without issues from triple quotes\r\n-\r\n-\r\n def log_available_buttons(job_card, job_title):\r\n     \"\"\"\r\n     Logs all available buttons within a job card for debugging purposes.\r\n     \"\"\"\r\n@@ -415,8 +442,11 @@\n             logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return  # Exit if the button is not found\r\n+\r\n+        # Handle login modal if it appears\r\n+        handle_login_modal()\r\n         \r\n         # Continue with the application process...\r\n         # Wait for the apply modal to appear\r\n         logging.info(f'Waiting for apply modal for job: {job_title}')\r\n"
                },
                {
                    "date": 1726907428602,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,9 @@\n import os\r\n from selenium import webdriver\r\n from selenium.webdriver.common.by import By\r\n from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n from selenium.common.exceptions import (\r\n     NoSuchElementException,\r\n     WebDriverException,\r\n     TimeoutException,\r\n"
                },
                {
                    "date": 1726907838433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -170,28 +170,33 @@\n     try:\r\n         wait = WebDriverWait(driver, 20)\r\n         logging.info(\"Checking if login modal is present.\")\r\n \r\n-        # Wait for the email field to be present in the login modal\r\n-        email_field = wait.until(EC.presence_of_element_located((By.ID, 'username')))\r\n-        logging.info(\"Login modal detected. Entering credentials.\")\r\n+        # Wait for the dialog to be present\r\n+        login_dialog = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, 'dialog.sc-login-dhi-modal[open]')))\r\n+        logging.info(\"Login modal detected.\")\r\n \r\n-        # Enter the email address\r\n+        # Locate the email field within the dialog\r\n+        email_field = login_dialog.find_element(By.ID, 'username')\r\n+        logging.info(\"Email field located in modal.\")\r\n         email_field.clear()\r\n         email_field.send_keys(EMAIL)\r\n+        logging.info(\"Entered email in login modal.\")\r\n \r\n-        # Enter the password\r\n-        password_field = driver.find_element(By.ID, 'password')\r\n+        # Locate the password field within the dialog\r\n+        password_field = login_dialog.find_element(By.ID, 'password')\r\n+        logging.info(\"Password field located in modal.\")\r\n         password_field.clear()\r\n         password_field.send_keys(PASSWORD)\r\n+        logging.info(\"Entered password in login modal.\")\r\n \r\n-        # Click the \"Log in\" button\r\n-        login_button = driver.find_element(By.CSS_SELECTOR, 'login-dhi-button button')\r\n+        # Locate and click the \"Log in\" button within the dialog\r\n+        login_button = login_dialog.find_element(By.CSS_SELECTOR, 'login-dhi-button[data-cy=\"login-submit\"] button')\r\n         login_button.click()\r\n-        logging.info(\"Clicked 'Log in' button.\")\r\n+        logging.info(\"Clicked 'Log in' button in modal.\")\r\n \r\n         # Wait for the modal to disappear (indicating a successful login)\r\n-        wait.until(EC.invisibility_of_element_located((By.ID, 'username')))\r\n+        wait.until(EC.invisibility_of_element_located((By.CSS_SELECTOR, 'dialog.sc-login-dhi-modal[open]')))\r\n         logging.info(\"Successfully logged in via modal.\")\r\n \r\n     except TimeoutException:\r\n         logging.error(\"Login modal did not appear as expected.\")\r\n@@ -199,8 +204,9 @@\n         logging.error(f\"Error finding login modal elements: {e}\")\r\n     except Exception as e:\r\n         logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n \r\n+\r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     Ensures that the filter button is clickable and not obscured by overlays.\r\n@@ -444,11 +450,11 @@\n             print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return  # Exit if the button is not found\r\n \r\n-        # Handle login modal if it appears\r\n+        # Call handle_login_modal right after the apply button is clicked\r\n         handle_login_modal()\r\n-        \r\n+\r\n         # Continue with the application process...\r\n         # Wait for the apply modal to appear\r\n         logging.info(f'Waiting for apply modal for job: {job_title}')\r\n         try:\r\n"
                },
                {
                    "date": 1726907892078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,13 +169,13 @@\n     \"\"\"\r\n     try:\r\n         wait = WebDriverWait(driver, 20)\r\n         logging.info(\"Checking if login modal is present.\")\r\n-\r\n+        print(\"Checking if login modal is present.\")\r\n         # Wait for the dialog to be present\r\n         login_dialog = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, 'dialog.sc-login-dhi-modal[open]')))\r\n         logging.info(\"Login modal detected.\")\r\n-\r\n+        print(\"Login modal detected.\")\r\n         # Locate the email field within the dialog\r\n         email_field = login_dialog.find_element(By.ID, 'username')\r\n         logging.info(\"Email field located in modal.\")\r\n         email_field.clear()\r\n"
                },
                {
                    "date": 1726908227162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,42 +169,56 @@\n     \"\"\"\r\n     try:\r\n         wait = WebDriverWait(driver, 20)\r\n         logging.info(\"Checking if login modal is present.\")\r\n-        print(\"Checking if login modal is present.\")\r\n-        # Wait for the dialog to be present\r\n-        login_dialog = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, 'dialog.sc-login-dhi-modal[open]')))\r\n-        logging.info(\"Login modal detected.\")\r\n+\r\n+        # Wait for the email field to be present in the login modal\r\n+        email_field = wait.until(EC.presence_of_element_located((By.ID, 'username')))\r\n+        logging.info(\"Login modal detected. Entering credentials.\")\r\n         print(\"Login modal detected.\")\r\n-        # Locate the email field within the dialog\r\n-        email_field = login_dialog.find_element(By.ID, 'username')\r\n-        logging.info(\"Email field located in modal.\")\r\n+\r\n+        # Enter the email address\r\n+        logging.info(\"Email field HTML: \" + email_field.get_attribute('outerHTML'))\r\n+        print(\"Email field HTML:\", email_field.get_attribute('outerHTML'))\r\n         email_field.clear()\r\n         email_field.send_keys(EMAIL)\r\n-        logging.info(\"Entered email in login modal.\")\r\n+        logging.info(\"Entered email in modal.\")\r\n+        print(\"Entered email in modal.\")\r\n \r\n-        # Locate the password field within the dialog\r\n-        password_field = login_dialog.find_element(By.ID, 'password')\r\n-        logging.info(\"Password field located in modal.\")\r\n+        # Find the password field\r\n+        password_field = driver.find_element(By.ID, 'password')\r\n+        logging.info(\"Password field HTML: \" + password_field.get_attribute('outerHTML'))\r\n+        print(\"Password field HTML:\", password_field.get_attribute('outerHTML'))\r\n         password_field.clear()\r\n         password_field.send_keys(PASSWORD)\r\n-        logging.info(\"Entered password in login modal.\")\r\n+        logging.info(\"Entered password in modal.\")\r\n+        print(\"Entered password in modal.\")\r\n \r\n-        # Locate and click the \"Log in\" button within the dialog\r\n-        login_button = login_dialog.find_element(By.CSS_SELECTOR, 'login-dhi-button[data-cy=\"login-submit\"] button')\r\n+        # Click the \"Log in\" button\r\n+        login_button = driver.find_element(By.CSS_SELECTOR, 'login-dhi-button button')\r\n+        logging.info(\"Login button HTML: \" + login_button.get_attribute('outerHTML'))\r\n+        print(\"Login button HTML:\", login_button.get_attribute('outerHTML'))\r\n         login_button.click()\r\n         logging.info(\"Clicked 'Log in' button in modal.\")\r\n+        print(\"Clicked 'Log in' button in modal.\")\r\n \r\n         # Wait for the modal to disappear (indicating a successful login)\r\n-        wait.until(EC.invisibility_of_element_located((By.CSS_SELECTOR, 'dialog.sc-login-dhi-modal[open]')))\r\n+        wait.until(EC.invisibility_of_element_located((By.ID, 'username')))\r\n         logging.info(\"Successfully logged in via modal.\")\r\n+        print(\"Successfully logged in via modal.\")\r\n \r\n     except TimeoutException:\r\n         logging.error(\"Login modal did not appear as expected.\")\r\n+        capture_screenshot('login_modal_missing', subfolder='login')\r\n+        print(\"Login modal did not appear as expected.\")\r\n     except NoSuchElementException as e:\r\n         logging.error(f\"Error finding login modal elements: {e}\")\r\n+        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n+        print(f\"Error finding login modal elements: {e}\")\r\n     except Exception as e:\r\n         logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n \r\n \r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n"
                },
                {
                    "date": 1726908372637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -170,10 +170,10 @@\n     try:\r\n         wait = WebDriverWait(driver, 20)\r\n         logging.info(\"Checking if login modal is present.\")\r\n \r\n-        # Wait for the email field to be present in the login modal\r\n-        email_field = wait.until(EC.presence_of_element_located((By.ID, 'username')))\r\n+        # Wait for the email field to be present and visible in the login modal\r\n+        email_field = wait.until(EC.visibility_of_element_located((By.ID, 'username')))\r\n         logging.info(\"Login modal detected. Entering credentials.\")\r\n         print(\"Login modal detected.\")\r\n \r\n         # Enter the email address\r\n@@ -183,19 +183,19 @@\n         email_field.send_keys(EMAIL)\r\n         logging.info(\"Entered email in modal.\")\r\n         print(\"Entered email in modal.\")\r\n \r\n-        # Find the password field\r\n-        password_field = driver.find_element(By.ID, 'password')\r\n+        # Wait for the password field to be visible\r\n+        password_field = wait.until(EC.visibility_of_element_located((By.ID, 'password')))\r\n         logging.info(\"Password field HTML: \" + password_field.get_attribute('outerHTML'))\r\n         print(\"Password field HTML:\", password_field.get_attribute('outerHTML'))\r\n         password_field.clear()\r\n         password_field.send_keys(PASSWORD)\r\n         logging.info(\"Entered password in modal.\")\r\n         print(\"Entered password in modal.\")\r\n \r\n-        # Click the \"Log in\" button\r\n-        login_button = driver.find_element(By.CSS_SELECTOR, 'login-dhi-button button')\r\n+        # Wait for the \"Log in\" button to be clickable\r\n+        login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'login-dhi-button button')))\r\n         logging.info(\"Login button HTML: \" + login_button.get_attribute('outerHTML'))\r\n         print(\"Login button HTML:\", login_button.get_attribute('outerHTML'))\r\n         login_button.click()\r\n         logging.info(\"Clicked 'Log in' button in modal.\")\r\n"
                },
                {
                    "date": 1726908724972,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,56 +169,55 @@\n     \"\"\"\r\n     try:\r\n         wait = WebDriverWait(driver, 20)\r\n         logging.info(\"Checking if login modal is present.\")\r\n+        print(\"Checking if login modal is present.\")  # Debugging print\r\n \r\n+        # Wait for the modal dialog itself to appear\r\n+        modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n+        logging.info(\"Modal dialog detected.\")\r\n+        print(\"Modal dialog detected.\")  # Debugging print\r\n+\r\n         # Wait for the email field to be present and visible in the login modal\r\n         email_field = wait.until(EC.visibility_of_element_located((By.ID, 'username')))\r\n         logging.info(\"Login modal detected. Entering credentials.\")\r\n-        print(\"Login modal detected.\")\r\n+        print(\"Login modal detected.\")  # Debugging print\r\n \r\n         # Enter the email address\r\n-        logging.info(\"Email field HTML: \" + email_field.get_attribute('outerHTML'))\r\n-        print(\"Email field HTML:\", email_field.get_attribute('outerHTML'))\r\n         email_field.clear()\r\n         email_field.send_keys(EMAIL)\r\n         logging.info(\"Entered email in modal.\")\r\n-        print(\"Entered email in modal.\")\r\n+        print(\"Entered email in modal.\")  # Debugging print\r\n \r\n         # Wait for the password field to be visible\r\n         password_field = wait.until(EC.visibility_of_element_located((By.ID, 'password')))\r\n-        logging.info(\"Password field HTML: \" + password_field.get_attribute('outerHTML'))\r\n-        print(\"Password field HTML:\", password_field.get_attribute('outerHTML'))\r\n         password_field.clear()\r\n         password_field.send_keys(PASSWORD)\r\n         logging.info(\"Entered password in modal.\")\r\n-        print(\"Entered password in modal.\")\r\n+        print(\"Entered password in modal.\")  # Debugging print\r\n \r\n         # Wait for the \"Log in\" button to be clickable\r\n         login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'login-dhi-button button')))\r\n-        logging.info(\"Login button HTML: \" + login_button.get_attribute('outerHTML'))\r\n-        print(\"Login button HTML:\", login_button.get_attribute('outerHTML'))\r\n         login_button.click()\r\n         logging.info(\"Clicked 'Log in' button in modal.\")\r\n-        print(\"Clicked 'Log in' button in modal.\")\r\n+        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n \r\n         # Wait for the modal to disappear (indicating a successful login)\r\n         wait.until(EC.invisibility_of_element_located((By.ID, 'username')))\r\n         logging.info(\"Successfully logged in via modal.\")\r\n-        print(\"Successfully logged in via modal.\")\r\n+        print(\"Successfully logged in via modal.\")  # Debugging print\r\n \r\n     except TimeoutException:\r\n         logging.error(\"Login modal did not appear as expected.\")\r\n+        print(\"Login modal did not appear as expected.\")  # Debugging print\r\n         capture_screenshot('login_modal_missing', subfolder='login')\r\n-        print(\"Login modal did not appear as expected.\")\r\n     except NoSuchElementException as e:\r\n         logging.error(f\"Error finding login modal elements: {e}\")\r\n         capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n-        print(f\"Error finding login modal elements: {e}\")\r\n     except Exception as e:\r\n         logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n         capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n \r\n \r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n"
                },
                {
                    "date": 1726909311240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,630 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to create directory {path}: {e}')\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info('Navigating to Dice login page.')\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        logging.info('Waiting for email field.')\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        logging.info('Locating \"Continue\" button.')\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        logging.info('Waiting for password field.')\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        logging.info('Locating \"Sign In\" button.')\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        logging.info('Waiting for dashboard to load.')\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def handle_login_modal():\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)\r\n+        logging.info(\"Checking if login modal is present.\")\r\n+        print(\"Checking if login modal is present.\")  # Debugging print\r\n+\r\n+        # Wait for the modal dialog itself to appear\r\n+        modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n+        logging.info(\"Modal dialog detected.\")\r\n+        print(\"Modal dialog detected.\")  # Debugging print\r\n+\r\n+        # Wait for the email field to be present and visible in the login modal\r\n+        email_field = wait.until(EC.visibility_of_element_located((By.ID, 'username')))\r\n+        logging.info(\"Login modal detected. Entering credentials.\")\r\n+        print(\"Login modal detected.\")  # Debugging print\r\n+\r\n+        # Enter the email address\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info(\"Entered email in modal.\")\r\n+        print(\"Entered email in modal.\")  # Debugging print\r\n+\r\n+        # Wait for the password field to be visible\r\n+        password_field = wait.until(EC.visibility_of_element_located((By.ID, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info(\"Entered password in modal.\")\r\n+        print(\"Entered password in modal.\")  # Debugging print\r\n+\r\n+        # Wait for the \"Log in\" button to be clickable\r\n+        login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'login-dhi-button button')))\r\n+        login_button.click()\r\n+        logging.info(\"Clicked 'Log in' button in modal.\")\r\n+        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n+\r\n+        # Wait for the modal to disappear (indicating a successful login)\r\n+        wait.until(EC.invisibility_of_element_located((By.ID, 'username')))\r\n+        logging.info(\"Successfully logged in via modal.\")\r\n+        print(\"Successfully logged in via modal.\")  # Debugging print\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(\"Login modal did not appear as expected.\")\r\n+        print(\"Login modal did not appear as expected.\")  # Debugging print\r\n+        capture_screenshot('login_modal_missing', subfolder='login')\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"Error finding login modal elements: {e}\")\r\n+        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        logging.info('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(driver):\r\n+    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n+    logging.info(\"Attempting to locate the shadow host element.\")\r\n+    try:\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n+        print(\"Shadow host element found\")  # Debugging print\r\n+\r\n+        logging.info(\"Accessing the shadow root.\")\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n+        print(\"Shadow root accessed\")  # Debugging print\r\n+\r\n+        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n+        print(\"Easy Apply button found\")  # Debugging print\r\n+\r\n+        # Scroll the button into view before clicking\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button using JavaScript\r\n+        try:\r\n+            apply_now_button.click()  # Attempt to click the button\r\n+            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n+            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n+        except Exception as e:\r\n+            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n+\r\n+        return True\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        print(\"NoSuchElementException caught\")  # Debugging print\r\n+        return False\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        print(\"Unexpected exception caught\")  # Debugging print\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            logging.info(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        logging.info(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Call handle_login_modal right after the apply button is clicked\r\n+        handle_login_modal()\r\n+\r\n+        # Continue with the application process...\r\n+        # Wait for the apply modal to appear\r\n+        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the resume upload field to be present within the modal\r\n+        logging.info(f'Locating resume upload field for job: {job_title}')\r\n+        try:\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Resume upload field not found for job: {job_title}')\r\n+            print(f'Resume upload field not found for job: {job_title}')\r\n+            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n+        try:\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+        except TimeoutException:\r\n+            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    login_to_dice()\r\n+\r\n+    try:\r\n+        logging.info('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        logging.info('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                logging.info(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726909495510,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -176,16 +176,16 @@\n         modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n         logging.info(\"Modal dialog detected.\")\r\n         print(\"Modal dialog detected.\")  # Debugging print\r\n \r\n-        # Wait for the email field to be present and visible in the login modal\r\n-        email_field = wait.until(EC.visibility_of_element_located((By.ID, 'username')))\r\n+        # Since the email field is already focused, we can directly send keys to it\r\n         logging.info(\"Login modal detected. Entering credentials.\")\r\n         print(\"Login modal detected.\")  # Debugging print\r\n \r\n-        # Enter the email address\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n+        # Send the email address (assuming it is focused already)\r\n+        actions = ActionChains(driver)\r\n+        actions.send_keys(EMAIL)\r\n+        actions.perform()\r\n         logging.info(\"Entered email in modal.\")\r\n         print(\"Entered email in modal.\")  # Debugging print\r\n \r\n         # Wait for the password field to be visible\r\n@@ -201,9 +201,9 @@\n         logging.info(\"Clicked 'Log in' button in modal.\")\r\n         print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n \r\n         # Wait for the modal to disappear (indicating a successful login)\r\n-        wait.until(EC.invisibility_of_element_located((By.ID, 'username')))\r\n+        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n         logging.info(\"Successfully logged in via modal.\")\r\n         print(\"Successfully logged in via modal.\")  # Debugging print\r\n \r\n     except TimeoutException:\r\n@@ -627,636 +627,4 @@\n # -----------------------------\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to create directory {path}: {e}')\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info('Navigating to Dice login page.')\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        logging.info('Waiting for email field.')\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        logging.info('Locating \"Continue\" button.')\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        logging.info('Waiting for password field.')\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        logging.info('Locating \"Sign In\" button.')\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        logging.info('Waiting for dashboard to load.')\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def handle_login_modal():\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)\r\n-        logging.info(\"Checking if login modal is present.\")\r\n-        print(\"Checking if login modal is present.\")  # Debugging print\r\n-\r\n-        # Wait for the modal dialog itself to appear\r\n-        modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Modal dialog detected.\")\r\n-        print(\"Modal dialog detected.\")  # Debugging print\r\n-\r\n-        # Wait for the email field to be present and visible in the login modal\r\n-        email_field = wait.until(EC.visibility_of_element_located((By.ID, 'username')))\r\n-        logging.info(\"Login modal detected. Entering credentials.\")\r\n-        print(\"Login modal detected.\")  # Debugging print\r\n-\r\n-        # Enter the email address\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info(\"Entered email in modal.\")\r\n-        print(\"Entered email in modal.\")  # Debugging print\r\n-\r\n-        # Wait for the password field to be visible\r\n-        password_field = wait.until(EC.visibility_of_element_located((By.ID, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info(\"Entered password in modal.\")\r\n-        print(\"Entered password in modal.\")  # Debugging print\r\n-\r\n-        # Wait for the \"Log in\" button to be clickable\r\n-        login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'login-dhi-button button')))\r\n-        login_button.click()\r\n-        logging.info(\"Clicked 'Log in' button in modal.\")\r\n-        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n-\r\n-        # Wait for the modal to disappear (indicating a successful login)\r\n-        wait.until(EC.invisibility_of_element_located((By.ID, 'username')))\r\n-        logging.info(\"Successfully logged in via modal.\")\r\n-        print(\"Successfully logged in via modal.\")  # Debugging print\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(\"Login modal did not appear as expected.\")\r\n-        print(\"Login modal did not appear as expected.\")  # Debugging print\r\n-        capture_screenshot('login_modal_missing', subfolder='login')\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"Error finding login modal elements: {e}\")\r\n-        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n-\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        logging.info('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(driver):\r\n-    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n-    logging.info(\"Attempting to locate the shadow host element.\")\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n-        print(\"Shadow host element found\")  # Debugging print\r\n-\r\n-        logging.info(\"Accessing the shadow root.\")\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n-        print(\"Shadow root accessed\")  # Debugging print\r\n-\r\n-        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n-        print(\"Easy Apply button found\")  # Debugging print\r\n-\r\n-        # Scroll the button into view before clicking\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button using JavaScript\r\n-        try:\r\n-            apply_now_button.click()  # Attempt to click the button\r\n-            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n-            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n-        except Exception as e:\r\n-            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n-\r\n-        return True\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        print(\"NoSuchElementException caught\")  # Debugging print\r\n-        return False\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        print(\"Unexpected exception caught\")  # Debugging print\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            logging.info(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Call handle_login_modal right after the apply button is clicked\r\n-        handle_login_modal()\r\n-\r\n-        # Continue with the application process...\r\n-        # Wait for the apply modal to appear\r\n-        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the resume upload field to be present within the modal\r\n-        logging.info(f'Locating resume upload field for job: {job_title}')\r\n-        try:\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Resume upload field not found for job: {job_title}')\r\n-            print(f'Resume upload field not found for job: {job_title}')\r\n-            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-        try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-        except TimeoutException:\r\n-            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    login_to_dice()\r\n-\r\n-    try:\r\n-        logging.info('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        logging.info('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                logging.info(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n"
                },
                {
                    "date": 1726909641095,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -176,16 +176,20 @@\n         modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n         logging.info(\"Modal dialog detected.\")\r\n         print(\"Modal dialog detected.\")  # Debugging print\r\n \r\n-        # Since the email field is already focused, we can directly send keys to it\r\n-        logging.info(\"Login modal detected. Entering credentials.\")\r\n-        print(\"Login modal detected.\")  # Debugging print\r\n+        # Wait for the email field to be visible and focused\r\n+        email_field = wait.until(EC.visibility_of_element_located((By.ID, 'username')))\r\n+        logging.info(\"Email field detected and focused.\")\r\n+        print(\"Email field detected and focused.\")  # Debugging print\r\n \r\n-        # Send the email address (assuming it is focused already)\r\n-        actions = ActionChains(driver)\r\n-        actions.send_keys(EMAIL)\r\n-        actions.perform()\r\n+        # Clear any pre-existing text in the email field (just in case)\r\n+        email_field.clear()\r\n+\r\n+        # Now send the email keys\r\n+        logging.info(\"Sending email to the email field.\")\r\n+        email_field.send_keys(EMAIL)\r\n+        time.sleep(1)  # Wait for a moment to ensure the text is entered\r\n         logging.info(\"Entered email in modal.\")\r\n         print(\"Entered email in modal.\")  # Debugging print\r\n \r\n         # Wait for the password field to be visible\r\n@@ -217,8 +221,9 @@\n         logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n         capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n         print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n \r\n+\r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     Ensures that the filter button is clickable and not obscured by overlays.\r\n"
                },
                {
                    "date": 1726910002273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -176,13 +176,18 @@\n         modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n         logging.info(\"Modal dialog detected.\")\r\n         print(\"Modal dialog detected.\")  # Debugging print\r\n \r\n-        # Wait for the email field to be visible and focused\r\n+        # Ensure the email field is visible and can be interacted with\r\n         email_field = wait.until(EC.visibility_of_element_located((By.ID, 'username')))\r\n-        logging.info(\"Email field detected and focused.\")\r\n-        print(\"Email field detected and focused.\")  # Debugging print\r\n+        logging.info(\"Email field detected and ready for interaction.\")\r\n+        print(\"Email field detected and ready for interaction.\")  # Debugging print\r\n \r\n+        # Use ActionChains to focus on the email field\r\n+        ActionChains(driver).move_to_element(email_field).click().perform()\r\n+        logging.info(\"Clicked on the email field to focus it.\")\r\n+        print(\"Clicked on the email field to focus it.\")  # Debugging print\r\n+\r\n         # Clear any pre-existing text in the email field (just in case)\r\n         email_field.clear()\r\n \r\n         # Now send the email keys\r\n@@ -191,18 +196,30 @@\n         time.sleep(1)  # Wait for a moment to ensure the text is entered\r\n         logging.info(\"Entered email in modal.\")\r\n         print(\"Entered email in modal.\")  # Debugging print\r\n \r\n-        # Wait for the password field to be visible\r\n+        # Ensure the password field is visible and can be interacted with\r\n         password_field = wait.until(EC.visibility_of_element_located((By.ID, 'password')))\r\n+        logging.info(\"Password field detected and ready for interaction.\")\r\n+        print(\"Password field detected and ready for interaction.\")  # Debugging print\r\n+\r\n+        # Use ActionChains to focus on the password field\r\n+        ActionChains(driver).move_to_element(password_field).click().perform()\r\n+        logging.info(\"Clicked on the password field to focus it.\")\r\n+        print(\"Clicked on the password field to focus it.\")  # Debugging print\r\n+\r\n         password_field.clear()\r\n         password_field.send_keys(PASSWORD)\r\n         logging.info(\"Entered password in modal.\")\r\n         print(\"Entered password in modal.\")  # Debugging print\r\n \r\n-        # Wait for the \"Log in\" button to be clickable\r\n+        # Ensure the \"Log in\" button is visible and can be interacted with\r\n         login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'login-dhi-button button')))\r\n-        login_button.click()\r\n+        logging.info(\"Log in button detected and ready for interaction.\")\r\n+        print(\"Log in button detected and ready for interaction.\")  # Debugging print\r\n+\r\n+        # Use JavaScript to click the button to avoid any potential issues\r\n+        driver.execute_script(\"arguments[0].click();\", login_button)\r\n         logging.info(\"Clicked 'Log in' button in modal.\")\r\n         print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n \r\n         # Wait for the modal to disappear (indicating a successful login)\r\n"
                },
                {
                    "date": 1726910630672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,15 +54,17 @@\n \r\n # Initialize the WebDriver\r\n try:\r\n     driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n except WebDriverException as e:\r\n     logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n     print(f'Error initializing Chrome WebDriver: {e}')\r\n     exit(1)\r\n \r\n # Maximize browser window\r\n driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n \r\n # -----------------------------\r\n # Utility Functions\r\n # -----------------------------\r\n@@ -78,8 +80,9 @@\n     Creates a directory if it doesn't exist.\r\n     \"\"\"\r\n     try:\r\n         os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n     except Exception as e:\r\n         logging.error(f'Failed to create directory {path}: {e}')\r\n         print(f'Failed to create directory {path}: {e}')\r\n \r\n@@ -114,38 +117,47 @@\n         wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n \r\n         # Wait for the email field to be present\r\n         logging.info('Waiting for email field.')\r\n+        print('Waiting for email field.')\r\n         email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        print(\"Email field located.\")\r\n         email_field.clear()\r\n         email_field.send_keys(EMAIL)\r\n         logging.info('Entered email.')\r\n         print('Entered email.')\r\n \r\n         # Locate and click the \"Continue\" button\r\n         logging.info('Locating \"Continue\" button.')\r\n+        print('Locating \"Continue\" button.')\r\n         continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        print(\"Continue button located.\")\r\n         continue_button.click()\r\n         logging.info('Clicked \"Continue\" button.')\r\n         print('Clicked \"Continue\" button.')\r\n \r\n         # Wait for the password field to be present\r\n         logging.info('Waiting for password field.')\r\n+        print('Waiting for password field.')\r\n         password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        print(\"Password field located.\")\r\n         password_field.clear()\r\n         password_field.send_keys(PASSWORD)\r\n         logging.info('Entered password.')\r\n         print('Entered password.')\r\n \r\n         # Locate and click the \"Sign In\" button\r\n         logging.info('Locating \"Sign In\" button.')\r\n+        print('Locating \"Sign In\" button.')\r\n         sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        print(\"Sign In button located.\")\r\n         sign_in_button.click()\r\n         logging.info('Clicked \"Sign In\" button.')\r\n         print('Clicked \"Sign In\" button.')\r\n \r\n         # Wait until dashboard loads by checking URL or a specific element\r\n         logging.info('Waiting for dashboard to load.')\r\n+        print('Waiting for dashboard to load.')\r\n         wait.until(EC.url_contains('/dashboard'))\r\n         logging.info('Successfully logged into Dice.')\r\n         print(\"Successfully logged into Dice.\")\r\n \r\n@@ -176,49 +188,49 @@\n         modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n         logging.info(\"Modal dialog detected.\")\r\n         print(\"Modal dialog detected.\")  # Debugging print\r\n \r\n-        # Ensure the email field is visible and can be interacted with\r\n-        email_field = wait.until(EC.visibility_of_element_located((By.ID, 'username')))\r\n-        logging.info(\"Email field detected and ready for interaction.\")\r\n-        print(\"Email field detected and ready for interaction.\")  # Debugging print\r\n+        # Add a short sleep to ensure modal is fully loaded\r\n+        time.sleep(1)\r\n \r\n-        # Use ActionChains to focus on the email field\r\n+        # Ensure the email field is visible and ready for interaction\r\n+        email_field = wait.until(EC.element_to_be_clickable((By.ID, 'username')))\r\n+        logging.info(\"Email field detected and clickable.\")\r\n+        print(\"Email field detected and clickable.\")  # Debugging print\r\n+\r\n+        # Focus on the email field using ActionChains\r\n         ActionChains(driver).move_to_element(email_field).click().perform()\r\n-        logging.info(\"Clicked on the email field to focus it.\")\r\n-        print(\"Clicked on the email field to focus it.\")  # Debugging print\r\n+        logging.info(\"Focused on email field.\")\r\n+        print(\"Focused on email field.\")  # Debugging print\r\n \r\n-        # Clear any pre-existing text in the email field (just in case)\r\n+        # Clear any pre-existing text and send the email keys\r\n         email_field.clear()\r\n-\r\n-        # Now send the email keys\r\n-        logging.info(\"Sending email to the email field.\")\r\n         email_field.send_keys(EMAIL)\r\n-        time.sleep(1)  # Wait for a moment to ensure the text is entered\r\n+        time.sleep(1)  # Short pause to ensure the text is entered\r\n         logging.info(\"Entered email in modal.\")\r\n         print(\"Entered email in modal.\")  # Debugging print\r\n \r\n-        # Ensure the password field is visible and can be interacted with\r\n-        password_field = wait.until(EC.visibility_of_element_located((By.ID, 'password')))\r\n-        logging.info(\"Password field detected and ready for interaction.\")\r\n-        print(\"Password field detected and ready for interaction.\")  # Debugging print\r\n+        # Ensure the password field is visible and ready for interaction\r\n+        password_field = wait.until(EC.element_to_be_clickable((By.ID, 'password')))\r\n+        logging.info(\"Password field detected and clickable.\")\r\n+        print(\"Password field detected and clickable.\")  # Debugging print\r\n \r\n-        # Use ActionChains to focus on the password field\r\n+        # Focus on the password field using ActionChains\r\n         ActionChains(driver).move_to_element(password_field).click().perform()\r\n-        logging.info(\"Clicked on the password field to focus it.\")\r\n-        print(\"Clicked on the password field to focus it.\")  # Debugging print\r\n+        logging.info(\"Focused on password field.\")\r\n+        print(\"Focused on password field.\")  # Debugging print\r\n \r\n         password_field.clear()\r\n         password_field.send_keys(PASSWORD)\r\n         logging.info(\"Entered password in modal.\")\r\n         print(\"Entered password in modal.\")  # Debugging print\r\n \r\n-        # Ensure the \"Log in\" button is visible and can be interacted with\r\n+        # Ensure the \"Log in\" button is visible and clickable\r\n         login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'login-dhi-button button')))\r\n-        logging.info(\"Log in button detected and ready for interaction.\")\r\n-        print(\"Log in button detected and ready for interaction.\")  # Debugging print\r\n+        logging.info(\"Log in button detected and clickable.\")\r\n+        print(\"Log in button detected and clickable.\")  # Debugging print\r\n \r\n-        # Use JavaScript to click the button to avoid any potential issues\r\n+        # Click the login button using JavaScript to ensure it is clicked\r\n         driver.execute_script(\"arguments[0].click();\", login_button)\r\n         logging.info(\"Clicked 'Log in' button in modal.\")\r\n         print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n \r\n@@ -238,9 +250,8 @@\n         logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n         capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n         print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n \r\n-\r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     Ensures that the filter button is clickable and not obscured by overlays.\r\n@@ -249,8 +260,9 @@\n         wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n \r\n         # Wait for the filters widget to load\r\n         logging.info('Waiting for filters widget.')\r\n+        print('Waiting for filters widget.')\r\n         filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n         logging.info('Filters widget located.')\r\n         print('Filters widget located.')\r\n \r\n@@ -261,8 +273,9 @@\n \r\n         # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n         try:\r\n             logging.info('Locating \"Easy Apply\" accordion.')\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n             easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n                 EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n             )\r\n             logging.info('\"Easy Apply\" accordion located.')\r\n@@ -280,8 +293,9 @@\n \r\n         # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n         try:\r\n             logging.info('Locating \"Easy Apply\" filter button.')\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n             easy_apply_filter_button = easy_apply_accordion.find_element(\r\n                 By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n             )\r\n             logging.info('\"Easy Apply\" filter button located.')\r\n@@ -295,8 +309,9 @@\n \r\n         # Wait until the \"Easy Apply\" filter button is clickable\r\n         try:\r\n             logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n             easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n                 EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n             )\r\n         except TimeoutException:\r\n@@ -317,8 +332,9 @@\n         else:\r\n             # Click using ActionChains to ensure the element is in view\r\n             try:\r\n                 logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n                 ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n             except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n                 logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n                 driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n@@ -437,21 +453,25 @@\n         wait = WebDriverWait(driver, 20)  # Increased timeout\r\n \r\n         # Scroll the job card into view\r\n         logging.info(f'Scrolling into view for job: {job_title}')\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n         driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n         time.sleep(1)  # Wait for scrolling animation\r\n \r\n         # Click on the job title to open job details\r\n         logging.info(f'Locating job title link for: {job_title}')\r\n+        print(f'Locating job title link for: {job_title}')\r\n         title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n \r\n         # Wait until the title_element is clickable\r\n         logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n         wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n \r\n         try:\r\n             logging.info(f'Attempting to click on job title: {job_title}')\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n             title_element.click()\r\n             logging.info(f'Clicked on job title: {job_title}')\r\n             print(f'Clicked on job title: {job_title}')\r\n         except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n@@ -472,8 +492,9 @@\n             print(f'Job details opened in the same window for job: {job_title}')\r\n \r\n         # Wait for the job details panel to load\r\n         logging.info(f'Waiting for job details to load for: {job_title}')\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n         wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n         logging.debug(f'Job details loaded for: {job_title}')\r\n         print(f'Job details loaded for: {job_title}')\r\n@@ -490,8 +511,9 @@\n \r\n         # Continue with the application process...\r\n         # Wait for the apply modal to appear\r\n         logging.info(f'Waiting for apply modal for job: {job_title}')\r\n+        print(f'Waiting for apply modal for job: {job_title}')\r\n         try:\r\n             modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n             logging.debug(f'Apply modal appeared for job: {job_title}')\r\n             print(f'Apply modal appeared for job: {job_title}')\r\n@@ -502,8 +524,9 @@\n             return\r\n \r\n         # Wait for the resume upload field to be present within the modal\r\n         logging.info(f'Locating resume upload field for job: {job_title}')\r\n+        print(f'Locating resume upload field for job: {job_title}')\r\n         try:\r\n             upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n             upload_field.send_keys(RESUME_PATH)\r\n             logging.info(f'Uploaded resume for job: {job_title}')\r\n@@ -515,8 +538,9 @@\n             return\r\n \r\n         # Wait for the 'Submit' button to be clickable and click it\r\n         logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n+        print(f'Locating \"Submit\" button for job: {job_title}')\r\n         try:\r\n             submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n             submit_button.click()\r\n             logging.info(f'Successfully applied to {job_title}')\r\n@@ -569,19 +593,22 @@\n     login_to_dice()\r\n \r\n     try:\r\n         logging.info('Navigating to Dice homepage.')\r\n+        print('Navigating to Dice homepage.')\r\n         # Enter search criteria\r\n         driver.get('https://www.dice.com/')\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout\r\n         logging.info('Waiting for search field.')\r\n+        print('Waiting for search field.')\r\n         search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n         search_field.clear()\r\n         search_field.send_keys(SEARCH_TERMS)\r\n         logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n         print(f'Entered search terms: {SEARCH_TERMS}')\r\n \r\n         logging.info('Locating search button.')\r\n+        print('Locating search button.')\r\n         search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n         search_button.click()\r\n         logging.info('Clicked search button.')\r\n         print('Clicked search button.')\r\n@@ -593,16 +620,18 @@\n         time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n \r\n         # Get the list of job postings\r\n         logging.info('Locating job cards.')\r\n+        print('Locating job cards.')\r\n         job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n         logging.info(f'Found {len(job_cards)} job postings.')\r\n         print(f'Found {len(job_cards)} job postings.')\r\n \r\n         for index, job_card in enumerate(job_cards, start=1):\r\n             try:\r\n                 # Extract the job title using data-cy attribute\r\n                 logging.info(f'Processing job {index}.')\r\n+                print(f'Processing job {index}.')\r\n                 title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n                 job_title = title_element.text.strip()\r\n                 logging.info(f'Job {index}: Found title: {job_title}')\r\n                 print(f'Job {index}: Found title: {job_title}')\r\n"
                },
                {
                    "date": 1726910848036,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,8 +48,10 @@\n # Uncomment the following line to run the browser in headless mode\r\n # chrome_options.add_argument('--headless')\r\n \r\n # Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n+\r\n chrome_options.add_argument('--ignore-certificate-errors')\r\n chrome_options.add_argument('--ignore-ssl-errors')\r\n \r\n # Initialize the WebDriver\r\n"
                },
                {
                    "date": 1726910865212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n # chrome_options.add_argument('--headless')\r\n \r\n # Optional: Ignore SSL certificate errors (Use with caution)\r\n chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n-\r\n+chrome_options.add_argument('--disable-extensions')\r\n chrome_options.add_argument('--ignore-certificate-errors')\r\n chrome_options.add_argument('--ignore-ssl-errors')\r\n \r\n # Initialize the WebDriver\r\n"
                },
                {
                    "date": 1726911201061,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -119,51 +119,59 @@\n         wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n \r\n         # Wait for the email field to be present\r\n         logging.info('Waiting for email field.')\r\n-        print('Waiting for email field.')\r\n         email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        print(\"Email field located.\")\r\n         email_field.clear()\r\n         email_field.send_keys(EMAIL)\r\n         logging.info('Entered email.')\r\n         print('Entered email.')\r\n \r\n         # Locate and click the \"Continue\" button\r\n         logging.info('Locating \"Continue\" button.')\r\n-        print('Locating \"Continue\" button.')\r\n         continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        print(\"Continue button located.\")\r\n         continue_button.click()\r\n         logging.info('Clicked \"Continue\" button.')\r\n         print('Clicked \"Continue\" button.')\r\n \r\n         # Wait for the password field to be present\r\n         logging.info('Waiting for password field.')\r\n-        print('Waiting for password field.')\r\n         password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        print(\"Password field located.\")\r\n         password_field.clear()\r\n         password_field.send_keys(PASSWORD)\r\n         logging.info('Entered password.')\r\n         print('Entered password.')\r\n \r\n         # Locate and click the \"Sign In\" button\r\n         logging.info('Locating \"Sign In\" button.')\r\n-        print('Locating \"Sign In\" button.')\r\n         sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        print(\"Sign In button located.\")\r\n         sign_in_button.click()\r\n         logging.info('Clicked \"Sign In\" button.')\r\n         print('Clicked \"Sign In\" button.')\r\n \r\n         # Wait until dashboard loads by checking URL or a specific element\r\n         logging.info('Waiting for dashboard to load.')\r\n-        print('Waiting for dashboard to load.')\r\n         wait.until(EC.url_contains('/dashboard'))\r\n         logging.info('Successfully logged into Dice.')\r\n         print(\"Successfully logged into Dice.\")\r\n \r\n+        # Save cookies after successful login\r\n+        cookies = driver.get_cookies()\r\n+        logging.info(f\"Saved cookies after login: {cookies}\")\r\n+\r\n+        # Navigate to homepage\r\n+        driver.get('https://www.dice.com/')\r\n+        logging.info(\"Navigated to Dice homepage.\")\r\n+\r\n+        # Reapply cookies if needed\r\n+        for cookie in cookies:\r\n+            driver.add_cookie(cookie)\r\n+        logging.info(\"Reapplied cookies to maintain session.\")\r\n+\r\n+        # Verify session persistence\r\n+        driver.get('https://www.dice.com/dashboard')\r\n+        logging.info(\"Navigated to the dashboard to check session.\")\r\n+\r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error during login: {e}')\r\n         print(f\"Error during login: {e}\")\r\n         capture_screenshot('login_error', subfolder='login')\r\n@@ -176,8 +184,9 @@\n         capture_screenshot('login_redirection_error', subfolder='login')\r\n         driver.quit()\r\n         exit(1)\r\n \r\n+\r\n def handle_login_modal():\r\n     \"\"\"\r\n     Handles the login modal that appears after clicking \"Apply now\".\r\n     \"\"\"\r\n"
                },
                {
                    "date": 1726911338037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,20 +157,16 @@\n         # Save cookies after successful login\r\n         cookies = driver.get_cookies()\r\n         logging.info(f\"Saved cookies after login: {cookies}\")\r\n \r\n-        # Navigate to homepage\r\n-        driver.get('https://www.dice.com/')\r\n-        logging.info(\"Navigated to Dice homepage.\")\r\n-\r\n         # Reapply cookies if needed\r\n         for cookie in cookies:\r\n             driver.add_cookie(cookie)\r\n         logging.info(\"Reapplied cookies to maintain session.\")\r\n \r\n-        # Verify session persistence\r\n+        # Verify session persistence by checking if we're still on the dashboard\r\n         driver.get('https://www.dice.com/dashboard')\r\n-        logging.info(\"Navigated to the dashboard to check session.\")\r\n+        logging.info(\"Verified session persistence by navigating to the dashboard again.\")\r\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error during login: {e}')\r\n         print(f\"Error during login: {e}\")\r\n"
                },
                {
                    "date": 1726938907487,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,10 +26,8 @@\n \r\n SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n RESUME_PATH = config['DEFAULT']['ResumePath']\r\n PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n \r\n # Validate Resume Path\r\n if not os.path.isfile(RESUME_PATH):\r\n     print(f'Resume file not found at path: {RESUME_PATH}')\r\n@@ -108,157 +106,8 @@\n # -----------------------------\r\n # Function Definitions\r\n # -----------------------------\r\n \r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info('Navigating to Dice login page.')\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        logging.info('Waiting for email field.')\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        logging.info('Locating \"Continue\" button.')\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        logging.info('Waiting for password field.')\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        logging.info('Locating \"Sign In\" button.')\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        logging.info('Waiting for dashboard to load.')\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-        # Save cookies after successful login\r\n-        cookies = driver.get_cookies()\r\n-        logging.info(f\"Saved cookies after login: {cookies}\")\r\n-\r\n-        # Reapply cookies if needed\r\n-        for cookie in cookies:\r\n-            driver.add_cookie(cookie)\r\n-        logging.info(\"Reapplied cookies to maintain session.\")\r\n-\r\n-        # Verify session persistence by checking if we're still on the dashboard\r\n-        driver.get('https://www.dice.com/dashboard')\r\n-        logging.info(\"Verified session persistence by navigating to the dashboard again.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-\r\n-def handle_login_modal():\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)\r\n-        logging.info(\"Checking if login modal is present.\")\r\n-        print(\"Checking if login modal is present.\")  # Debugging print\r\n-\r\n-        # Wait for the modal dialog itself to appear\r\n-        modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Modal dialog detected.\")\r\n-        print(\"Modal dialog detected.\")  # Debugging print\r\n-\r\n-        # Add a short sleep to ensure modal is fully loaded\r\n-        time.sleep(1)\r\n-\r\n-        # Ensure the email field is visible and ready for interaction\r\n-        email_field = wait.until(EC.element_to_be_clickable((By.ID, 'username')))\r\n-        logging.info(\"Email field detected and clickable.\")\r\n-        print(\"Email field detected and clickable.\")  # Debugging print\r\n-\r\n-        # Focus on the email field using ActionChains\r\n-        ActionChains(driver).move_to_element(email_field).click().perform()\r\n-        logging.info(\"Focused on email field.\")\r\n-        print(\"Focused on email field.\")  # Debugging print\r\n-\r\n-        # Clear any pre-existing text and send the email keys\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        time.sleep(1)  # Short pause to ensure the text is entered\r\n-        logging.info(\"Entered email in modal.\")\r\n-        print(\"Entered email in modal.\")  # Debugging print\r\n-\r\n-        # Ensure the password field is visible and ready for interaction\r\n-        password_field = wait.until(EC.element_to_be_clickable((By.ID, 'password')))\r\n-        logging.info(\"Password field detected and clickable.\")\r\n-        print(\"Password field detected and clickable.\")  # Debugging print\r\n-\r\n-        # Focus on the password field using ActionChains\r\n-        ActionChains(driver).move_to_element(password_field).click().perform()\r\n-        logging.info(\"Focused on password field.\")\r\n-        print(\"Focused on password field.\")  # Debugging print\r\n-\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info(\"Entered password in modal.\")\r\n-        print(\"Entered password in modal.\")  # Debugging print\r\n-\r\n-        # Ensure the \"Log in\" button is visible and clickable\r\n-        login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'login-dhi-button button')))\r\n-        logging.info(\"Log in button detected and clickable.\")\r\n-        print(\"Log in button detected and clickable.\")  # Debugging print\r\n-\r\n-        # Click the login button using JavaScript to ensure it is clicked\r\n-        driver.execute_script(\"arguments[0].click();\", login_button)\r\n-        logging.info(\"Clicked 'Log in' button in modal.\")\r\n-        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n-\r\n-        # Wait for the modal to disappear (indicating a successful login)\r\n-        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Successfully logged in via modal.\")\r\n-        print(\"Successfully logged in via modal.\")  # Debugging print\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(\"Login modal did not appear as expected.\")\r\n-        print(\"Login modal did not appear as expected.\")  # Debugging print\r\n-        capture_screenshot('login_modal_missing', subfolder='login')\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"Error finding login modal elements: {e}\")\r\n-        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n-\r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     Ensures that the filter button is clickable and not obscured by overlays.\r\n@@ -512,11 +361,8 @@\n             print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return  # Exit if the button is not found\r\n \r\n-        # Call handle_login_modal right after the apply button is clicked\r\n-        handle_login_modal()\r\n-\r\n         # Continue with the application process...\r\n         # Wait for the apply modal to appear\r\n         logging.info(f'Waiting for apply modal for job: {job_title}')\r\n         print(f'Waiting for apply modal for job: {job_title}')\r\n@@ -596,10 +442,8 @@\n \r\n def main():\r\n     applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n-    login_to_dice()\r\n-\r\n     try:\r\n         logging.info('Navigating to Dice homepage.')\r\n         print('Navigating to Dice homepage.')\r\n         # Enter search criteria\r\n"
                },
                {
                    "date": 1726939701502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -366,36 +366,22 @@\n         # Wait for the apply modal to appear\r\n         logging.info(f'Waiting for apply modal for job: {job_title}')\r\n         print(f'Waiting for apply modal for job: {job_title}')\r\n         try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"steps\")]')))\r\n             logging.debug(f'Apply modal appeared for job: {job_title}')\r\n             print(f'Apply modal appeared for job: {job_title}')\r\n         except TimeoutException:\r\n             logging.error(f'Apply modal did not appear for job: {job_title}')\r\n             print(f'Apply modal did not appear for job: {job_title}')\r\n             capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return\r\n \r\n-        # Wait for the resume upload field to be present within the modal\r\n-        logging.info(f'Locating resume upload field for job: {job_title}')\r\n-        print(f'Locating resume upload field for job: {job_title}')\r\n-        try:\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Resume upload field not found for job: {job_title}')\r\n-            print(f'Resume upload field not found for job: {job_title}')\r\n-            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n         # Wait for the 'Submit' button to be clickable and click it\r\n         logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n         print(f'Locating \"Submit\" button for job: {job_title}')\r\n         try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Next\")]')))\r\n             submit_button.click()\r\n             logging.info(f'Successfully applied to {job_title}')\r\n             print(f\"Successfully applied to {job_title}\")\r\n         except TimeoutException:\r\n@@ -439,8 +425,39 @@\n             driver.switch_to.window(original_window)\r\n             logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n             print(f'Closed new window and switched back to original window after processing {job_title}')\r\n \r\n+def click_next_button():\r\n+    \"\"\"\r\n+    Waits for the 'Next' button to appear after the resume upload\r\n+    and clicks it.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the 'Next' button to be clickable\r\n+        logging.info('Waiting for \"Next\" button to be clickable.')\r\n+        print('Waiting for \"Next\" button to be clickable.')\r\n+        next_button = wait.until(\r\n+            EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]'))\r\n+        )\r\n+        \r\n+        # Scroll the button into view and click\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+        next_button.click()\r\n+        logging.info('\"Next\" button clicked.')\r\n+        print('\"Next\" button clicked.')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n+        print('Timeout: \"Next\" button did not become clickable.')\r\n+        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n+    except Exception as e:\r\n+        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n+        print(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n+        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n+\r\n def main():\r\n     applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n     try:\r\n"
                },
                {
                    "date": 1726940046285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,561 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('--disable-extensions')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to create directory {path}: {e}')\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        logging.info('Waiting for filters widget.')\r\n+        print('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" accordion.')\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" filter button.')\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(driver):\r\n+    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n+    logging.info(\"Attempting to locate the shadow host element.\")\r\n+    try:\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n+        print(\"Shadow host element found\")  # Debugging print\r\n+\r\n+        logging.info(\"Accessing the shadow root.\")\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n+        print(\"Shadow root accessed\")  # Debugging print\r\n+\r\n+        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n+        print(\"Easy Apply button found\")  # Debugging print\r\n+\r\n+        # Scroll the button into view before clicking\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button using JavaScript\r\n+        try:\r\n+            apply_now_button.click()  # Attempt to click the button\r\n+            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n+            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n+        except Exception as e:\r\n+            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n+\r\n+        return True\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        print(\"NoSuchElementException caught\")  # Debugging print\r\n+        return False\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        print(\"Unexpected exception caught\")  # Debugging print\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            logging.info(f'Attempting to click on job title: {job_title}')\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        logging.info(f'Waiting for job details to load for: {job_title}')\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Continue with the application process...\r\n+        # Wait for the apply modal to appear\r\n+        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n+        print(f'Waiting for apply modal for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"steps\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n+        print(f'Locating \"Submit\" button for job: {job_title}')\r\n+        try:\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Next\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+        except TimeoutException:\r\n+            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def click_next_button():\r\n+    \"\"\"\r\n+    Waits for the 'Next' button to appear after the resume upload\r\n+    and clicks it.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Attempting to locate the 'Next' button using the absolute XPath\r\n+        logging.info('Waiting for \"Next\" button to be clickable.')\r\n+        print('Waiting for \"Next\" button to be clickable.')\r\n+        next_button = wait.until(\r\n+            EC.element_to_be_clickable((By.XPATH, '/html/body/div[3]/div[4]/div/div[1]/div/div/span/seds-container/seds-row/seds-column/seds-column/div/main/div[4]/button[1]'))\r\n+        )\r\n+        \r\n+        # Scroll the button into view and click\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button using JavaScript\r\n+        try:\r\n+            next_button.click()  # Attempt to click the button normally\r\n+            logging.info('\"Next\" button clicked.')\r\n+            print('\"Next\" button clicked.')\r\n+        except Exception as e:\r\n+            logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", next_button)\r\n+            logging.info('\"Next\" button clicked using JavaScript.')\r\n+            print('\"Next\" button clicked using JavaScript.')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n+        print('Timeout: \"Next\" button did not become clickable.')\r\n+        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n+    except Exception as e:\r\n+        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n+        print(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n+        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n+\r\n+# Call the function after the resume is uploaded or after the 'Easy Apply' button is clicked\r\n+click_next_button()\r\n+\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    try:\r\n+        logging.info('Navigating to Dice homepage.')\r\n+        print('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n+        print('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        logging.info('Locating search button.')\r\n+        print('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n+        print('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                logging.info(f'Processing job {index}.')\r\n+                print(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726940428075,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -342,11 +342,11 @@\n             driver.switch_to.window(new_window)\r\n             logging.info(f'Switched to new window for job: {job_title}')\r\n             print(f'Switched to new window for job: {job_title}')\r\n         else:\r\n-            # Job details opened in the same window\r\n-            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n+            # Wait for a possible URL change due to redirection\r\n+            logging.info('Waiting for possible URL change after job title click.')\r\n+            wait.until(EC.url_changes(driver.current_url))\r\n \r\n         # Wait for the job details panel to load\r\n         logging.info(f'Waiting for job details to load for: {job_title}')\r\n         print(f'Waiting for job details to load for: {job_title}')\r\n@@ -558,553 +558,4 @@\n # -----------------------------\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n-chrome_options.add_argument('--disable-extensions')\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-    print(\"Initialized Chrome WebDriver.\")\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-print(\"Maximized browser window.\")\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-        print(f\"Created directory at path: {path}\")\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to create directory {path}: {e}')\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        logging.info('Waiting for filters widget.')\r\n-        print('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" accordion.')\r\n-            print('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" filter button.')\r\n-            print('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n-                print('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(driver):\r\n-    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n-    logging.info(\"Attempting to locate the shadow host element.\")\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n-        print(\"Shadow host element found\")  # Debugging print\r\n-\r\n-        logging.info(\"Accessing the shadow root.\")\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n-        print(\"Shadow root accessed\")  # Debugging print\r\n-\r\n-        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n-        print(\"Easy Apply button found\")  # Debugging print\r\n-\r\n-        # Scroll the button into view before clicking\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button using JavaScript\r\n-        try:\r\n-            apply_now_button.click()  # Attempt to click the button\r\n-            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n-            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n-        except Exception as e:\r\n-            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n-\r\n-        return True\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        print(\"NoSuchElementException caught\")  # Debugging print\r\n-        return False\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        print(\"Unexpected exception caught\")  # Debugging print\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        print(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            logging.info(f'Attempting to click on job title: {job_title}')\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Continue with the application process...\r\n-        # Wait for the apply modal to appear\r\n-        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        print(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"steps\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-        print(f'Locating \"Submit\" button for job: {job_title}')\r\n-        try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Next\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-        except TimeoutException:\r\n-            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def click_next_button():\r\n-    \"\"\"\r\n-    Waits for the 'Next' button to appear after the resume upload\r\n-    and clicks it.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the 'Next' button to be clickable\r\n-        logging.info('Waiting for \"Next\" button to be clickable.')\r\n-        print('Waiting for \"Next\" button to be clickable.')\r\n-        next_button = wait.until(\r\n-            EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]'))\r\n-        )\r\n-        \r\n-        # Scroll the button into view and click\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-        next_button.click()\r\n-        logging.info('\"Next\" button clicked.')\r\n-        print('\"Next\" button clicked.')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n-        print('Timeout: \"Next\" button did not become clickable.')\r\n-        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n-    except Exception as e:\r\n-        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n-        print(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n-        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    try:\r\n-        logging.info('Navigating to Dice homepage.')\r\n-        print('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        print('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        logging.info('Locating search button.')\r\n-        print('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        print('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                logging.info(f'Processing job {index}.')\r\n-                print(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n"
                },
                {
                    "date": 1726940607944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -379,8 +379,9 @@\n         # Wait for the 'Submit' button to be clickable and click it\r\n         logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n         print(f'Locating \"Submit\" button for job: {job_title}')\r\n         try:\r\n+            wait.until(EC.url_changes(driver.current_url))\r\n             submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Next\")]')))\r\n             submit_button.click()\r\n             logging.info(f'Successfully applied to {job_title}')\r\n             print(f\"Successfully applied to {job_title}\")\r\n"
                },
                {
                    "date": 1726941412454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -313,40 +313,24 @@\n         print(f'Scrolling into view for job: {job_title}')\r\n         driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n         time.sleep(1)  # Wait for scrolling animation\r\n \r\n-        # Click on the job title to open job details\r\n+        # Click on the job title to open job details in a new tab\r\n         logging.info(f'Locating job title link for: {job_title}')\r\n         print(f'Locating job title link for: {job_title}')\r\n         title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n \r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+        original_window = driver.current_window_handle\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n \r\n-        try:\r\n-            logging.info(f'Attempting to click on job title: {job_title}')\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n+        # Switch to the new tab\r\n         windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Wait for a possible URL change due to redirection\r\n-            logging.info('Waiting for possible URL change after job title click.')\r\n-            wait.until(EC.url_changes(driver.current_url))\r\n+        new_window = [window for window in windows_after_click if window != original_window][0]\r\n+        driver.switch_to.window(new_window)\r\n+        logging.info(f'Switched to new window for job: {job_title}')\r\n+        print(f'Switched to new window for job: {job_title}')\r\n \r\n         # Wait for the job details panel to load\r\n         logging.info(f'Waiting for job details to load for: {job_title}')\r\n         print(f'Waiting for job details to load for: {job_title}')\r\n@@ -361,57 +345,39 @@\n             print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return  # Exit if the button is not found\r\n \r\n-        # Continue with the application process...\r\n-        # Wait for the apply modal to appear\r\n-        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        print(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"steps\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n+        # Wait for the URL to change after clicking \"Apply Now\"\r\n+        wait.until(EC.url_changes(driver.current_url))\r\n+        logging.info('URL has changed after clicking Apply Now.')\r\n+        print('URL has changed after clicking Apply Now.')\r\n \r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-        print(f'Locating \"Submit\" button for job: {job_title}')\r\n+        # Locate and click the \"Next\" button on the application page\r\n+        logging.info(f'Locating \"Next\" button for job: {job_title}')\r\n+        print(f'Locating \"Next\" button for job: {job_title}')\r\n         try:\r\n-            wait.until(EC.url_changes(driver.current_url))\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Next\")]')))\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n             submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n+            logging.info(f'Successfully clicked \"Next\" for {job_title}')\r\n+            print(f'Successfully clicked \"Next\" for {job_title}\")\r\n         except TimeoutException:\r\n-            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            logging.error(f'\"Next\" button not found or not clickable for job: {job_title}')\r\n+            print(f'\"Next\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'next_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return\r\n \r\n         # Add the job to the set of applied jobs\r\n         applied_jobs.add(job_title)\r\n \r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n+        # Close the new tab and switch back to the original window\r\n+        driver.close()\r\n+        driver.switch_to.window(original_window)\r\n+        logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        print(f'Closed new window and switched back to original window after processing {job_title}')\r\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error applying to \"{job_title}\": {e}')\r\n         print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n         log_available_buttons(job_card, job_title)\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n \r\n     except Exception as e:\r\n@@ -419,15 +385,16 @@\n         print(f'Failed to apply to \"{job_title}\": {e}')\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n \r\n     finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n+        # Ensure any new window is closed and focus is back to the original window\r\n         if len(driver.window_handles) > 1:\r\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n             logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n             print(f'Closed new window and switched back to original window after processing {job_title}')\r\n \r\n+\r\n def click_next_button():\r\n     \"\"\"\r\n     Waits for the 'Next' button to appear after the resume upload\r\n     and clicks it.\r\n"
                },
                {
                    "date": 1726941676340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,691 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('--disable-extensions')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to create directory {path}: {e}')\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        logging.info('Waiting for filters widget.')\r\n+        print('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" accordion.')\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" filter button.')\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(driver):\r\n+    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n+    logging.info(\"Attempting to locate the shadow host element.\")\r\n+    try:\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n+        print(\"Shadow host element found\")  # Debugging print\r\n+\r\n+        logging.info(\"Accessing the shadow root.\")\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n+        print(\"Shadow root accessed\")  # Debugging print\r\n+\r\n+        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n+        print(\"Easy Apply button found\")  # Debugging print\r\n+\r\n+        # Scroll the button into view before clicking\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button using JavaScript\r\n+        try:\r\n+            apply_now_button.click()  # Attempt to click the button\r\n+            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n+            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n+        except Exception as e:\r\n+            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n+\r\n+        return True\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        print(\"NoSuchElementException caught\")  # Debugging print\r\n+        return False\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        print(\"Unexpected exception caught\")  # Debugging print\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            logging.info(f'Attempting to click on job title: {job_title}')\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Wait for a possible URL change due to redirection\r\n+            logging.info('Waiting for possible URL change after job title click.')\r\n+            wait.until(EC.url_changes(driver.current_url))\r\n+\r\n+        # Wait for the job details panel to load\r\n+        logging.info(f'Waiting for job details to load for: {job_title}')\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Continue with the application process...\r\n+        # Wait for the apply modal to appear\r\n+        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n+        print(f'Waiting for apply modal for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"steps\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n+        print(f'Locating \"Submit\" button for job: {job_title}')\r\n+        try:\r\n+            wait.until(EC.url_changes(driver.current_url))\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Next\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+        except TimeoutException:\r\n+            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            logging.info(f'Attempting to click on job title: {job_title}')\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Wait for a possible URL change due to redirection\r\n+            logging.info('Waiting for possible URL change after job title click.')\r\n+            wait.until(EC.url_changes(driver.current_url))\r\n+\r\n+        # Wait for the job details panel to load\r\n+        logging.info(f'Waiting for job details to load for: {job_title}')\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Continue with the application process...\r\n+        # Wait for the apply modal to appear\r\n+        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n+        print(f'Waiting for apply modal for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"steps\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n+        print(f'Locating \"Submit\" button for job: {job_title}')\r\n+        try:\r\n+            wait.until(EC.url_changes(driver.current_url))\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Next\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+        except TimeoutException:\r\n+            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def click_next_button():\r\n+    \"\"\"\r\n+    Waits for the 'Next' button to appear after the resume upload\r\n+    and clicks it.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Attempting to locate the 'Next' button using the absolute XPath\r\n+        logging.info('Waiting for \"Next\" button to be clickable.')\r\n+        print('Waiting for \"Next\" button to be clickable.')\r\n+        next_button = wait.until(\r\n+            EC.element_to_be_clickable((By.XPATH, '/html/body/div[3]/div[4]/div/div[1]/div/div/span/seds-container/seds-row/seds-column/seds-column/div/main/div[4]/button[1]'))\r\n+        )\r\n+        \r\n+        # Scroll the button into view and click\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button using JavaScript\r\n+        try:\r\n+            next_button.click()  # Attempt to click the button normally\r\n+            logging.info('\"Next\" button clicked.')\r\n+            print('\"Next\" button clicked.')\r\n+        except Exception as e:\r\n+            logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", next_button)\r\n+            logging.info('\"Next\" button clicked using JavaScript.')\r\n+            print('\"Next\" button clicked using JavaScript.')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n+        print('Timeout: \"Next\" button did not become clickable.')\r\n+        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n+    except Exception as e:\r\n+        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n+        print(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n+        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n+\r\n+# Call the function after the resume is uploaded or after the 'Easy Apply' button is clicked\r\n+click_next_button()\r\n+\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    try:\r\n+        logging.info('Navigating to Dice homepage.')\r\n+        print('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n+        print('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        logging.info('Locating search button.')\r\n+        print('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n+        print('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                logging.info(f'Processing job {index}.')\r\n+                print(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726941870988,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -594,12 +594,9 @@\n         logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n         print(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n         capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n \r\n-# Call the function after the resume is uploaded or after the 'Easy Apply' button is clicked\r\n-click_next_button()\r\n \r\n-\r\n def main():\r\n     applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n     try:\r\n@@ -688,533 +685,4 @@\n # -----------------------------\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n-chrome_options.add_argument('--disable-extensions')\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-    print(\"Initialized Chrome WebDriver.\")\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-print(\"Maximized browser window.\")\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-        print(f\"Created directory at path: {path}\")\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to create directory {path}: {e}')\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        logging.info('Waiting for filters widget.')\r\n-        print('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" accordion.')\r\n-            print('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" filter button.')\r\n-            print('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n-                print('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(driver):\r\n-    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n-    logging.info(\"Attempting to locate the shadow host element.\")\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n-        print(\"Shadow host element found\")  # Debugging print\r\n-\r\n-        logging.info(\"Accessing the shadow root.\")\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n-        print(\"Shadow root accessed\")  # Debugging print\r\n-\r\n-        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n-        print(\"Easy Apply button found\")  # Debugging print\r\n-\r\n-        # Scroll the button into view before clicking\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button using JavaScript\r\n-        try:\r\n-            apply_now_button.click()  # Attempt to click the button\r\n-            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n-            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n-        except Exception as e:\r\n-            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n-\r\n-        return True\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        print(\"NoSuchElementException caught\")  # Debugging print\r\n-        return False\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        print(\"Unexpected exception caught\")  # Debugging print\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details in a new tab\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        print(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        original_window = driver.current_window_handle\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Switch to the new tab\r\n-        windows_after_click = driver.window_handles\r\n-        new_window = [window for window in windows_after_click if window != original_window][0]\r\n-        driver.switch_to.window(new_window)\r\n-        logging.info(f'Switched to new window for job: {job_title}')\r\n-        print(f'Switched to new window for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Wait for the URL to change after clicking \"Apply Now\"\r\n-        wait.until(EC.url_changes(driver.current_url))\r\n-        logging.info('URL has changed after clicking Apply Now.')\r\n-        print('URL has changed after clicking Apply Now.')\r\n-\r\n-        # Locate and click the \"Next\" button on the application page\r\n-        logging.info(f'Locating \"Next\" button for job: {job_title}')\r\n-        print(f'Locating \"Next\" button for job: {job_title}')\r\n-        try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully clicked \"Next\" for {job_title}')\r\n-            print(f'Successfully clicked \"Next\" for {job_title}\")\r\n-        except TimeoutException:\r\n-            logging.error(f'\"Next\" button not found or not clickable for job: {job_title}')\r\n-            print(f'\"Next\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'next_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new tab and switch back to the original window\r\n-        driver.close()\r\n-        driver.switch_to.window(original_window)\r\n-        logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-\r\n-def click_next_button():\r\n-    \"\"\"\r\n-    Waits for the 'Next' button to appear after the resume upload\r\n-    and clicks it.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Attempting to locate the 'Next' button using the absolute XPath\r\n-        logging.info('Waiting for \"Next\" button to be clickable.')\r\n-        print('Waiting for \"Next\" button to be clickable.')\r\n-        next_button = wait.until(\r\n-            EC.element_to_be_clickable((By.XPATH, '/html/body/div[3]/div[4]/div/div[1]/div/div/span/seds-container/seds-row/seds-column/seds-column/div/main/div[4]/button[1]'))\r\n-        )\r\n-        \r\n-        # Scroll the button into view and click\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button using JavaScript\r\n-        try:\r\n-            next_button.click()  # Attempt to click the button normally\r\n-            logging.info('\"Next\" button clicked.')\r\n-            print('\"Next\" button clicked.')\r\n-        except Exception as e:\r\n-            logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", next_button)\r\n-            logging.info('\"Next\" button clicked using JavaScript.')\r\n-            print('\"Next\" button clicked using JavaScript.')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n-        print('Timeout: \"Next\" button did not become clickable.')\r\n-        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n-    except Exception as e:\r\n-        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n-        print(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n-        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n-\r\n-# Call the function after the resume is uploaded or after the 'Easy Apply' button is clicked\r\n-click_next_button()\r\n-\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    try:\r\n-        logging.info('Navigating to Dice homepage.')\r\n-        print('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        print('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        logging.info('Locating search button.')\r\n-        print('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        print('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                logging.info(f'Processing job {index}.')\r\n-                print(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n"
                },
                {
                    "date": 1726942031353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -498,8 +498,9 @@\n         try:\r\n             modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"steps\")]')))\r\n             logging.debug(f'Apply modal appeared for job: {job_title}')\r\n             print(f'Apply modal appeared for job: {job_title}')\r\n+            click_next_button()\r\n         except TimeoutException:\r\n             logging.error(f'Apply modal did not appear for job: {job_title}')\r\n             print(f'Apply modal did not appear for job: {job_title}')\r\n             capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n"
                },
                {
                    "date": 1726942257827,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -305,221 +305,66 @@\n         if job_title in applied_jobs:\r\n             logging.info(f'Skipping already applied job: {job_title}')\r\n             return  # Skip if we've already applied to this job\r\n \r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        wait = WebDriverWait(driver, 30)  # Increased timeout to handle new tab loading\r\n \r\n         # Scroll the job card into view\r\n         logging.info(f'Scrolling into view for job: {job_title}')\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n         driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n         time.sleep(1)  # Wait for scrolling animation\r\n \r\n         # Click on the job title to open job details\r\n         logging.info(f'Locating job title link for: {job_title}')\r\n-        print(f'Locating job title link for: {job_title}')\r\n         title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n \r\n         # Wait until the title_element is clickable\r\n         logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n         wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+        \r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n \r\n-        try:\r\n-            logging.info(f'Attempting to click on job title: {job_title}')\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n+        # Handle the new window or tab\r\n         original_window = driver.current_window_handle\r\n         windows_after_click = driver.window_handles\r\n         if len(windows_after_click) > 1:\r\n             new_window = [window for window in windows_after_click if window != original_window][0]\r\n             driver.switch_to.window(new_window)\r\n             logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Wait for a possible URL change due to redirection\r\n-            logging.info('Waiting for possible URL change after job title click.')\r\n-            wait.until(EC.url_changes(driver.current_url))\r\n \r\n-        # Wait for the job details panel to load\r\n-        logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n+        # Wait for the job details page to load and URL to change\r\n+        logging.info(f'Waiting for job details page to load for: {job_title}')\r\n+        wait.until(EC.url_changes(driver.current_url))\r\n         wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n \r\n-        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        # Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n         if not has_apply_now(driver):\r\n             logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return  # Exit if the button is not found\r\n \r\n-        # Continue with the application process...\r\n         # Wait for the apply modal to appear\r\n         logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        print(f'Waiting for apply modal for job: {job_title}')\r\n         try:\r\n             modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"steps\")]')))\r\n             logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-        print(f'Locating \"Submit\" button for job: {job_title}')\r\n-        try:\r\n-            wait.until(EC.url_changes(driver.current_url))\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Next\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-        except TimeoutException:\r\n-            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        print(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            logging.info(f'Attempting to click on job title: {job_title}')\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Wait for a possible URL change due to redirection\r\n-            logging.info('Waiting for possible URL change after job title click.')\r\n-            wait.until(EC.url_changes(driver.current_url))\r\n-\r\n-        # Wait for the job details panel to load\r\n-        logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Continue with the application process...\r\n-        # Wait for the apply modal to appear\r\n-        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        print(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"steps\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n             click_next_button()\r\n         except TimeoutException:\r\n             logging.error(f'Apply modal did not appear for job: {job_title}')\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n             capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return\r\n \r\n         # Wait for the 'Submit' button to be clickable and click it\r\n-        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-        print(f'Locating \"Submit\" button for job: {job_title}')\r\n+        logging.info(f'Locating \"Next\" button for job: {job_title}')\r\n         try:\r\n-            wait.until(EC.url_changes(driver.current_url))\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Next\")]')))\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n             submit_button.click()\r\n             logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n         except TimeoutException:\r\n-            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            logging.error(f'\"Next\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'next_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return\r\n \r\n         # Add the job to the set of applied jobs\r\n         applied_jobs.add(job_title)\r\n@@ -528,73 +373,54 @@\n         if len(driver.window_handles) > 1:\r\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n             logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n         else:\r\n-            # Navigate back to the job listings page\r\n             driver.back()\r\n             logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n         log_available_buttons(job_card, job_title)\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n \r\n     except Exception as e:\r\n         logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n \r\n     finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n         if len(driver.window_handles) > 1:\r\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n             logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n \r\n def click_next_button():\r\n     \"\"\"\r\n     Waits for the 'Next' button to appear after the resume upload\r\n     and clicks it.\r\n     \"\"\"\r\n     try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+        wait = WebDriverWait(driver, 30)  # Increased timeout for dynamic content\r\n \r\n-        # Attempting to locate the 'Next' button using the absolute XPath\r\n         logging.info('Waiting for \"Next\" button to be clickable.')\r\n-        print('Waiting for \"Next\" button to be clickable.')\r\n-        next_button = wait.until(\r\n-            EC.element_to_be_clickable((By.XPATH, '/html/body/div[3]/div[4]/div/div[1]/div/div/span/seds-container/seds-row/seds-column/seds-column/div/main/div[4]/button[1]'))\r\n-        )\r\n+        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n         \r\n-        # Scroll the button into view and click\r\n         driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n         time.sleep(1)  # Give time for scrolling animation\r\n \r\n-        # Try clicking the button using JavaScript\r\n         try:\r\n             next_button.click()  # Attempt to click the button normally\r\n             logging.info('\"Next\" button clicked.')\r\n-            print('\"Next\" button clicked.')\r\n         except Exception as e:\r\n             logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n             driver.execute_script(\"arguments[0].click();\", next_button)\r\n             logging.info('\"Next\" button clicked using JavaScript.')\r\n-            print('\"Next\" button clicked using JavaScript.')\r\n \r\n     except TimeoutException:\r\n         logging.error('Timeout: \"Next\" button did not become clickable.')\r\n-        print('Timeout: \"Next\" button did not become clickable.')\r\n         capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n     except Exception as e:\r\n         logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n-        print(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n         capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n \r\n \r\n def main():\r\n"
                },
                {
                    "date": 1726942624757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -331,11 +331,10 @@\n             new_window = [window for window in windows_after_click if window != original_window][0]\r\n             driver.switch_to.window(new_window)\r\n             logging.info(f'Switched to new window for job: {job_title}')\r\n \r\n-        # Wait for the job details page to load and URL to change\r\n+        # Wait for the job details page to load\r\n         logging.info(f'Waiting for job details page to load for: {job_title}')\r\n-        wait.until(EC.url_changes(driver.current_url))\r\n         wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n \r\n         # Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n@@ -343,31 +342,16 @@\n             logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return  # Exit if the button is not found\r\n \r\n-        # Wait for the apply modal to appear\r\n-        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"steps\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            click_next_button()\r\n-        except TimeoutException:\r\n-            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n+        # Click the \"Apply Now\" button and wait for URL to change\r\n+        logging.info(f'Clicking \"Apply Now\" button and waiting for URL change for job: {job_title}')\r\n+        wait.until(EC.url_changes(driver.current_url))\r\n \r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        logging.info(f'Locating \"Next\" button for job: {job_title}')\r\n-        try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'\"Next\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'next_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n+        # Now, wait for the \"Next\" button to appear and click it\r\n+        click_next_button()\r\n \r\n-        # Add the job to the set of applied jobs\r\n+        logging.info(f'Successfully applied to {job_title}')\r\n         applied_jobs.add(job_title)\r\n \r\n         # Close the new window or navigate back\r\n         if len(driver.window_handles) > 1:\r\n@@ -394,10 +378,9 @@\n             logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n \r\n def click_next_button():\r\n     \"\"\"\r\n-    Waits for the 'Next' button to appear after the resume upload\r\n-    and clicks it.\r\n+    Waits for the 'Next' button to appear after the apply modal is displayed and clicks it.\r\n     \"\"\"\r\n     try:\r\n         wait = WebDriverWait(driver, 30)  # Increased timeout for dynamic content\r\n \r\n@@ -422,8 +405,9 @@\n         logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n         capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n \r\n \r\n+\r\n def main():\r\n     applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n     try:\r\n"
                },
                {
                    "date": 1726942887720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -342,13 +342,19 @@\n             logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return  # Exit if the button is not found\r\n \r\n-        # Click the \"Apply Now\" button and wait for URL to change\r\n-        logging.info(f'Clicking \"Apply Now\" button and waiting for URL change for job: {job_title}')\r\n-        wait.until(EC.url_changes(driver.current_url))\r\n+        # Click the \"Apply Now\" button\r\n+        logging.info(f'Clicking \"Apply Now\" button for job: {job_title}')\r\n+        apply_now_button = driver.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        apply_now_button.click()\r\n \r\n+        # Wait for the URL to change to the application form URL\r\n+        logging.info(f'Waiting for URL change to application form for job: {job_title}')\r\n+        wait.until(EC.url_contains(\"dice.com/apply\"))\r\n+\r\n         # Now, wait for the \"Next\" button to appear and click it\r\n+        logging.info(f'Waiting for \"Next\" button to be clickable on the application form page.')\r\n         click_next_button()\r\n \r\n         logging.info(f'Successfully applied to {job_title}')\r\n         applied_jobs.add(job_title)\r\n@@ -404,10 +410,8 @@\n     except Exception as e:\r\n         logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n         capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n \r\n-\r\n-\r\n def main():\r\n     applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n     try:\r\n"
                },
                {
                    "date": 1726943189903,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -347,8 +347,24 @@\n         logging.info(f'Clicking \"Apply Now\" button for job: {job_title}')\r\n         apply_now_button = driver.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n         apply_now_button.click()\r\n \r\n+        # Wait for the login modal to appear\r\n+        logging.info('Waiting for login modal to appear.')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"login-modal\")]')))\r\n+        \r\n+        # Enter login details (you'll need to update these selectors and values to match your login form)\r\n+        logging.info('Entering login credentials.')\r\n+        username_field = driver.find_element(By.ID, 'username')  # Adjust the selector as needed\r\n+        password_field = driver.find_element(By.ID, 'password')  # Adjust the selector as needed\r\n+        username_field.send_keys(\"your_username\")  # Replace with your actual username\r\n+        password_field.send_keys(\"your_password\")  # Replace with your actual password\r\n+        \r\n+        # Submit the login form\r\n+        login_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Sign In\")]')  # Adjust as needed\r\n+        login_button.click()\r\n+        logging.info('Login form submitted.')\r\n+\r\n         # Wait for the URL to change to the application form URL\r\n         logging.info(f'Waiting for URL change to application form for job: {job_title}')\r\n         wait.until(EC.url_contains(\"dice.com/apply\"))\r\n \r\n@@ -410,8 +426,35 @@\n     except Exception as e:\r\n         logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n         capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n \r\n+    \"\"\"\r\n+    Waits for the 'Next' button to appear after the apply modal is displayed and clicks it.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 30)  # Increased timeout for dynamic content\r\n+\r\n+        logging.info('Waiting for \"Next\" button to be clickable.')\r\n+        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n+        \r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        try:\r\n+            next_button.click()  # Attempt to click the button normally\r\n+            logging.info('\"Next\" button clicked.')\r\n+        except Exception as e:\r\n+            logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", next_button)\r\n+            logging.info('\"Next\" button clicked using JavaScript.')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n+        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n+    except Exception as e:\r\n+        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n+        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n+\r\n def main():\r\n     applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n     try:\r\n"
                },
                {
                    "date": 1726944081494,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -347,21 +347,21 @@\n         logging.info(f'Clicking \"Apply Now\" button for job: {job_title}')\r\n         apply_now_button = driver.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n         apply_now_button.click()\r\n \r\n-        # Wait for the login modal to appear\r\n+        # Wait for the login modal to appear and stay visible\r\n         logging.info('Waiting for login modal to appear.')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"login-modal\")]')))\r\n-        \r\n+        login_modal = wait.until(EC.visibility_of_element_located((By.XPATH, '//div[contains(@class, \"login-modal\")]')))\r\n+\r\n         # Enter login details (you'll need to update these selectors and values to match your login form)\r\n         logging.info('Entering login credentials.')\r\n-        username_field = driver.find_element(By.ID, 'username')  # Adjust the selector as needed\r\n+        username_field = driver.find_element(By.ID, 'email')  # Adjust the selector as needed\r\n         password_field = driver.find_element(By.ID, 'password')  # Adjust the selector as needed\r\n         username_field.send_keys(\"your_username\")  # Replace with your actual username\r\n         password_field.send_keys(\"your_password\")  # Replace with your actual password\r\n         \r\n         # Submit the login form\r\n-        login_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Sign In\")]')  # Adjust as needed\r\n+        login_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Log in\")]')  # Adjust as needed\r\n         login_button.click()\r\n         logging.info('Login form submitted.')\r\n \r\n         # Wait for the URL to change to the application form URL\r\n@@ -426,58 +426,26 @@\n     except Exception as e:\r\n         logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n         capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n \r\n-    \"\"\"\r\n-    Waits for the 'Next' button to appear after the apply modal is displayed and clicks it.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 30)  # Increased timeout for dynamic content\r\n-\r\n-        logging.info('Waiting for \"Next\" button to be clickable.')\r\n-        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n-        \r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        try:\r\n-            next_button.click()  # Attempt to click the button normally\r\n-            logging.info('\"Next\" button clicked.')\r\n-        except Exception as e:\r\n-            logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", next_button)\r\n-            logging.info('\"Next\" button clicked using JavaScript.')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n-        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n-    except Exception as e:\r\n-        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n-        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n-\r\n+# Main Function\r\n def main():\r\n     applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n     try:\r\n         logging.info('Navigating to Dice homepage.')\r\n-        print('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n         driver.get('https://www.dice.com/')\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout\r\n         logging.info('Waiting for search field.')\r\n-        print('Waiting for search field.')\r\n         search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n         search_field.clear()\r\n         search_field.send_keys(SEARCH_TERMS)\r\n         logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n \r\n         logging.info('Locating search button.')\r\n-        print('Locating search button.')\r\n         search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n         search_button.click()\r\n         logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n \r\n         # Activate the \"Easy Apply\" filter\r\n         activate_easy_apply_filter()\r\n \r\n@@ -485,60 +453,43 @@\n         time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n \r\n         # Get the list of job postings\r\n         logging.info('Locating job cards.')\r\n-        print('Locating job cards.')\r\n         job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n         logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n \r\n         for index, job_card in enumerate(job_cards, start=1):\r\n             try:\r\n                 # Extract the job title using data-cy attribute\r\n                 logging.info(f'Processing job {index}.')\r\n-                print(f'Processing job {index}.')\r\n                 title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n                 job_title = title_element.text.strip()\r\n                 logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n \r\n             except NoSuchElementException:\r\n                 logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n                 job_card_html = job_card.get_attribute('outerHTML')\r\n                 logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n                 capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n                 continue\r\n \r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n             if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n                 logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n                 apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n                 time.sleep(PAUSE_DURATION)\r\n             else:\r\n                 logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n \r\n-        print(\"Job application process completed.\")\r\n         logging.info(\"Job application process completed.\")\r\n     except Exception as e:\r\n         logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n         capture_screenshot('main_exception', subfolder='main_errors')\r\n     finally:\r\n         driver.quit()\r\n \r\n+if __name__ == '__main__':\r\n+    main()\r\n+\r\n # -----------------------------\r\n # Entry Point\r\n # -----------------------------\r\n \r\n"
                },
                {
                    "date": 1726945051094,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,347 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('--disable-extensions')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to create directory {path}: {e}')\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        logging.info('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        easy_apply_accordion = wait.until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+        )\r\n+        logging.info('\"Easy Apply\" accordion located.')\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+            By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+        )\r\n+        logging.info('\"Easy Apply\" filter button located.')\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        wait.until(EC.element_to_be_clickable(easy_apply_filter_button))\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 30)  # Increased timeout to handle new tab loading\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        wait.until(EC.element_to_be_clickable(title_element))\r\n+        title_element.click()\r\n+        logging.info(f'Clicked on job title: {job_title}')\r\n+\r\n+        # Handle the new window or tab\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+\r\n+        # Wait for the job details page to load\r\n+        logging.info(f'Waiting for job details page to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+\r\n+        # Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Click the \"Apply Now\" button\r\n+        logging.info(f'Clicking \"Apply Now\" button for job: {job_title}')\r\n+        apply_now_button = driver.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        apply_now_button.click()\r\n+\r\n+        # Wait for the URL to change to the application form URL\r\n+        logging.info(f'Waiting for URL change to application form for job: {job_title}')\r\n+        wait.until(EC.url_contains(\"dice.com/apply\"))\r\n+\r\n+        # Now, wait for the \"Next\" button to appear and click it\r\n+        logging.info(f'Waiting for \"Next\" button to be clickable on the application form page.')\r\n+        click_next_button()\r\n+\r\n+        logging.info(f'Successfully applied to {job_title}')\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def click_next_button():\r\n+    \"\"\"\r\n+    Waits for the 'Next' button to appear after the apply modal is displayed and clicks it.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 30)  # Increased timeout for dynamic content\r\n+\r\n+        logging.info('Waiting for \"Next\" button to be clickable.')\r\n+        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n+        \r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        try:\r\n+            next_button.click()  # Attempt to click the button normally\r\n+            logging.info('\"Next\" button clicked.')\r\n+        except Exception as e:\r\n+            logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", next_button)\r\n+            logging.info('\"Next\" button clicked using JavaScript.')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n+        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n+    except Exception as e:\r\n+        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n+        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n+\r\n+# Main Function\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    try:\r\n+        logging.info('Navigating to Dice homepage.')\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        logging.info('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                logging.info(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726945311700,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n import os\r\n from selenium import webdriver\r\n from selenium.webdriver.common.by import By\r\n from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.action_chains import ActionChains\r\n from selenium.common.exceptions import (\r\n     NoSuchElementException,\r\n     WebDriverException,\r\n     TimeoutException,\r\n@@ -42,12 +42,8 @@\n )\r\n \r\n # Set up Chrome options\r\n chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n chrome_options.add_argument('--disable-extensions')\r\n chrome_options.add_argument('--ignore-certificate-errors')\r\n chrome_options.add_argument('--ignore-ssl-errors')\r\n@@ -106,8 +102,27 @@\n # -----------------------------\r\n # Function Definitions\r\n # -----------------------------\r\n \r\n+def wait_for_manual_login():\r\n+    \"\"\"\r\n+    Waits for the user to manually log in before proceeding.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 300)  # Wait up to 5 minutes for manual login\r\n+        print(\"Please log in manually, waiting for you to complete login...\")\r\n+        logging.info(\"Waiting for manual login.\")\r\n+\r\n+        # Assuming the presence of the job listings after login is complete\r\n+        wait.until(EC.presence_of_element_located((By.ID, 'searchResultsLocation')))\r\n+        print(\"Login completed, proceeding with the script.\")\r\n+        logging.info(\"Login completed.\")\r\n+    except TimeoutException:\r\n+        logging.error('Manual login not completed within timeout period.')\r\n+        print('Login not completed within timeout period.')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n def activate_easy_apply_filter():\r\n     \"\"\"\r\n     Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n     Ensures that the filter button is clickable and not obscured by overlays.\r\n@@ -115,9 +130,8 @@\n     try:\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n \r\n         # Wait for the filters widget to load\r\n-        logging.info('Waiting for filters widget.')\r\n         filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n         logging.info('Filters widget located.')\r\n \r\n         # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n@@ -206,9 +220,8 @@\n             driver.switch_to.window(new_window)\r\n             logging.info(f'Switched to new window for job: {job_title}')\r\n \r\n         # Wait for the job details page to load\r\n-        logging.info(f'Waiting for job details page to load for: {job_title}')\r\n         wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n \r\n         # Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n@@ -244,13 +257,11 @@\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error applying to \"{job_title}\": {e}')\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n     except Exception as e:\r\n         logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n     finally:\r\n         if len(driver.window_handles) > 1:\r\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n@@ -290,20 +301,10 @@\n \r\n     try:\r\n         logging.info('Navigating to Dice homepage.')\r\n         driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        wait_for_manual_login()  # Wait for the user to log in manually\r\n \r\n-        logging.info('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-\r\n         # Activate the \"Easy Apply\" filter\r\n         activate_easy_apply_filter()\r\n \r\n         # Wait for job listings to load\r\n"
                },
                {
                    "date": 1726945789628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,356 +42,8 @@\n )\r\n \r\n # Set up Chrome options\r\n chrome_options = Options()\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n-chrome_options.add_argument('--disable-extensions')\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-    print(\"Initialized Chrome WebDriver.\")\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-print(\"Maximized browser window.\")\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-        print(f\"Created directory at path: {path}\")\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to create directory {path}: {e}')\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def wait_for_manual_login():\r\n-    \"\"\"\r\n-    Waits for the user to manually log in before proceeding.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 300)  # Wait up to 5 minutes for manual login\r\n-        print(\"Please log in manually, waiting for you to complete login...\")\r\n-        logging.info(\"Waiting for manual login.\")\r\n-\r\n-        # Assuming the presence of the job listings after login is complete\r\n-        wait.until(EC.presence_of_element_located((By.ID, 'searchResultsLocation')))\r\n-        print(\"Login completed, proceeding with the script.\")\r\n-        logging.info(\"Login completed.\")\r\n-    except TimeoutException:\r\n-        logging.error('Manual login not completed within timeout period.')\r\n-        print('Login not completed within timeout period.')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        easy_apply_accordion = wait.until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-        )\r\n-        logging.info('\"Easy Apply\" accordion located.')\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-            By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-        )\r\n-        logging.info('\"Easy Apply\" filter button located.')\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        wait.until(EC.element_to_be_clickable(easy_apply_filter_button))\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            time.sleep(3)  # Wait for the page to refresh after applying the filter\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 30)  # Increased timeout to handle new tab loading\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-        wait.until(EC.element_to_be_clickable(title_element))\r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Handle the new window or tab\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-\r\n-        # Wait for the job details page to load\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-\r\n-        # Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Click the \"Apply Now\" button\r\n-        logging.info(f'Clicking \"Apply Now\" button for job: {job_title}')\r\n-        apply_now_button = driver.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        apply_now_button.click()\r\n-\r\n-        # Wait for the URL to change to the application form URL\r\n-        logging.info(f'Waiting for URL change to application form for job: {job_title}')\r\n-        wait.until(EC.url_contains(\"dice.com/apply\"))\r\n-\r\n-        # Now, wait for the \"Next\" button to appear and click it\r\n-        logging.info(f'Waiting for \"Next\" button to be clickable on the application form page.')\r\n-        click_next_button()\r\n-\r\n-        logging.info(f'Successfully applied to {job_title}')\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-    finally:\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def click_next_button():\r\n-    \"\"\"\r\n-    Waits for the 'Next' button to appear after the apply modal is displayed and clicks it.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 30)  # Increased timeout for dynamic content\r\n-\r\n-        logging.info('Waiting for \"Next\" button to be clickable.')\r\n-        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n-        \r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        try:\r\n-            next_button.click()  # Attempt to click the button normally\r\n-            logging.info('\"Next\" button clicked.')\r\n-        except Exception as e:\r\n-            logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", next_button)\r\n-            logging.info('\"Next\" button clicked using JavaScript.')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n-        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n-    except Exception as e:\r\n-        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n-        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n-\r\n-# Main Function\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    try:\r\n-        logging.info('Navigating to Dice homepage.')\r\n-        driver.get('https://www.dice.com/')\r\n-        wait_for_manual_login()  # Wait for the user to log in manually\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                logging.info(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n # Uncomment the following line to run the browser in headless mode\r\n # chrome_options.add_argument('--headless')\r\n \r\n # Optional: Ignore SSL certificate errors (Use with caution)\r\n@@ -403,16 +55,18 @@\n # Initialize the WebDriver\r\n try:\r\n     driver = webdriver.Chrome(options=chrome_options)\r\n     print(\"Initialized Chrome WebDriver.\")\r\n+    logging.info(\"Initialized Chrome WebDriver.\")\r\n except WebDriverException as e:\r\n     logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n     print(f'Error initializing Chrome WebDriver: {e}')\r\n     exit(1)\r\n \r\n # Maximize browser window\r\n driver.maximize_window()\r\n print(\"Maximized browser window.\")\r\n+logging.info(\"Maximized browser window.\")\r\n \r\n # -----------------------------\r\n # Utility Functions\r\n # -----------------------------\r\n@@ -429,8 +83,9 @@\n     \"\"\"\r\n     try:\r\n         os.makedirs(path, exist_ok=True)\r\n         print(f\"Created directory at path: {path}\")\r\n+        logging.info(f\"Created directory at path: {path}\")\r\n     except Exception as e:\r\n         logging.error(f'Failed to create directory {path}: {e}')\r\n         print(f'Failed to create directory {path}: {e}')\r\n \r\n@@ -540,8 +195,9 @@\n                 print('Attempting to click \"Easy Apply\" filter button.')\r\n                 ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n             except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n                 logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n                 driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n \r\n             logging.info('\"Easy Apply\" filter activated.')\r\n             print('\"Easy Apply\" filter activated.')\r\n@@ -581,23 +237,26 @@\n \r\n def has_apply_now(driver):\r\n     print(\"Entering `has_apply_now` function\")  # Debugging print\r\n     logging.info(\"Attempting to locate the shadow host element.\")\r\n+    print(\"Attempting to locate the shadow host element.\")  # Debugging print\r\n     try:\r\n         # Locate the shadow host element\r\n         shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n         logging.info(\"Shadow host element found: %s\", shadow_host)\r\n         print(\"Shadow host element found\")  # Debugging print\r\n \r\n         logging.info(\"Accessing the shadow root.\")\r\n+        print(\"Accessing the shadow root.\")  # Debugging print\r\n         shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n         logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n         print(\"Shadow root accessed\")  # Debugging print\r\n \r\n         logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n+        print(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")  # Debugging print\r\n         apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n         logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n-        print(\"Easy Apply button found\")  # Debugging print\r\n+        print(\"Found the 'Easy Apply' button\")  # Debugging print\r\n \r\n         # Scroll the button into view before clicking\r\n         driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n         time.sleep(1)  # Give time for scrolling animation\r\n@@ -608,22 +267,23 @@\n             logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n             print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n         except Exception as e:\r\n             logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            print(f\"Regular click failed: {e}, trying JavaScript click.\")  # Debugging print\r\n             driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n             logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n             print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n \r\n         return True\r\n     except NoSuchElementException as e:\r\n         logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n+        print(f\"NoSuchElementException: {str(e)} - Element not found.\")  # Debugging print\r\n         driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        print(\"NoSuchElementException caught\")  # Debugging print\r\n         return False\r\n     except Exception as e:\r\n         logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n+        print(f\"An unexpected error occurred: {str(e)}\")  # Debugging print\r\n         driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        print(\"Unexpected exception caught\")  # Debugging print\r\n         return False\r\n \r\n def log_available_buttons(job_card, job_title):\r\n     \"\"\"\r\n@@ -651,102 +311,109 @@\n     \"\"\"\r\n     try:\r\n         if job_title in applied_jobs:\r\n             logging.info(f'Skipping already applied job: {job_title}')\r\n+            print(f'Skipping already applied job: {job_title}')\r\n             return  # Skip if we've already applied to this job\r\n \r\n         wait = WebDriverWait(driver, 30)  # Increased timeout to handle new tab loading\r\n \r\n         # Scroll the job card into view\r\n         logging.info(f'Scrolling into view for job: {job_title}')\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n         driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n         time.sleep(1)  # Wait for scrolling animation\r\n \r\n         # Click on the job title to open job details\r\n         logging.info(f'Locating job title link for: {job_title}')\r\n+        print(f'Locating job title link for: {job_title}')\r\n         title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n \r\n         # Wait until the title_element is clickable\r\n         logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n         wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n         \r\n         title_element.click()\r\n         logging.info(f'Clicked on job title: {job_title}')\r\n+        print(f'Clicked on job title: {job_title}')\r\n \r\n         # Handle the new window or tab\r\n         original_window = driver.current_window_handle\r\n         windows_after_click = driver.window_handles\r\n         if len(windows_after_click) > 1:\r\n             new_window = [window for window in windows_after_click if window != original_window][0]\r\n             driver.switch_to.window(new_window)\r\n             logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n \r\n         # Wait for the job details page to load\r\n         logging.info(f'Waiting for job details page to load for: {job_title}')\r\n+        print(f'Waiting for job details page to load for: {job_title}')\r\n         wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n \r\n         # Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n         if not has_apply_now(driver):\r\n             logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n             return  # Exit if the button is not found\r\n \r\n         # Click the \"Apply Now\" button\r\n         logging.info(f'Clicking \"Apply Now\" button for job: {job_title}')\r\n+        print(f'Clicking \"Apply Now\" button for job: {job_title}')\r\n         apply_now_button = driver.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n         apply_now_button.click()\r\n \r\n         # Wait for the login modal to appear and stay visible\r\n         logging.info('Waiting for login modal to appear.')\r\n+        print('Waiting for login modal to appear.')\r\n         login_modal = wait.until(EC.visibility_of_element_located((By.XPATH, '//div[contains(@class, \"login-modal\")]')))\r\n \r\n-        # Enter login details (you'll need to update these selectors and values to match your login form)\r\n-        logging.info('Entering login credentials.')\r\n-        username_field = driver.find_element(By.ID, 'email')  # Adjust the selector as needed\r\n-        password_field = driver.find_element(By.ID, 'password')  # Adjust the selector as needed\r\n-        username_field.send_keys(\"your_username\")  # Replace with your actual username\r\n-        password_field.send_keys(\"your_password\")  # Replace with your actual password\r\n-        \r\n-        # Submit the login form\r\n-        login_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Log in\")]')  # Adjust as needed\r\n-        login_button.click()\r\n-        logging.info('Login form submitted.')\r\n+        logging.info('Waiting for the user to manually log in.')\r\n+        print('Waiting for the user to manually log in.')\r\n \r\n-        # Wait for the URL to change to the application form URL\r\n-        logging.info(f'Waiting for URL change to application form for job: {job_title}')\r\n+        # Wait until the URL changes to the application form page after login\r\n         wait.until(EC.url_contains(\"dice.com/apply\"))\r\n \r\n         # Now, wait for the \"Next\" button to appear and click it\r\n         logging.info(f'Waiting for \"Next\" button to be clickable on the application form page.')\r\n+        print(f'Waiting for \"Next\" button to be clickable on the application form page.')\r\n         click_next_button()\r\n \r\n         logging.info(f'Successfully applied to {job_title}')\r\n+        print(f'Successfully applied to {job_title}')\r\n         applied_jobs.add(job_title)\r\n \r\n         # Close the new window or navigate back\r\n         if len(driver.window_handles) > 1:\r\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n             logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n         else:\r\n             driver.back()\r\n             logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n         log_available_buttons(job_card, job_title)\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n \r\n     except Exception as e:\r\n         logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n \r\n     finally:\r\n         if len(driver.window_handles) > 1:\r\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n             logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n \r\n def click_next_button():\r\n     \"\"\"\r\n     Waits for the 'Next' button to appear after the apply modal is displayed and clicks it.\r\n@@ -754,46 +421,57 @@\n     try:\r\n         wait = WebDriverWait(driver, 30)  # Increased timeout for dynamic content\r\n \r\n         logging.info('Waiting for \"Next\" button to be clickable.')\r\n+        print('Waiting for \"Next\" button to be clickable.')\r\n         next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n         \r\n         driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n         time.sleep(1)  # Give time for scrolling animation\r\n \r\n         try:\r\n             next_button.click()  # Attempt to click the button normally\r\n             logging.info('\"Next\" button clicked.')\r\n+            print('\"Next\" button clicked.')\r\n         except Exception as e:\r\n             logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n+            print(f'Normal click failed: {e}, trying JavaScript click.')\r\n             driver.execute_script(\"arguments[0].click();\", next_button)\r\n             logging.info('\"Next\" button clicked using JavaScript.')\r\n+            print('\"Next\" button clicked using JavaScript.')\r\n \r\n     except TimeoutException:\r\n         logging.error('Timeout: \"Next\" button did not become clickable.')\r\n+        print('Timeout: \"Next\" button did not become clickable.')\r\n         capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n     except Exception as e:\r\n         logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n+        print(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n         capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n \r\n # Main Function\r\n def main():\r\n     applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n     try:\r\n         logging.info('Navigating to Dice homepage.')\r\n+        print('Navigating to Dice homepage.')\r\n         driver.get('https://www.dice.com/')\r\n         wait = WebDriverWait(driver, 20)  # Increased timeout\r\n         logging.info('Waiting for search field.')\r\n+        print('Waiting for search field.')\r\n         search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n         search_field.clear()\r\n         search_field.send_keys(SEARCH_TERMS)\r\n         logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n \r\n         logging.info('Locating search button.')\r\n+        print('Locating search button.')\r\n         search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n         search_button.click()\r\n         logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n \r\n         # Activate the \"Easy Apply\" filter\r\n         activate_easy_apply_filter()\r\n \r\n@@ -801,45 +479,48 @@\n         time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n \r\n         # Get the list of job postings\r\n         logging.info('Locating job cards.')\r\n+        print('Locating job cards.')\r\n         job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n         logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n \r\n         for index, job_card in enumerate(job_cards, start=1):\r\n             try:\r\n                 # Extract the job title using data-cy attribute\r\n                 logging.info(f'Processing job {index}.')\r\n+                print(f'Processing job {index}.')\r\n                 title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n                 job_title = title_element.text.strip()\r\n                 logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n \r\n             except NoSuchElementException:\r\n                 logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n                 job_card_html = job_card.get_attribute('outerHTML')\r\n                 logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n                 capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n                 continue\r\n \r\n             if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n                 logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Job {index}: Applying to job: {job_title}')\r\n                 apply_to_job(job_card, job_title, applied_jobs)\r\n                 time.sleep(PAUSE_DURATION)\r\n             else:\r\n                 logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f'Job {index}: Skipping job: {job_title}')\r\n \r\n         logging.info(\"Job application process completed.\")\r\n+        print(\"Job application process completed.\")\r\n     except Exception as e:\r\n         logging.error(f'An error occurred in main(): {e}')\r\n+        print(f'An error occurred in main(): {e}')\r\n         capture_screenshot('main_exception', subfolder='main_errors')\r\n     finally:\r\n         driver.quit()\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n"
                },
                {
                    "date": 1726945846832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n import os\r\n from selenium import webdriver\r\n from selenium.webdriver.common.by import By\r\n from selenium.webdriver.chrome.options import Options\r\n-from selenium.common.action_chains import ActionChains\r\n+from selenium.webdriver.common.action_chains import ActionChains \r\n from selenium.common.exceptions import (\r\n     NoSuchElementException,\r\n     WebDriverException,\r\n     TimeoutException,\r\n"
                },
                {
                    "date": 1726946500905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n import os\r\n from selenium import webdriver\r\n from selenium.webdriver.common.by import By\r\n from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains \r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n from selenium.common.exceptions import (\r\n     NoSuchElementException,\r\n     WebDriverException,\r\n     TimeoutException,\r\n@@ -33,492 +33,229 @@\n     print(f'Resume file not found at path: {RESUME_PATH}')\r\n     logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n     exit(1)\r\n \r\n-# Configure logging\r\n+# Configure logging to both file and console\r\n logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+    level=logging.DEBUG,\r\n+    format='%(asctime)s:%(levelname)s:%(message)s',\r\n+    handlers=[\r\n+        logging.FileHandler('application_log.txt'),\r\n+        logging.StreamHandler()\r\n+    ]\r\n )\r\n \r\n # Set up Chrome options\r\n chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n chrome_options.add_argument('--disable-extensions')\r\n chrome_options.add_argument('--ignore-certificate-errors')\r\n chrome_options.add_argument('--ignore-ssl-errors')\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n \r\n # Initialize the WebDriver\r\n try:\r\n     driver = webdriver.Chrome(options=chrome_options)\r\n-    print(\"Initialized Chrome WebDriver.\")\r\n     logging.info(\"Initialized Chrome WebDriver.\")\r\n except WebDriverException as e:\r\n     logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n     exit(1)\r\n \r\n # Maximize browser window\r\n driver.maximize_window()\r\n-print(\"Maximized browser window.\")\r\n logging.info(\"Maximized browser window.\")\r\n \r\n # -----------------------------\r\n # Utility Functions\r\n # -----------------------------\r\n \r\n def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n     return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n \r\n def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n     try:\r\n         os.makedirs(path, exist_ok=True)\r\n-        print(f\"Created directory at path: {path}\")\r\n         logging.info(f\"Created directory at path: {path}\")\r\n     except Exception as e:\r\n         logging.error(f'Failed to create directory {path}: {e}')\r\n-        print(f'Failed to create directory {path}: {e}')\r\n \r\n def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n     try:\r\n         timestamp = int(time.time())\r\n         screenshots_dir = os.path.join('screenshots', subfolder)\r\n         create_directory(screenshots_dir)\r\n         sanitized_name = sanitize_title(name)\r\n         screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n         driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n+        logging.info(f'Screenshot saved to {screenshot_path}')\r\n     except Exception as e:\r\n         logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n \r\n # -----------------------------\r\n # Function Definitions\r\n # -----------------------------\r\n \r\n def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n     try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        logging.info('Waiting for filters widget.')\r\n-        print('Waiting for filters widget.')\r\n+        wait = WebDriverWait(driver, 20)\r\n         filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n         logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" accordion.')\r\n-            print('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n+        easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+            EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+        )\r\n+        logging.info('\"Easy Apply\" accordion located.')\r\n         driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n+        time.sleep(1)\r\n \r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" filter button.')\r\n-            print('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n+        easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+            By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+        )\r\n+        logging.info('\"Easy Apply\" filter button located.')\r\n         aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        logging.info(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n \r\n-        if aria_checked == 'true':\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n+        if aria_checked != 'true':\r\n             try:\r\n-                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n-                print('Attempting to click \"Easy Apply\" filter button.')\r\n                 ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+                logging.info('\"Easy Apply\" filter activated.')\r\n+                time.sleep(3)\r\n             except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n                 logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n                 driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+                logging.info('\"Easy Apply\" filter activated using JavaScript.')\r\n \r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n+        if 'filters.easyApply=true' not in driver.current_url:\r\n             driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n             wait.until(EC.presence_of_all_elements_located(\r\n                 (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n             ))\r\n             logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n         else:\r\n             logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n         capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n         driver.quit()\r\n         exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n \r\n def has_apply_now(driver):\r\n-    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n-    logging.info(\"Attempting to locate the shadow host element.\")\r\n-    print(\"Attempting to locate the shadow host element.\")  # Debugging print\r\n+    logging.info(\"Entering `has_apply_now` function\")\r\n     try:\r\n-        # Locate the shadow host element\r\n         shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n-        print(\"Shadow host element found\")  # Debugging print\r\n-\r\n-        logging.info(\"Accessing the shadow root.\")\r\n-        print(\"Accessing the shadow root.\")  # Debugging print\r\n         shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n-        print(\"Shadow root accessed\")  # Debugging print\r\n-\r\n-        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n-        print(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")  # Debugging print\r\n         apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n-        print(\"Found the 'Easy Apply' button\")  # Debugging print\r\n-\r\n-        # Scroll the button into view before clicking\r\n+        logging.info(\"Found the 'Easy Apply' button.\")\r\n         driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button using JavaScript\r\n-        try:\r\n-            apply_now_button.click()  # Attempt to click the button\r\n-            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n-            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n-        except Exception as e:\r\n-            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n-            print(f\"Regular click failed: {e}, trying JavaScript click.\")  # Debugging print\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n-\r\n+        time.sleep(1)\r\n+        apply_now_button.click()\r\n+        logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n         return True\r\n     except NoSuchElementException as e:\r\n         logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        print(f\"NoSuchElementException: {str(e)} - Element not found.\")  # Debugging print\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        capture_screenshot('easy_apply_missing', subfolder='easy_apply_missing')\r\n         return False\r\n     except Exception as e:\r\n         logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n-        print(f\"An unexpected error occurred: {str(e)}\")  # Debugging print\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        capture_screenshot('unexpected_error', subfolder='easy_apply_missing')\r\n         return False\r\n \r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    if job_title in applied_jobs:\r\n+        logging.info(f'Skipping already applied job: {job_title}')\r\n+        return\r\n \r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n     try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            print(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 30)  # Increased timeout to handle new tab loading\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n+        wait = WebDriverWait(driver, 30)\r\n         driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        print(f'Locating job title link for: {job_title}')\r\n+        time.sleep(1)\r\n         title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n         wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-        \r\n         title_element.click()\r\n         logging.info(f'Clicked on job title: {job_title}')\r\n-        print(f'Clicked on job title: {job_title}')\r\n \r\n-        # Handle the new window or tab\r\n         original_window = driver.current_window_handle\r\n         windows_after_click = driver.window_handles\r\n         if len(windows_after_click) > 1:\r\n             new_window = [window for window in windows_after_click if window != original_window][0]\r\n             driver.switch_to.window(new_window)\r\n             logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n \r\n-        # Wait for the job details page to load\r\n-        logging.info(f'Waiting for job details page to load for: {job_title}')\r\n-        print(f'Waiting for job details page to load for: {job_title}')\r\n         wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        time.sleep(2)\r\n \r\n-        # Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n         if not has_apply_now(driver):\r\n             logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n+            return\r\n \r\n-        # Click the \"Apply Now\" button\r\n-        logging.info(f'Clicking \"Apply Now\" button for job: {job_title}')\r\n-        print(f'Clicking \"Apply Now\" button for job: {job_title}')\r\n-        apply_now_button = driver.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        apply_now_button.click()\r\n-\r\n-        # Wait for the login modal to appear and stay visible\r\n-        logging.info('Waiting for login modal to appear.')\r\n-        print('Waiting for login modal to appear.')\r\n-        login_modal = wait.until(EC.visibility_of_element_located((By.XPATH, '//div[contains(@class, \"login-modal\")]')))\r\n-\r\n-        logging.info('Waiting for the user to manually log in.')\r\n-        print('Waiting for the user to manually log in.')\r\n-\r\n-        # Wait until the URL changes to the application form page after login\r\n+        logging.info(f'Waiting for user login before proceeding with application for job: {job_title}')\r\n         wait.until(EC.url_contains(\"dice.com/apply\"))\r\n \r\n-        # Now, wait for the \"Next\" button to appear and click it\r\n-        logging.info(f'Waiting for \"Next\" button to be clickable on the application form page.')\r\n-        print(f'Waiting for \"Next\" button to be clickable on the application form page.')\r\n-        click_next_button()\r\n-\r\n         logging.info(f'Successfully applied to {job_title}')\r\n-        print(f'Successfully applied to {job_title}')\r\n         applied_jobs.add(job_title)\r\n \r\n-        # Close the new window or navigate back\r\n         if len(driver.window_handles) > 1:\r\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n             logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n         else:\r\n             driver.back()\r\n             logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        log_available_buttons(job_card, job_title)\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n     except Exception as e:\r\n         logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n     finally:\r\n         if len(driver.window_handles) > 1:\r\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n \r\n-def click_next_button():\r\n-    \"\"\"\r\n-    Waits for the 'Next' button to appear after the apply modal is displayed and clicks it.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 30)  # Increased timeout for dynamic content\r\n-\r\n-        logging.info('Waiting for \"Next\" button to be clickable.')\r\n-        print('Waiting for \"Next\" button to be clickable.')\r\n-        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n-        \r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        try:\r\n-            next_button.click()  # Attempt to click the button normally\r\n-            logging.info('\"Next\" button clicked.')\r\n-            print('\"Next\" button clicked.')\r\n-        except Exception as e:\r\n-            logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n-            print(f'Normal click failed: {e}, trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", next_button)\r\n-            logging.info('\"Next\" button clicked using JavaScript.')\r\n-            print('\"Next\" button clicked using JavaScript.')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n-        print('Timeout: \"Next\" button did not become clickable.')\r\n-        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n-    except Exception as e:\r\n-        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n-        print(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n-        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n-\r\n-# Main Function\r\n def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n+    applied_jobs = set()\r\n \r\n     try:\r\n         logging.info('Navigating to Dice homepage.')\r\n-        print('Navigating to Dice homepage.')\r\n         driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        print('Waiting for search field.')\r\n+        wait = WebDriverWait(driver, 20)\r\n         search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n         search_field.clear()\r\n         search_field.send_keys(SEARCH_TERMS)\r\n         logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n \r\n-        logging.info('Locating search button.')\r\n-        print('Locating search button.')\r\n         search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n         search_button.click()\r\n         logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n \r\n-        # Activate the \"Easy Apply\" filter\r\n         activate_easy_apply_filter()\r\n+        time.sleep(3)\r\n \r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        print('Locating job cards.')\r\n         job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n         logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n \r\n         for index, job_card in enumerate(job_cards, start=1):\r\n             try:\r\n-                # Extract the job title using data-cy attribute\r\n                 logging.info(f'Processing job {index}.')\r\n-                print(f'Processing job {index}.')\r\n                 title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n                 job_title = title_element.text.strip()\r\n                 logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n             except NoSuchElementException:\r\n                 logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n                 capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n                 continue\r\n \r\n             if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n                 logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Job {index}: Applying to job: {job_title}')\r\n                 apply_to_job(job_card, job_title, applied_jobs)\r\n                 time.sleep(PAUSE_DURATION)\r\n             else:\r\n                 logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f'Job {index}: Skipping job: {job_title}')\r\n \r\n         logging.info(\"Job application process completed.\")\r\n-        print(\"Job application process completed.\")\r\n     except Exception as e:\r\n         logging.error(f'An error occurred in main(): {e}')\r\n-        print(f'An error occurred in main(): {e}')\r\n         capture_screenshot('main_exception', subfolder='main_errors')\r\n     finally:\r\n         driver.quit()\r\n \r\n"
                },
                {
                    "date": 1726947170242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,24 +33,26 @@\n     print(f'Resume file not found at path: {RESUME_PATH}')\r\n     logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n     exit(1)\r\n \r\n-# Configure logging to both file and console\r\n+# Configure logging\r\n logging.basicConfig(\r\n-    level=logging.DEBUG,\r\n-    format='%(asctime)s:%(levelname)s:%(message)s',\r\n-    handlers=[\r\n-        logging.FileHandler('application_log.txt'),\r\n-        logging.StreamHandler()\r\n-    ]\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n )\r\n \r\n+console_handler = logging.StreamHandler()\r\n+console_handler.setLevel(logging.DEBUG)\r\n+console_handler.setFormatter(logging.Formatter('%(asctime)s:%(levelname)s:%(message)s'))\r\n+logging.getLogger().addHandler(console_handler)\r\n+\r\n # Set up Chrome options\r\n chrome_options = Options()\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n chrome_options.add_argument('--disable-extensions')\r\n chrome_options.add_argument('--ignore-certificate-errors')\r\n chrome_options.add_argument('--ignore-ssl-errors')\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n \r\n # Initialize the WebDriver\r\n try:\r\n     driver = webdriver.Chrome(options=chrome_options)\r\n@@ -67,18 +69,27 @@\n # Utility Functions\r\n # -----------------------------\r\n \r\n def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n     return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n \r\n def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n     try:\r\n         os.makedirs(path, exist_ok=True)\r\n         logging.info(f\"Created directory at path: {path}\")\r\n     except Exception as e:\r\n         logging.error(f'Failed to create directory {path}: {e}')\r\n \r\n def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n     try:\r\n         timestamp = int(time.time())\r\n         screenshots_dir = os.path.join('screenshots', subfolder)\r\n         create_directory(screenshots_dir)\r\n@@ -93,38 +104,93 @@\n # Function Definitions\r\n # -----------------------------\r\n \r\n def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n     try:\r\n-        wait = WebDriverWait(driver, 20)\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        logging.info('Waiting for filters widget.')\r\n         filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n         logging.info('Filters widget located.')\r\n-        easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-            EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-        )\r\n-        logging.info('\"Easy Apply\" accordion located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n         driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n \r\n-        easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-            By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-        )\r\n-        logging.info('\"Easy Apply\" filter button located.')\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n         aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.info(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n \r\n-        if aria_checked != 'true':\r\n+        if aria_checked == 'true':\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n             try:\r\n+                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n                 ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-                logging.info('\"Easy Apply\" filter activated.')\r\n-                time.sleep(3)\r\n             except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n                 logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n                 driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-                logging.info('\"Easy Apply\" filter activated using JavaScript.')\r\n \r\n-        if 'filters.easyApply=true' not in driver.current_url:\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n             driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n             wait.until(EC.presence_of_all_elements_located(\r\n                 (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n             ))\r\n             logging.info('Navigated to filtered URL.')\r\n@@ -135,65 +201,140 @@\n         logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n         capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n         driver.quit()\r\n         exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n \r\n def has_apply_now(driver):\r\n-    logging.info(\"Entering `has_apply_now` function\")\r\n+    logging.info(\"Entering `has_apply_now` function.\")\r\n     try:\r\n+        # Locate the shadow host element\r\n         shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        logging.info(\"Shadow host element found.\")\r\n+\r\n+        # Access the shadow root\r\n         shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        logging.info(\"Shadow root accessed.\")\r\n+\r\n+        # Locate the 'Easy Apply' button within the shadow root\r\n         apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n         logging.info(\"Found the 'Easy Apply' button.\")\r\n+\r\n+        # Scroll the button into view before clicking\r\n         driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)\r\n-        apply_now_button.click()\r\n-        logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button using JavaScript\r\n+        try:\r\n+            apply_now_button.click()  # Attempt to click the button\r\n+            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n+        except Exception as e:\r\n+            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+\r\n         return True\r\n     except NoSuchElementException as e:\r\n         logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        capture_screenshot('easy_apply_missing', subfolder='easy_apply_missing')\r\n+        capture_screenshot('easy_apply_not_found', subfolder='easy_apply_missing')\r\n         return False\r\n     except Exception as e:\r\n         logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n         capture_screenshot('unexpected_error', subfolder='easy_apply_missing')\r\n         return False\r\n \r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n def apply_to_job(job_card, job_title, applied_jobs):\r\n-    if job_title in applied_jobs:\r\n-        logging.info(f'Skipping already applied job: {job_title}')\r\n-        return\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n \r\n-    try:\r\n-        wait = WebDriverWait(driver, 30)\r\n+        wait = WebDriverWait(driver, 30)  # Increased timeout to handle new tab loading\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n         driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n         title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n         wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+        \r\n         title_element.click()\r\n         logging.info(f'Clicked on job title: {job_title}')\r\n \r\n+        # Handle the new window or tab\r\n         original_window = driver.current_window_handle\r\n         windows_after_click = driver.window_handles\r\n         if len(windows_after_click) > 1:\r\n             new_window = [window for window in windows_after_click if window != original_window][0]\r\n             driver.switch_to.window(new_window)\r\n             logging.info(f'Switched to new window for job: {job_title}')\r\n \r\n+        # Wait for the job details page to load\r\n+        logging.info(f'Waiting for job details page to load for: {job_title}')\r\n         wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n \r\n+        # Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n         if not has_apply_now(driver):\r\n             logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n             capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n+            return  # Exit if the button is not found\r\n \r\n-        logging.info(f'Waiting for user login before proceeding with application for job: {job_title}')\r\n-        wait.until(EC.url_contains(\"dice.com/apply\"))\r\n+        # Click the \"Apply Now\" button\r\n+        logging.info(f'Clicking \"Apply Now\" button for job: {job_title}')\r\n+        apply_now_button = driver.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        apply_now_button.click()\r\n \r\n+        # Wait for the login modal to appear and stay visible\r\n+        logging.info('Waiting for login modal to appear.')\r\n+        login_modal = wait.until(EC.visibility_of_element_located((By.XPATH, '//div[contains(@class, \"login-modal\")]')))\r\n+\r\n+        # Log in manually, as requested by the user\r\n+        logging.info('Login modal found. Please log in manually.')\r\n+        while True:\r\n+            if driver.current_url.startswith(\"https://www.dice.com/apply\"):\r\n+                logging.info(\"Login successful, URL has changed.\")\r\n+                break\r\n+            time.sleep(1)\r\n+\r\n+        # Wait for the \"Next\" button to appear and click it\r\n+        logging.info(f'Waiting for \"Next\" button to be clickable on the application form page.')\r\n+        click_next_button()\r\n+\r\n         logging.info(f'Successfully applied to {job_title}')\r\n         applied_jobs.add(job_title)\r\n \r\n+        # Close the new window or navigate back\r\n         if len(driver.window_handles) > 1:\r\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n             logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n@@ -202,47 +343,91 @@\n             logging.info(f'Navigated back to job listings after processing {job_title}')\r\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        log_available_buttons(job_card, job_title)\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n     except Exception as e:\r\n         logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n     finally:\r\n         if len(driver.window_handles) > 1:\r\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n \r\n+def click_next_button():\r\n+    \"\"\"\r\n+    Waits for the 'Next' button to appear after the apply modal is displayed and clicks it.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 30)  # Increased timeout for dynamic content\r\n+\r\n+        logging.info('Waiting for \"Next\" button to be clickable.')\r\n+        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n+        \r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        try:\r\n+            next_button.click()  # Attempt to click the button normally\r\n+            logging.info('\"Next\" button clicked.')\r\n+        except Exception as e:\r\n+            logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", next_button)\r\n+            logging.info('\"Next\" button clicked using JavaScript.')\r\n+\r\n+    except TimeoutException:\r\n+        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n+        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n+    except Exception as e:\r\n+        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n+        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n+\r\n+# Main Function\r\n def main():\r\n-    applied_jobs = set()\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n     try:\r\n         logging.info('Navigating to Dice homepage.')\r\n         driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n         search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n         search_field.clear()\r\n         search_field.send_keys(SEARCH_TERMS)\r\n         logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n \r\n+        logging.info('Locating search button.')\r\n         search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n         search_button.click()\r\n         logging.info('Clicked search button.')\r\n \r\n+        # Activate the \"Easy Apply\" filter\r\n         activate_easy_apply_filter()\r\n-        time.sleep(3)\r\n \r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n         job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n         logging.info(f'Found {len(job_cards)} job postings.')\r\n \r\n         for index, job_card in enumerate(job_cards, start=1):\r\n             try:\r\n+                # Extract the job title using data-cy attribute\r\n                 logging.info(f'Processing job {index}.')\r\n                 title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n                 job_title = title_element.text.strip()\r\n                 logging.info(f'Job {index}: Found title: {job_title}')\r\n+\r\n             except NoSuchElementException:\r\n                 logging.warning(f'Job {index}: Title element not found.')\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n                 capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n                 continue\r\n \r\n             if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n"
                },
                {
                    "date": 1726949019657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,688 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('--disable-extensions')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to create directory {path}: {e}')\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info('Navigating to Dice login page.')\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        logging.info('Waiting for email field.')\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        logging.info('Locating \"Continue\" button.')\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        logging.info('Waiting for password field.')\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        logging.info('Locating \"Sign In\" button.')\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        logging.info('Waiting for dashboard to load.')\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+        # Save cookies after successful login\r\n+        cookies = driver.get_cookies()\r\n+        logging.info(f\"Saved cookies after login: {cookies}\")\r\n+\r\n+        # Reapply cookies if needed\r\n+        for cookie in cookies:\r\n+            driver.add_cookie(cookie)\r\n+        logging.info(\"Reapplied cookies to maintain session.\")\r\n+\r\n+        # Verify session persistence by checking if we're still on the dashboard\r\n+        driver.get('https://www.dice.com/dashboard')\r\n+        logging.info(\"Verified session persistence by navigating to the dashboard again.\")\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+\r\n+def handle_login_modal():\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)\r\n+        logging.info(\"Checking if login modal is present.\")\r\n+        print(\"Checking if login modal is present.\")  # Debugging print\r\n+\r\n+        # Wait for the modal dialog itself to appear\r\n+        modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n+        logging.info(\"Modal dialog detected.\")\r\n+        print(\"Modal dialog detected.\")  # Debugging print\r\n+\r\n+        # Add a short sleep to ensure modal is fully loaded\r\n+        time.sleep(1)\r\n+\r\n+        # Ensure the email field is visible and ready for interaction\r\n+        email_field = wait.until(EC.element_to_be_clickable((By.ID, 'username')))\r\n+        logging.info(\"Email field detected and clickable.\")\r\n+        print(\"Email field detected and clickable.\")  # Debugging print\r\n+\r\n+        # Focus on the email field using ActionChains\r\n+        ActionChains(driver).move_to_element(email_field).click().perform()\r\n+        logging.info(\"Focused on email field.\")\r\n+        print(\"Focused on email field.\")  # Debugging print\r\n+\r\n+        # Clear any pre-existing text and send the email keys\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        time.sleep(1)  # Short pause to ensure the text is entered\r\n+        logging.info(\"Entered email in modal.\")\r\n+        print(\"Entered email in modal.\")  # Debugging print\r\n+\r\n+        # Ensure the password field is visible and ready for interaction\r\n+        password_field = wait.until(EC.element_to_be_clickable((By.ID, 'password')))\r\n+        logging.info(\"Password field detected and clickable.\")\r\n+        print(\"Password field detected and clickable.\")  # Debugging print\r\n+\r\n+        # Focus on the password field using ActionChains\r\n+        ActionChains(driver).move_to_element(password_field).click().perform()\r\n+        logging.info(\"Focused on password field.\")\r\n+        print(\"Focused on password field.\")  # Debugging print\r\n+\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info(\"Entered password in modal.\")\r\n+        print(\"Entered password in modal.\")  # Debugging print\r\n+\r\n+        # Ensure the \"Log in\" button is visible and clickable\r\n+        login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'login-dhi-button button')))\r\n+        logging.info(\"Log in button detected and clickable.\")\r\n+        print(\"Log in button detected and clickable.\")  # Debugging print\r\n+\r\n+        # Click the login button using JavaScript to ensure it is clicked\r\n+        driver.execute_script(\"arguments[0].click();\", login_button)\r\n+        logging.info(\"Clicked 'Log in' button in modal.\")\r\n+        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n+\r\n+        # Wait for the modal to disappear (indicating a successful login)\r\n+        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n+        logging.info(\"Successfully logged in via modal.\")\r\n+        print(\"Successfully logged in via modal.\")  # Debugging print\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(\"Login modal did not appear as expected.\")\r\n+        print(\"Login modal did not appear as expected.\")  # Debugging print\r\n+        capture_screenshot('login_modal_missing', subfolder='login')\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"Error finding login modal elements: {e}\")\r\n+        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        logging.info('Waiting for filters widget.')\r\n+        print('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" accordion.')\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" filter button.')\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(driver):\r\n+    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n+    logging.info(\"Attempting to locate the shadow host element.\")\r\n+    try:\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n+        print(\"Shadow host element found\")  # Debugging print\r\n+\r\n+        logging.info(\"Accessing the shadow root.\")\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n+        print(\"Shadow root accessed\")  # Debugging print\r\n+\r\n+        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n+        print(\"Easy Apply button found\")  # Debugging print\r\n+\r\n+        # Scroll the button into view before clicking\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button using JavaScript\r\n+        try:\r\n+            apply_now_button.click()  # Attempt to click the button\r\n+            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n+            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n+        except Exception as e:\r\n+            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n+\r\n+        return True\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        print(\"NoSuchElementException caught\")  # Debugging print\r\n+        return False\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        print(\"Unexpected exception caught\")  # Debugging print\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            logging.info(f'Attempting to click on job title: {job_title}')\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        logging.info(f'Waiting for job details to load for: {job_title}')\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Call handle_login_modal right after the apply button is clicked\r\n+        handle_login_modal()\r\n+\r\n+        # Continue with the application process...\r\n+        # Wait for the apply modal to appear\r\n+        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n+        print(f'Waiting for apply modal for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the resume upload field to be present within the modal\r\n+        logging.info(f'Locating resume upload field for job: {job_title}')\r\n+        print(f'Locating resume upload field for job: {job_title}')\r\n+        try:\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Resume upload field not found for job: {job_title}')\r\n+            print(f'Resume upload field not found for job: {job_title}')\r\n+            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n+        print(f'Locating \"Submit\" button for job: {job_title}')\r\n+        try:\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+        except TimeoutException:\r\n+            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+   \r\n+\r\n+    try:\r\n+        logging.info('Navigating to Dice homepage.')\r\n+        print('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n+        print('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        logging.info('Locating search button.')\r\n+        print('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n+        print('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                logging.info(f'Processing job {index}.')\r\n+                print(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726949324711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -192,10 +192,10 @@\n         print(\"Checking if login modal is present.\")  # Debugging print\r\n \r\n         # Wait for the modal dialog itself to appear\r\n         modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Modal dialog detected.\")\r\n-        print(\"Modal dialog detected.\")  # Debugging print\r\n+        logging.info(\"Modal dialog detected.\", modal_dialog)\r\n+        print(\"Modal dialog detected.\", modal_dialog)  # Debugging print\r\n \r\n         # Add a short sleep to ensure modal is fully loaded\r\n         time.sleep(1)\r\n \r\n@@ -685,452 +685,4 @@\n # -----------------------------\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-console_handler = logging.StreamHandler()\r\n-console_handler.setLevel(logging.DEBUG)\r\n-console_handler.setFormatter(logging.Formatter('%(asctime)s:%(levelname)s:%(message)s'))\r\n-logging.getLogger().addHandler(console_handler)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n-chrome_options.add_argument('--disable-extensions')\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-    logging.info(\"Initialized Chrome WebDriver.\")\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-logging.info(\"Maximized browser window.\")\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-        logging.info(f\"Created directory at path: {path}\")\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.info(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        logging.info('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(driver):\r\n-    logging.info(\"Entering `has_apply_now` function.\")\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        logging.info(\"Shadow host element found.\")\r\n-\r\n-        # Access the shadow root\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        logging.info(\"Shadow root accessed.\")\r\n-\r\n-        # Locate the 'Easy Apply' button within the shadow root\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        logging.info(\"Found the 'Easy Apply' button.\")\r\n-\r\n-        # Scroll the button into view before clicking\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button using JavaScript\r\n-        try:\r\n-            apply_now_button.click()  # Attempt to click the button\r\n-            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n-        except Exception as e:\r\n-            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n-\r\n-        return True\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        capture_screenshot('easy_apply_not_found', subfolder='easy_apply_missing')\r\n-        return False\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n-        capture_screenshot('unexpected_error', subfolder='easy_apply_missing')\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 30)  # Increased timeout to handle new tab loading\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-        \r\n-        title_element.click()\r\n-        logging.info(f'Clicked on job title: {job_title}')\r\n-\r\n-        # Handle the new window or tab\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-\r\n-        # Wait for the job details page to load\r\n-        logging.info(f'Waiting for job details page to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-\r\n-        # Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Click the \"Apply Now\" button\r\n-        logging.info(f'Clicking \"Apply Now\" button for job: {job_title}')\r\n-        apply_now_button = driver.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        apply_now_button.click()\r\n-\r\n-        # Wait for the login modal to appear and stay visible\r\n-        logging.info('Waiting for login modal to appear.')\r\n-        login_modal = wait.until(EC.visibility_of_element_located((By.XPATH, '//div[contains(@class, \"login-modal\")]')))\r\n-\r\n-        # Log in manually, as requested by the user\r\n-        logging.info('Login modal found. Please log in manually.')\r\n-        while True:\r\n-            if driver.current_url.startswith(\"https://www.dice.com/apply\"):\r\n-                logging.info(\"Login successful, URL has changed.\")\r\n-                break\r\n-            time.sleep(1)\r\n-\r\n-        # Wait for the \"Next\" button to appear and click it\r\n-        logging.info(f'Waiting for \"Next\" button to be clickable on the application form page.')\r\n-        click_next_button()\r\n-\r\n-        logging.info(f'Successfully applied to {job_title}')\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def click_next_button():\r\n-    \"\"\"\r\n-    Waits for the 'Next' button to appear after the apply modal is displayed and clicks it.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 30)  # Increased timeout for dynamic content\r\n-\r\n-        logging.info('Waiting for \"Next\" button to be clickable.')\r\n-        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n-        \r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", next_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        try:\r\n-            next_button.click()  # Attempt to click the button normally\r\n-            logging.info('\"Next\" button clicked.')\r\n-        except Exception as e:\r\n-            logging.warning(f'Normal click failed: {e}, trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", next_button)\r\n-            logging.info('\"Next\" button clicked using JavaScript.')\r\n-\r\n-    except TimeoutException:\r\n-        logging.error('Timeout: \"Next\" button did not become clickable.')\r\n-        capture_screenshot('next_button_not_clickable', subfolder='application_errors')\r\n-    except Exception as e:\r\n-        logging.error(f'An unexpected error occurred when clicking \"Next\" button: {e}')\r\n-        capture_screenshot('unexpected_error_clicking_next_button', subfolder='application_errors')\r\n-\r\n-# Main Function\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    try:\r\n-        logging.info('Navigating to Dice homepage.')\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        logging.info('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                logging.info(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n"
                },
                {
                    "date": 1726949668287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -193,9 +193,10 @@\n \r\n         # Wait for the modal dialog itself to appear\r\n         modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n         logging.info(\"Modal dialog detected.\", modal_dialog)\r\n-        print(\"Modal dialog detected.\", modal_dialog)  # Debugging print\r\n+        print(f\"Modal dialog detected: {modal_dialog}\")\r\n+  # Debugging print\r\n \r\n         # Add a short sleep to ensure modal is fully loaded\r\n         time.sleep(1)\r\n \r\n"
                },
                {
                    "date": 1726949682591,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -192,11 +192,11 @@\n         print(\"Checking if login modal is present.\")  # Debugging print\r\n \r\n         # Wait for the modal dialog itself to appear\r\n         modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Modal dialog detected.\", modal_dialog)\r\n+        logging.info(\"Modal dialog detected.\")\r\n         print(f\"Modal dialog detected: {modal_dialog}\")\r\n-  # Debugging print\r\n+      # Debugging print\r\n \r\n         # Add a short sleep to ensure modal is fully loaded\r\n         time.sleep(1)\r\n \r\n"
                },
                {
                    "date": 1726950111744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -181,14 +181,83 @@\n         driver.quit()\r\n         exit(1)\r\n \r\n \r\n+def find_element_by_css_selector_through_shadow_dom(driver, selectors):\r\n+    \"\"\"\r\n+    Navigates through nested shadow DOMs to find the desired element.\r\n+    :param driver: The WebDriver instance.\r\n+    :param selectors: A list of CSS selectors, each representing a level in the shadow DOM.\r\n+    :return: The desired WebElement.\r\n+    \"\"\"\r\n+    element = driver\r\n+    for selector in selectors:\r\n+        # Use JavaScript to navigate through shadow roots\r\n+        element = driver.execute_script('''\r\n+            return (arguments[0].shadowRoot || arguments[0]).querySelector(arguments[1])\r\n+            ''', element, selector)\r\n+        if element is None:\r\n+            raise Exception(f'Element not found for selector: {selector}')\r\n+    return element\r\n+\r\n def handle_login_modal():\r\n     \"\"\"\r\n     Handles the login modal that appears after clicking \"Apply now\".\r\n     \"\"\"\r\n     try:\r\n+        logging.info(\"Checking if login modal is present.\")\r\n+        print(\"Checking if login modal is present.\")  # Debugging print\r\n+\r\n+        # Define the selectors to navigate through the nested shadow DOMs\r\n+        email_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#username']\r\n+        password_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#password']\r\n+        login_button_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', 'login-dhi-button[data-cy=\"login-submit\"] button']\r\n+\r\n+        # Use the helper function to find the elements\r\n+        email_field = find_element_by_css_selector_through_shadow_dom(driver, email_field_selectors)\r\n+        logging.info(\"Email field detected.\")\r\n+        print(\"Email field detected.\")  # Debugging print\r\n+\r\n+        password_field = find_element_by_css_selector_through_shadow_dom(driver, password_field_selectors)\r\n+        logging.info(\"Password field detected.\")\r\n+        print(\"Password field detected.\")  # Debugging print\r\n+\r\n+        login_button = find_element_by_css_selector_through_shadow_dom(driver, login_button_selectors)\r\n+        logging.info(\"Login button detected.\")\r\n+        print(\"Login button detected.\")  # Debugging print\r\n+\r\n+        # Interact with the elements\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info(\"Entered email in modal.\")\r\n+        print(\"Entered email in modal.\")  # Debugging print\r\n+\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info(\"Entered password in modal.\")\r\n+        print(\"Entered password in modal.\")  # Debugging print\r\n+\r\n+        # Click the login button using JavaScript to ensure it is clicked\r\n+        driver.execute_script(\"arguments[0].click();\", login_button)\r\n+        logging.info(\"Clicked 'Log in' button in modal.\")\r\n+        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n+\r\n+        # Wait for the modal to disappear (indicating a successful login)\r\n         wait = WebDriverWait(driver, 20)\r\n+        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n+        logging.info(\"Successfully logged in via modal.\")\r\n+        print(\"Successfully logged in via modal.\")  # Debugging print\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n+\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)\r\n         logging.info(\"Checking if login modal is present.\")\r\n         print(\"Checking if login modal is present.\")  # Debugging print\r\n \r\n         # Wait for the modal dialog itself to appear\r\n"
                },
                {
                    "date": 1726950526480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -188,18 +188,20 @@\n     :param driver: The WebDriver instance.\r\n     :param selectors: A list of CSS selectors, each representing a level in the shadow DOM.\r\n     :return: The desired WebElement.\r\n     \"\"\"\r\n-    element = driver\r\n-    for selector in selectors:\r\n+    # Start by finding the first element in the DOM\r\n+    element = driver.find_element(By.CSS_SELECTOR, selectors[0])\r\n+    for selector in selectors[1:]:\r\n         # Use JavaScript to navigate through shadow roots\r\n         element = driver.execute_script('''\r\n-            return (arguments[0].shadowRoot || arguments[0]).querySelector(arguments[1])\r\n+            return arguments[0].shadowRoot.querySelector(arguments[1])\r\n             ''', element, selector)\r\n         if element is None:\r\n             raise Exception(f'Element not found for selector: {selector}')\r\n     return element\r\n \r\n+\r\n def handle_login_modal():\r\n     \"\"\"\r\n     Handles the login modal that appears after clicking \"Apply now\".\r\n     \"\"\"\r\n@@ -255,9 +257,61 @@\n     \"\"\"\r\n     Handles the login modal that appears after clicking \"Apply now\".\r\n     \"\"\"\r\n     try:\r\n+        logging.info(\"Checking if login modal is present.\")\r\n+        print(\"Checking if login modal is present.\")  # Debugging print\r\n+\r\n+        # Define the selectors to navigate through the nested shadow DOMs\r\n+        email_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#username']\r\n+        password_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#password']\r\n+        login_button_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', 'login-dhi-button[data-cy=\"login-submit\"] button']\r\n+\r\n+        # Use the helper function to find the elements\r\n+        email_field = find_element_by_css_selector_through_shadow_dom(driver, email_field_selectors)\r\n+        logging.info(\"Email field detected.\")\r\n+        print(\"Email field detected.\")  # Debugging print\r\n+\r\n+        password_field = find_element_by_css_selector_through_shadow_dom(driver, password_field_selectors)\r\n+        logging.info(\"Password field detected.\")\r\n+        print(\"Password field detected.\")  # Debugging print\r\n+\r\n+        login_button = find_element_by_css_selector_through_shadow_dom(driver, login_button_selectors)\r\n+        logging.info(\"Login button detected.\")\r\n+        print(\"Login button detected.\")  # Debugging print\r\n+\r\n+        # Interact with the elements\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info(\"Entered email in modal.\")\r\n+        print(\"Entered email in modal.\")  # Debugging print\r\n+\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info(\"Entered password in modal.\")\r\n+        print(\"Entered password in modal.\")  # Debugging print\r\n+\r\n+        # Click the login button using JavaScript to ensure it is clicked\r\n+        driver.execute_script(\"arguments[0].click();\", login_button)\r\n+        logging.info(\"Clicked 'Log in' button in modal.\")\r\n+        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n+\r\n+        # Wait for the modal to disappear (indicating a successful login)\r\n         wait = WebDriverWait(driver, 20)\r\n+        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n+        logging.info(\"Successfully logged in via modal.\")\r\n+        print(\"Successfully logged in via modal.\")  # Debugging print\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n+\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)\r\n         logging.info(\"Checking if login modal is present.\")\r\n         print(\"Checking if login modal is present.\")  # Debugging print\r\n \r\n         # Wait for the modal dialog itself to appear\r\n"
                },
                {
                    "date": 1726950790133,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,874 @@\n+import configparser\r\n+import logging\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Configure logging\r\n+logging.basicConfig(\r\n+    filename='application_log.txt',\r\n+    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n+    format='%(asctime)s:%(levelname)s:%(message)s'\r\n+)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('--disable-extensions')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n+except WebDriverException as e:\r\n+    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to create directory {path}: {e}')\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info('Navigating to Dice login page.')\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        logging.info('Waiting for email field.')\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info('Entered email.')\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        logging.info('Locating \"Continue\" button.')\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        logging.info('Clicked \"Continue\" button.')\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        logging.info('Waiting for password field.')\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info('Entered password.')\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        logging.info('Locating \"Sign In\" button.')\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        logging.info('Clicked \"Sign In\" button.')\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        logging.info('Waiting for dashboard to load.')\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        logging.info('Successfully logged into Dice.')\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+        # Save cookies after successful login\r\n+        cookies = driver.get_cookies()\r\n+        logging.info(f\"Saved cookies after login: {cookies}\")\r\n+\r\n+        # Reapply cookies if needed\r\n+        for cookie in cookies:\r\n+            driver.add_cookie(cookie)\r\n+        logging.info(\"Reapplied cookies to maintain session.\")\r\n+\r\n+        # Verify session persistence by checking if we're still on the dashboard\r\n+        driver.get('https://www.dice.com/dashboard')\r\n+        logging.info(\"Verified session persistence by navigating to the dashboard again.\")\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error during login: {e}')\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+\r\n+def find_element_by_css_selector_through_shadow_dom(driver, selectors):\r\n+    \"\"\"\r\n+    Navigates through nested shadow DOMs to find the desired element.\r\n+    :param driver: The WebDriver instance.\r\n+    :param selectors: A list of CSS selectors, each representing a level in the shadow DOM.\r\n+    :return: The desired WebElement.\r\n+    \"\"\"\r\n+    # Start by finding the first element in the DOM\r\n+    element = driver.find_element(By.CSS_SELECTOR, selectors[0])\r\n+    for selector in selectors[1:]:\r\n+        # Use JavaScript to navigate through shadow roots\r\n+        element = driver.execute_script('''\r\n+            return arguments[0].shadowRoot.querySelector(arguments[1])\r\n+            ''', element, selector)\r\n+        if element is None:\r\n+            raise Exception(f'Element not found for selector: {selector}')\r\n+    return element\r\n+\r\n+\r\n+def handle_login_modal():\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)\r\n+        logging.info(\"Checking if login modal is present.\")\r\n+        print(\"Checking if login modal is present.\")\r\n+\r\n+        # Wait for the modal dialog to be present\r\n+        modal_dialog = wait.until(EC.presence_of_element_located((By.XPATH, '//dialog')))\r\n+        logging.info(\"Modal dialog detected.\")\r\n+        print(f\"Modal dialog detected: {modal_dialog}\")\r\n+\r\n+        # Use the modal_dialog as the context for finding elements\r\n+        # Locate the email field within the dialog\r\n+        email_field = modal_dialog.find_element(By.ID, 'username')\r\n+        logging.info(\"Email field detected.\")\r\n+        print(\"Email field detected.\")\r\n+\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info(\"Entered email in modal.\")\r\n+        print(\"Entered email in modal.\")\r\n+\r\n+        # Locate the password field within the dialog\r\n+        password_field = modal_dialog.find_element(By.ID, 'password')\r\n+        logging.info(\"Password field detected.\")\r\n+        print(\"Password field detected.\")\r\n+\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info(\"Entered password in modal.\")\r\n+        print(\"Entered password in modal.\")\r\n+\r\n+        # Locate the login button within the dialog\r\n+        login_button = modal_dialog.find_element(By.XPATH, './/login-dhi-button[@data-cy=\"login-submit\"]//button')\r\n+        logging.info(\"Log in button detected.\")\r\n+        print(\"Log in button detected.\")\r\n+\r\n+        # Click the login button\r\n+        login_button.click()\r\n+        logging.info(\"Clicked 'Log in' button in modal.\")\r\n+        print(\"Clicked 'Log in' button in modal.\")\r\n+\r\n+        # Wait for the modal to disappear (indicating successful login)\r\n+        wait.until(EC.invisibility_of_element_located((By.XPATH, '//dialog')))\r\n+        logging.info(\"Successfully logged in via modal.\")\r\n+        print(\"Successfully logged in via modal.\")\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(\"Login modal did not appear as expected.\")\r\n+        print(\"Login modal did not appear as expected.\")\r\n+        capture_screenshot('login_modal_missing', subfolder='login')\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"Error finding login modal elements: {e}\")\r\n+        print(f\"Error finding login modal elements: {e}\")\r\n+        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Checking if login modal is present.\")\r\n+        print(\"Checking if login modal is present.\")  # Debugging print\r\n+\r\n+        # Define the selectors to navigate through the nested shadow DOMs\r\n+        email_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#username']\r\n+        password_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#password']\r\n+        login_button_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', 'login-dhi-button[data-cy=\"login-submit\"] button']\r\n+\r\n+        # Use the helper function to find the elements\r\n+        email_field = find_element_by_css_selector_through_shadow_dom(driver, email_field_selectors)\r\n+        logging.info(\"Email field detected.\")\r\n+        print(\"Email field detected.\")  # Debugging print\r\n+\r\n+        password_field = find_element_by_css_selector_through_shadow_dom(driver, password_field_selectors)\r\n+        logging.info(\"Password field detected.\")\r\n+        print(\"Password field detected.\")  # Debugging print\r\n+\r\n+        login_button = find_element_by_css_selector_through_shadow_dom(driver, login_button_selectors)\r\n+        logging.info(\"Login button detected.\")\r\n+        print(\"Login button detected.\")  # Debugging print\r\n+\r\n+        # Interact with the elements\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info(\"Entered email in modal.\")\r\n+        print(\"Entered email in modal.\")  # Debugging print\r\n+\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info(\"Entered password in modal.\")\r\n+        print(\"Entered password in modal.\")  # Debugging print\r\n+\r\n+        # Click the login button using JavaScript to ensure it is clicked\r\n+        driver.execute_script(\"arguments[0].click();\", login_button)\r\n+        logging.info(\"Clicked 'Log in' button in modal.\")\r\n+        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n+\r\n+        # Wait for the modal to disappear (indicating a successful login)\r\n+        wait = WebDriverWait(driver, 20)\r\n+        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n+        logging.info(\"Successfully logged in via modal.\")\r\n+        print(\"Successfully logged in via modal.\")  # Debugging print\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n+\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Checking if login modal is present.\")\r\n+        print(\"Checking if login modal is present.\")  # Debugging print\r\n+\r\n+        # Define the selectors to navigate through the nested shadow DOMs\r\n+        email_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#username']\r\n+        password_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#password']\r\n+        login_button_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', 'login-dhi-button[data-cy=\"login-submit\"] button']\r\n+\r\n+        # Use the helper function to find the elements\r\n+        email_field = find_element_by_css_selector_through_shadow_dom(driver, email_field_selectors)\r\n+        logging.info(\"Email field detected.\")\r\n+        print(\"Email field detected.\")  # Debugging print\r\n+\r\n+        password_field = find_element_by_css_selector_through_shadow_dom(driver, password_field_selectors)\r\n+        logging.info(\"Password field detected.\")\r\n+        print(\"Password field detected.\")  # Debugging print\r\n+\r\n+        login_button = find_element_by_css_selector_through_shadow_dom(driver, login_button_selectors)\r\n+        logging.info(\"Login button detected.\")\r\n+        print(\"Login button detected.\")  # Debugging print\r\n+\r\n+        # Interact with the elements\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        logging.info(\"Entered email in modal.\")\r\n+        print(\"Entered email in modal.\")  # Debugging print\r\n+\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info(\"Entered password in modal.\")\r\n+        print(\"Entered password in modal.\")  # Debugging print\r\n+\r\n+        # Click the login button using JavaScript to ensure it is clicked\r\n+        driver.execute_script(\"arguments[0].click();\", login_button)\r\n+        logging.info(\"Clicked 'Log in' button in modal.\")\r\n+        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n+\r\n+        # Wait for the modal to disappear (indicating a successful login)\r\n+        wait = WebDriverWait(driver, 20)\r\n+        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n+        logging.info(\"Successfully logged in via modal.\")\r\n+        print(\"Successfully logged in via modal.\")  # Debugging print\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n+\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)\r\n+        logging.info(\"Checking if login modal is present.\")\r\n+        print(\"Checking if login modal is present.\")  # Debugging print\r\n+\r\n+        # Wait for the modal dialog itself to appear\r\n+        modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n+        logging.info(\"Modal dialog detected.\")\r\n+        print(f\"Modal dialog detected: {modal_dialog}\")\r\n+      # Debugging print\r\n+\r\n+        # Add a short sleep to ensure modal is fully loaded\r\n+        time.sleep(1)\r\n+\r\n+        # Ensure the email field is visible and ready for interaction\r\n+        email_field = wait.until(EC.element_to_be_clickable((By.ID, 'username')))\r\n+        logging.info(\"Email field detected and clickable.\")\r\n+        print(\"Email field detected and clickable.\")  # Debugging print\r\n+\r\n+        # Focus on the email field using ActionChains\r\n+        ActionChains(driver).move_to_element(email_field).click().perform()\r\n+        logging.info(\"Focused on email field.\")\r\n+        print(\"Focused on email field.\")  # Debugging print\r\n+\r\n+        # Clear any pre-existing text and send the email keys\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        time.sleep(1)  # Short pause to ensure the text is entered\r\n+        logging.info(\"Entered email in modal.\")\r\n+        print(\"Entered email in modal.\")  # Debugging print\r\n+\r\n+        # Ensure the password field is visible and ready for interaction\r\n+        password_field = wait.until(EC.element_to_be_clickable((By.ID, 'password')))\r\n+        logging.info(\"Password field detected and clickable.\")\r\n+        print(\"Password field detected and clickable.\")  # Debugging print\r\n+\r\n+        # Focus on the password field using ActionChains\r\n+        ActionChains(driver).move_to_element(password_field).click().perform()\r\n+        logging.info(\"Focused on password field.\")\r\n+        print(\"Focused on password field.\")  # Debugging print\r\n+\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        logging.info(\"Entered password in modal.\")\r\n+        print(\"Entered password in modal.\")  # Debugging print\r\n+\r\n+        # Ensure the \"Log in\" button is visible and clickable\r\n+        login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'login-dhi-button button')))\r\n+        logging.info(\"Log in button detected and clickable.\")\r\n+        print(\"Log in button detected and clickable.\")  # Debugging print\r\n+\r\n+        # Click the login button using JavaScript to ensure it is clicked\r\n+        driver.execute_script(\"arguments[0].click();\", login_button)\r\n+        logging.info(\"Clicked 'Log in' button in modal.\")\r\n+        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n+\r\n+        # Wait for the modal to disappear (indicating a successful login)\r\n+        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n+        logging.info(\"Successfully logged in via modal.\")\r\n+        print(\"Successfully logged in via modal.\")  # Debugging print\r\n+\r\n+    except TimeoutException:\r\n+        logging.error(\"Login modal did not appear as expected.\")\r\n+        print(\"Login modal did not appear as expected.\")  # Debugging print\r\n+        capture_screenshot('login_modal_missing', subfolder='login')\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"Error finding login modal elements: {e}\")\r\n+        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        logging.info('Waiting for filters widget.')\r\n+        print('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        logging.info('Filters widget located.')\r\n+        print('Filters widget located.')\r\n+\r\n+        # For debugging: log the inner HTML of the filters_widget\r\n+        filters_html = filters_widget.get_attribute('innerHTML')\r\n+        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n+        print('Logged filters widget inner HTML for debugging.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" accordion.')\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            logging.info('\"Easy Apply\" accordion located.')\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            logging.info('Locating \"Easy Apply\" filter button.')\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            logging.info('\"Easy Apply\" filter button located.')\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            logging.info('\"Easy Apply\" filter is already active.')\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            logging.info('\"Easy Apply\" filter activated.')\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            logging.info('Navigated to filtered URL.')\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            logging.info('URL contains the expected filter parameters.')\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(driver):\r\n+    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n+    logging.info(\"Attempting to locate the shadow host element.\")\r\n+    try:\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n+        print(\"Shadow host element found\")  # Debugging print\r\n+\r\n+        logging.info(\"Accessing the shadow root.\")\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n+        print(\"Shadow root accessed\")  # Debugging print\r\n+\r\n+        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n+        print(\"Easy Apply button found\")  # Debugging print\r\n+\r\n+        # Scroll the button into view before clicking\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button using JavaScript\r\n+        try:\r\n+            apply_now_button.click()  # Attempt to click the button\r\n+            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n+            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n+        except Exception as e:\r\n+            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n+\r\n+        return True\r\n+    except NoSuchElementException as e:\r\n+        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        print(\"NoSuchElementException caught\")  # Debugging print\r\n+        return False\r\n+    except Exception as e:\r\n+        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        print(\"Unexpected exception caught\")  # Debugging print\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            logging.info(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        logging.info(f'Scrolling into view for job: {job_title}')\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        logging.info(f'Locating job title link for: {job_title}')\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            logging.info(f'Attempting to click on job title: {job_title}')\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            logging.info(f'Clicked on job title: {job_title}')\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            logging.info(f'Switched to new window for job: {job_title}')\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        logging.info(f'Waiting for job details to load for: {job_title}')\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        logging.debug(f'Job details loaded for: {job_title}')\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n+            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Call handle_login_modal right after the apply button is clicked\r\n+        handle_login_modal()\r\n+\r\n+        # Continue with the application process...\r\n+        # Wait for the apply modal to appear\r\n+        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n+        print(f'Waiting for apply modal for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the resume upload field to be present within the modal\r\n+        logging.info(f'Locating resume upload field for job: {job_title}')\r\n+        print(f'Locating resume upload field for job: {job_title}')\r\n+        try:\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            logging.info(f'Uploaded resume for job: {job_title}')\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+        except TimeoutException:\r\n+            logging.error(f'Resume upload field not found for job: {job_title}')\r\n+            print(f'Resume upload field not found for job: {job_title}')\r\n+            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n+        print(f'Locating \"Submit\" button for job: {job_title}')\r\n+        try:\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            logging.info(f'Successfully applied to {job_title}')\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+        except TimeoutException:\r\n+            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+   \r\n+\r\n+    try:\r\n+        logging.info('Navigating to Dice homepage.')\r\n+        print('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        logging.info('Waiting for search field.')\r\n+        print('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        logging.info('Locating search button.')\r\n+        print('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        logging.info('Clicked search button.')\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        logging.info('Locating job cards.')\r\n+        print('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        logging.info(f'Found {len(job_cards)} job postings.')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                logging.info(f'Processing job {index}.')\r\n+                print(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                logging.info(f'Job {index}: Found title: {job_title}')\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                logging.warning(f'Job {index}: Title element not found.')\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            # Debugging: Log job titles\r\n+            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+        logging.info(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        logging.error(f'An error occurred in main(): {e}')\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726951059130,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,562 @@\n+import configparser\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('--disable-extensions')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Add options to use existing Chrome profile\r\n+# Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n+chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\YourUserName\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n+chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n+except WebDriverException as e:\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n+    except Exception as e:\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+        # Save cookies after successful login\r\n+        cookies = driver.get_cookies()\r\n+\r\n+        # Reapply cookies if needed\r\n+        for cookie in cookies:\r\n+            driver.add_cookie(cookie)\r\n+\r\n+        # Verify session persistence by checking if we're still on the dashboard\r\n+        driver.get('https://www.dice.com/dashboard')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def handle_login_modal():\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)\r\n+        print(\"Checking if login modal is present.\")\r\n+\r\n+        # Wait for the modal dialog to be present\r\n+        modal_dialog = wait.until(EC.presence_of_element_located((By.XPATH, '//dialog')))\r\n+        print(f\"Modal dialog detected: {modal_dialog}\")\r\n+\r\n+        # Use the modal_dialog as the context for finding elements\r\n+        # Locate the email field within the dialog\r\n+        email_field = modal_dialog.find_element(By.ID, 'username')\r\n+        print(\"Email field detected.\")\r\n+\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        print(\"Entered email in modal.\")\r\n+\r\n+        # Locate the password field within the dialog\r\n+        password_field = modal_dialog.find_element(By.ID, 'password')\r\n+        print(\"Password field detected.\")\r\n+\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        print(\"Entered password in modal.\")\r\n+\r\n+        # Locate the login button within the dialog\r\n+        login_button = modal_dialog.find_element(By.XPATH, './/login-dhi-button[@data-cy=\"login-submit\"]//button')\r\n+        print(\"Log in button detected.\")\r\n+\r\n+        # Click the login button\r\n+        login_button.click()\r\n+        print(\"Clicked 'Log in' button in modal.\")\r\n+\r\n+        # Wait for the modal to disappear (indicating successful login)\r\n+        wait.until(EC.invisibility_of_element_located((By.XPATH, '//dialog')))\r\n+        print(\"Successfully logged in via modal.\")\r\n+\r\n+    except TimeoutException:\r\n+        print(\"Login modal did not appear as expected.\")\r\n+        capture_screenshot('login_modal_missing', subfolder='login')\r\n+    except NoSuchElementException as e:\r\n+        print(f\"Error finding login modal elements: {e}\")\r\n+        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n+    except Exception as e:\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        print('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        print('Filters widget located.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(driver):\r\n+    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n+    try:\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        print(\"Shadow host element found\")  # Debugging print\r\n+\r\n+        # Access the shadow root\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        print(\"Shadow root accessed\")  # Debugging print\r\n+\r\n+        # Locate the 'Easy Apply' button within the shadow root\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        print(\"Easy Apply button found\")  # Debugging print\r\n+\r\n+        # Scroll the button into view before clicking\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button\r\n+        try:\r\n+            apply_now_button.click()  # Attempt to click the button\r\n+            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n+        except Exception as e:\r\n+            print(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n+\r\n+        return True\r\n+    except NoSuchElementException as e:\r\n+        print(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        print(\"NoSuchElementException caught\")  # Debugging print\r\n+        return False\r\n+    except Exception as e:\r\n+        print(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        print(\"Unexpected exception caught\")  # Debugging print\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            print(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Call handle_login_modal right after the apply button is clicked\r\n+        handle_login_modal()\r\n+\r\n+        # Continue with the application process...\r\n+        # Wait for the apply modal to appear\r\n+        print(f'Waiting for apply modal for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the resume upload field to be present within the modal\r\n+        print(f'Locating resume upload field for job: {job_title}')\r\n+        try:\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+        except TimeoutException:\r\n+            print(f'Resume upload field not found for job: {job_title}')\r\n+            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        print(f'Locating \"Submit\" button for job: {job_title}')\r\n+        try:\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+        except TimeoutException:\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    try:\r\n+        print('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        print('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        print('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        print('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                print(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726951154821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n \r\n # Add options to use existing Chrome profile\r\n # Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\YourUserName\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n-chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n+chrome_options.add_argument(\"profile-directory=anon\")  # Or the name of your profile directory\r\n \r\n # Initialize the WebDriver\r\n try:\r\n     driver = webdriver.Chrome(options=chrome_options)\r\n@@ -559,1690 +559,4 @@\n # -----------------------------\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n-chrome_options.add_argument('--disable-extensions')\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-    print(\"Initialized Chrome WebDriver.\")\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-print(\"Maximized browser window.\")\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-        print(f\"Created directory at path: {path}\")\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to create directory {path}: {e}')\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info('Navigating to Dice login page.')\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        logging.info('Waiting for email field.')\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        logging.info('Locating \"Continue\" button.')\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        logging.info('Waiting for password field.')\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        logging.info('Locating \"Sign In\" button.')\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        logging.info('Waiting for dashboard to load.')\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-        # Save cookies after successful login\r\n-        cookies = driver.get_cookies()\r\n-        logging.info(f\"Saved cookies after login: {cookies}\")\r\n-\r\n-        # Reapply cookies if needed\r\n-        for cookie in cookies:\r\n-            driver.add_cookie(cookie)\r\n-        logging.info(\"Reapplied cookies to maintain session.\")\r\n-\r\n-        # Verify session persistence by checking if we're still on the dashboard\r\n-        driver.get('https://www.dice.com/dashboard')\r\n-        logging.info(\"Verified session persistence by navigating to the dashboard again.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-\r\n-def find_element_by_css_selector_through_shadow_dom(driver, selectors):\r\n-    \"\"\"\r\n-    Navigates through nested shadow DOMs to find the desired element.\r\n-    :param driver: The WebDriver instance.\r\n-    :param selectors: A list of CSS selectors, each representing a level in the shadow DOM.\r\n-    :return: The desired WebElement.\r\n-    \"\"\"\r\n-    # Start by finding the first element in the DOM\r\n-    element = driver.find_element(By.CSS_SELECTOR, selectors[0])\r\n-    for selector in selectors[1:]:\r\n-        # Use JavaScript to navigate through shadow roots\r\n-        element = driver.execute_script('''\r\n-            return arguments[0].shadowRoot.querySelector(arguments[1])\r\n-            ''', element, selector)\r\n-        if element is None:\r\n-            raise Exception(f'Element not found for selector: {selector}')\r\n-    return element\r\n-\r\n-\r\n-def handle_login_modal():\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)\r\n-        logging.info(\"Checking if login modal is present.\")\r\n-        print(\"Checking if login modal is present.\")\r\n-\r\n-        # Wait for the modal dialog to be present\r\n-        modal_dialog = wait.until(EC.presence_of_element_located((By.XPATH, '//dialog')))\r\n-        logging.info(\"Modal dialog detected.\")\r\n-        print(f\"Modal dialog detected: {modal_dialog}\")\r\n-\r\n-        # Use the modal_dialog as the context for finding elements\r\n-        # Locate the email field within the dialog\r\n-        email_field = modal_dialog.find_element(By.ID, 'username')\r\n-        logging.info(\"Email field detected.\")\r\n-        print(\"Email field detected.\")\r\n-\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info(\"Entered email in modal.\")\r\n-        print(\"Entered email in modal.\")\r\n-\r\n-        # Locate the password field within the dialog\r\n-        password_field = modal_dialog.find_element(By.ID, 'password')\r\n-        logging.info(\"Password field detected.\")\r\n-        print(\"Password field detected.\")\r\n-\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info(\"Entered password in modal.\")\r\n-        print(\"Entered password in modal.\")\r\n-\r\n-        # Locate the login button within the dialog\r\n-        login_button = modal_dialog.find_element(By.XPATH, './/login-dhi-button[@data-cy=\"login-submit\"]//button')\r\n-        logging.info(\"Log in button detected.\")\r\n-        print(\"Log in button detected.\")\r\n-\r\n-        # Click the login button\r\n-        login_button.click()\r\n-        logging.info(\"Clicked 'Log in' button in modal.\")\r\n-        print(\"Clicked 'Log in' button in modal.\")\r\n-\r\n-        # Wait for the modal to disappear (indicating successful login)\r\n-        wait.until(EC.invisibility_of_element_located((By.XPATH, '//dialog')))\r\n-        logging.info(\"Successfully logged in via modal.\")\r\n-        print(\"Successfully logged in via modal.\")\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(\"Login modal did not appear as expected.\")\r\n-        print(\"Login modal did not appear as expected.\")\r\n-        capture_screenshot('login_modal_missing', subfolder='login')\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"Error finding login modal elements: {e}\")\r\n-        print(f\"Error finding login modal elements: {e}\")\r\n-        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Checking if login modal is present.\")\r\n-        print(\"Checking if login modal is present.\")  # Debugging print\r\n-\r\n-        # Define the selectors to navigate through the nested shadow DOMs\r\n-        email_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#username']\r\n-        password_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#password']\r\n-        login_button_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', 'login-dhi-button[data-cy=\"login-submit\"] button']\r\n-\r\n-        # Use the helper function to find the elements\r\n-        email_field = find_element_by_css_selector_through_shadow_dom(driver, email_field_selectors)\r\n-        logging.info(\"Email field detected.\")\r\n-        print(\"Email field detected.\")  # Debugging print\r\n-\r\n-        password_field = find_element_by_css_selector_through_shadow_dom(driver, password_field_selectors)\r\n-        logging.info(\"Password field detected.\")\r\n-        print(\"Password field detected.\")  # Debugging print\r\n-\r\n-        login_button = find_element_by_css_selector_through_shadow_dom(driver, login_button_selectors)\r\n-        logging.info(\"Login button detected.\")\r\n-        print(\"Login button detected.\")  # Debugging print\r\n-\r\n-        # Interact with the elements\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info(\"Entered email in modal.\")\r\n-        print(\"Entered email in modal.\")  # Debugging print\r\n-\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info(\"Entered password in modal.\")\r\n-        print(\"Entered password in modal.\")  # Debugging print\r\n-\r\n-        # Click the login button using JavaScript to ensure it is clicked\r\n-        driver.execute_script(\"arguments[0].click();\", login_button)\r\n-        logging.info(\"Clicked 'Log in' button in modal.\")\r\n-        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n-\r\n-        # Wait for the modal to disappear (indicating a successful login)\r\n-        wait = WebDriverWait(driver, 20)\r\n-        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Successfully logged in via modal.\")\r\n-        print(\"Successfully logged in via modal.\")  # Debugging print\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n-\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Checking if login modal is present.\")\r\n-        print(\"Checking if login modal is present.\")  # Debugging print\r\n-\r\n-        # Define the selectors to navigate through the nested shadow DOMs\r\n-        email_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#username']\r\n-        password_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#password']\r\n-        login_button_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', 'login-dhi-button[data-cy=\"login-submit\"] button']\r\n-\r\n-        # Use the helper function to find the elements\r\n-        email_field = find_element_by_css_selector_through_shadow_dom(driver, email_field_selectors)\r\n-        logging.info(\"Email field detected.\")\r\n-        print(\"Email field detected.\")  # Debugging print\r\n-\r\n-        password_field = find_element_by_css_selector_through_shadow_dom(driver, password_field_selectors)\r\n-        logging.info(\"Password field detected.\")\r\n-        print(\"Password field detected.\")  # Debugging print\r\n-\r\n-        login_button = find_element_by_css_selector_through_shadow_dom(driver, login_button_selectors)\r\n-        logging.info(\"Login button detected.\")\r\n-        print(\"Login button detected.\")  # Debugging print\r\n-\r\n-        # Interact with the elements\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info(\"Entered email in modal.\")\r\n-        print(\"Entered email in modal.\")  # Debugging print\r\n-\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info(\"Entered password in modal.\")\r\n-        print(\"Entered password in modal.\")  # Debugging print\r\n-\r\n-        # Click the login button using JavaScript to ensure it is clicked\r\n-        driver.execute_script(\"arguments[0].click();\", login_button)\r\n-        logging.info(\"Clicked 'Log in' button in modal.\")\r\n-        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n-\r\n-        # Wait for the modal to disappear (indicating a successful login)\r\n-        wait = WebDriverWait(driver, 20)\r\n-        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Successfully logged in via modal.\")\r\n-        print(\"Successfully logged in via modal.\")  # Debugging print\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n-\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)\r\n-        logging.info(\"Checking if login modal is present.\")\r\n-        print(\"Checking if login modal is present.\")  # Debugging print\r\n-\r\n-        # Wait for the modal dialog itself to appear\r\n-        modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Modal dialog detected.\")\r\n-        print(f\"Modal dialog detected: {modal_dialog}\")\r\n-      # Debugging print\r\n-\r\n-        # Add a short sleep to ensure modal is fully loaded\r\n-        time.sleep(1)\r\n-\r\n-        # Ensure the email field is visible and ready for interaction\r\n-        email_field = wait.until(EC.element_to_be_clickable((By.ID, 'username')))\r\n-        logging.info(\"Email field detected and clickable.\")\r\n-        print(\"Email field detected and clickable.\")  # Debugging print\r\n-\r\n-        # Focus on the email field using ActionChains\r\n-        ActionChains(driver).move_to_element(email_field).click().perform()\r\n-        logging.info(\"Focused on email field.\")\r\n-        print(\"Focused on email field.\")  # Debugging print\r\n-\r\n-        # Clear any pre-existing text and send the email keys\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        time.sleep(1)  # Short pause to ensure the text is entered\r\n-        logging.info(\"Entered email in modal.\")\r\n-        print(\"Entered email in modal.\")  # Debugging print\r\n-\r\n-        # Ensure the password field is visible and ready for interaction\r\n-        password_field = wait.until(EC.element_to_be_clickable((By.ID, 'password')))\r\n-        logging.info(\"Password field detected and clickable.\")\r\n-        print(\"Password field detected and clickable.\")  # Debugging print\r\n-\r\n-        # Focus on the password field using ActionChains\r\n-        ActionChains(driver).move_to_element(password_field).click().perform()\r\n-        logging.info(\"Focused on password field.\")\r\n-        print(\"Focused on password field.\")  # Debugging print\r\n-\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info(\"Entered password in modal.\")\r\n-        print(\"Entered password in modal.\")  # Debugging print\r\n-\r\n-        # Ensure the \"Log in\" button is visible and clickable\r\n-        login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'login-dhi-button button')))\r\n-        logging.info(\"Log in button detected and clickable.\")\r\n-        print(\"Log in button detected and clickable.\")  # Debugging print\r\n-\r\n-        # Click the login button using JavaScript to ensure it is clicked\r\n-        driver.execute_script(\"arguments[0].click();\", login_button)\r\n-        logging.info(\"Clicked 'Log in' button in modal.\")\r\n-        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n-\r\n-        # Wait for the modal to disappear (indicating a successful login)\r\n-        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Successfully logged in via modal.\")\r\n-        print(\"Successfully logged in via modal.\")  # Debugging print\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(\"Login modal did not appear as expected.\")\r\n-        print(\"Login modal did not appear as expected.\")  # Debugging print\r\n-        capture_screenshot('login_modal_missing', subfolder='login')\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"Error finding login modal elements: {e}\")\r\n-        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        logging.info('Waiting for filters widget.')\r\n-        print('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" accordion.')\r\n-            print('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" filter button.')\r\n-            print('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n-                print('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(driver):\r\n-    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n-    logging.info(\"Attempting to locate the shadow host element.\")\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n-        print(\"Shadow host element found\")  # Debugging print\r\n-\r\n-        logging.info(\"Accessing the shadow root.\")\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n-        print(\"Shadow root accessed\")  # Debugging print\r\n-\r\n-        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n-        print(\"Easy Apply button found\")  # Debugging print\r\n-\r\n-        # Scroll the button into view before clicking\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button using JavaScript\r\n-        try:\r\n-            apply_now_button.click()  # Attempt to click the button\r\n-            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n-            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n-        except Exception as e:\r\n-            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n-\r\n-        return True\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        print(\"NoSuchElementException caught\")  # Debugging print\r\n-        return False\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        print(\"Unexpected exception caught\")  # Debugging print\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        print(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            logging.info(f'Attempting to click on job title: {job_title}')\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Call handle_login_modal right after the apply button is clicked\r\n-        handle_login_modal()\r\n-\r\n-        # Continue with the application process...\r\n-        # Wait for the apply modal to appear\r\n-        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        print(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the resume upload field to be present within the modal\r\n-        logging.info(f'Locating resume upload field for job: {job_title}')\r\n-        print(f'Locating resume upload field for job: {job_title}')\r\n-        try:\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Resume upload field not found for job: {job_title}')\r\n-            print(f'Resume upload field not found for job: {job_title}')\r\n-            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-        print(f'Locating \"Submit\" button for job: {job_title}')\r\n-        try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-        except TimeoutException:\r\n-            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-   \r\n-\r\n-    try:\r\n-        logging.info('Navigating to Dice homepage.')\r\n-        print('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        print('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        logging.info('Locating search button.')\r\n-        print('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        print('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                logging.info(f'Processing job {index}.')\r\n-                print(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import logging\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    logging.error(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Configure logging\r\n-logging.basicConfig(\r\n-    filename='application_log.txt',\r\n-    level=logging.DEBUG,  # Set to DEBUG for detailed logs\r\n-    format='%(asctime)s:%(levelname)s:%(message)s'\r\n-)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n-chrome_options.add_argument('--disable-extensions')\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-    print(\"Initialized Chrome WebDriver.\")\r\n-except WebDriverException as e:\r\n-    logging.error(f'Error initializing Chrome WebDriver: {e}')\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-print(\"Maximized browser window.\")\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-        print(f\"Created directory at path: {path}\")\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to create directory {path}: {e}')\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to capture screenshot \"{name}\": {e}')\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info('Navigating to Dice login page.')\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        logging.info('Waiting for email field.')\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info('Entered email.')\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        logging.info('Locating \"Continue\" button.')\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        logging.info('Clicked \"Continue\" button.')\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        logging.info('Waiting for password field.')\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info('Entered password.')\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        logging.info('Locating \"Sign In\" button.')\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        logging.info('Clicked \"Sign In\" button.')\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        logging.info('Waiting for dashboard to load.')\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        logging.info('Successfully logged into Dice.')\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-        # Save cookies after successful login\r\n-        cookies = driver.get_cookies()\r\n-        logging.info(f\"Saved cookies after login: {cookies}\")\r\n-\r\n-        # Reapply cookies if needed\r\n-        for cookie in cookies:\r\n-            driver.add_cookie(cookie)\r\n-        logging.info(\"Reapplied cookies to maintain session.\")\r\n-\r\n-        # Verify session persistence by checking if we're still on the dashboard\r\n-        driver.get('https://www.dice.com/dashboard')\r\n-        logging.info(\"Verified session persistence by navigating to the dashboard again.\")\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error during login: {e}')\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        logging.error(f'Redirected to an unexpected URL or logged out: {e}')\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-\r\n-def find_element_by_css_selector_through_shadow_dom(driver, selectors):\r\n-    \"\"\"\r\n-    Navigates through nested shadow DOMs to find the desired element.\r\n-    :param driver: The WebDriver instance.\r\n-    :param selectors: A list of CSS selectors, each representing a level in the shadow DOM.\r\n-    :return: The desired WebElement.\r\n-    \"\"\"\r\n-    # Start by finding the first element in the DOM\r\n-    element = driver.find_element(By.CSS_SELECTOR, selectors[0])\r\n-    for selector in selectors[1:]:\r\n-        # Use JavaScript to navigate through shadow roots\r\n-        element = driver.execute_script('''\r\n-            return arguments[0].shadowRoot.querySelector(arguments[1])\r\n-            ''', element, selector)\r\n-        if element is None:\r\n-            raise Exception(f'Element not found for selector: {selector}')\r\n-    return element\r\n-\r\n-\r\n-def handle_login_modal():\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Checking if login modal is present.\")\r\n-        print(\"Checking if login modal is present.\")  # Debugging print\r\n-\r\n-        # Define the selectors to navigate through the nested shadow DOMs\r\n-        email_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#username']\r\n-        password_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#password']\r\n-        login_button_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', 'login-dhi-button[data-cy=\"login-submit\"] button']\r\n-\r\n-        # Use the helper function to find the elements\r\n-        email_field = find_element_by_css_selector_through_shadow_dom(driver, email_field_selectors)\r\n-        logging.info(\"Email field detected.\")\r\n-        print(\"Email field detected.\")  # Debugging print\r\n-\r\n-        password_field = find_element_by_css_selector_through_shadow_dom(driver, password_field_selectors)\r\n-        logging.info(\"Password field detected.\")\r\n-        print(\"Password field detected.\")  # Debugging print\r\n-\r\n-        login_button = find_element_by_css_selector_through_shadow_dom(driver, login_button_selectors)\r\n-        logging.info(\"Login button detected.\")\r\n-        print(\"Login button detected.\")  # Debugging print\r\n-\r\n-        # Interact with the elements\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info(\"Entered email in modal.\")\r\n-        print(\"Entered email in modal.\")  # Debugging print\r\n-\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info(\"Entered password in modal.\")\r\n-        print(\"Entered password in modal.\")  # Debugging print\r\n-\r\n-        # Click the login button using JavaScript to ensure it is clicked\r\n-        driver.execute_script(\"arguments[0].click();\", login_button)\r\n-        logging.info(\"Clicked 'Log in' button in modal.\")\r\n-        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n-\r\n-        # Wait for the modal to disappear (indicating a successful login)\r\n-        wait = WebDriverWait(driver, 20)\r\n-        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Successfully logged in via modal.\")\r\n-        print(\"Successfully logged in via modal.\")  # Debugging print\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n-\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Checking if login modal is present.\")\r\n-        print(\"Checking if login modal is present.\")  # Debugging print\r\n-\r\n-        # Define the selectors to navigate through the nested shadow DOMs\r\n-        email_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#username']\r\n-        password_field_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', '#password']\r\n-        login_button_selectors = ['login-modal', 'login-dhi-modal', 'dialog', 'login-form', 'login-dhi-button[data-cy=\"login-submit\"] button']\r\n-\r\n-        # Use the helper function to find the elements\r\n-        email_field = find_element_by_css_selector_through_shadow_dom(driver, email_field_selectors)\r\n-        logging.info(\"Email field detected.\")\r\n-        print(\"Email field detected.\")  # Debugging print\r\n-\r\n-        password_field = find_element_by_css_selector_through_shadow_dom(driver, password_field_selectors)\r\n-        logging.info(\"Password field detected.\")\r\n-        print(\"Password field detected.\")  # Debugging print\r\n-\r\n-        login_button = find_element_by_css_selector_through_shadow_dom(driver, login_button_selectors)\r\n-        logging.info(\"Login button detected.\")\r\n-        print(\"Login button detected.\")  # Debugging print\r\n-\r\n-        # Interact with the elements\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        logging.info(\"Entered email in modal.\")\r\n-        print(\"Entered email in modal.\")  # Debugging print\r\n-\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info(\"Entered password in modal.\")\r\n-        print(\"Entered password in modal.\")  # Debugging print\r\n-\r\n-        # Click the login button using JavaScript to ensure it is clicked\r\n-        driver.execute_script(\"arguments[0].click();\", login_button)\r\n-        logging.info(\"Clicked 'Log in' button in modal.\")\r\n-        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n-\r\n-        # Wait for the modal to disappear (indicating a successful login)\r\n-        wait = WebDriverWait(driver, 20)\r\n-        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Successfully logged in via modal.\")\r\n-        print(\"Successfully logged in via modal.\")  # Debugging print\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n-\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)\r\n-        logging.info(\"Checking if login modal is present.\")\r\n-        print(\"Checking if login modal is present.\")  # Debugging print\r\n-\r\n-        # Wait for the modal dialog itself to appear\r\n-        modal_dialog = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Modal dialog detected.\")\r\n-        print(f\"Modal dialog detected: {modal_dialog}\")\r\n-      # Debugging print\r\n-\r\n-        # Add a short sleep to ensure modal is fully loaded\r\n-        time.sleep(1)\r\n-\r\n-        # Ensure the email field is visible and ready for interaction\r\n-        email_field = wait.until(EC.element_to_be_clickable((By.ID, 'username')))\r\n-        logging.info(\"Email field detected and clickable.\")\r\n-        print(\"Email field detected and clickable.\")  # Debugging print\r\n-\r\n-        # Focus on the email field using ActionChains\r\n-        ActionChains(driver).move_to_element(email_field).click().perform()\r\n-        logging.info(\"Focused on email field.\")\r\n-        print(\"Focused on email field.\")  # Debugging print\r\n-\r\n-        # Clear any pre-existing text and send the email keys\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        time.sleep(1)  # Short pause to ensure the text is entered\r\n-        logging.info(\"Entered email in modal.\")\r\n-        print(\"Entered email in modal.\")  # Debugging print\r\n-\r\n-        # Ensure the password field is visible and ready for interaction\r\n-        password_field = wait.until(EC.element_to_be_clickable((By.ID, 'password')))\r\n-        logging.info(\"Password field detected and clickable.\")\r\n-        print(\"Password field detected and clickable.\")  # Debugging print\r\n-\r\n-        # Focus on the password field using ActionChains\r\n-        ActionChains(driver).move_to_element(password_field).click().perform()\r\n-        logging.info(\"Focused on password field.\")\r\n-        print(\"Focused on password field.\")  # Debugging print\r\n-\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        logging.info(\"Entered password in modal.\")\r\n-        print(\"Entered password in modal.\")  # Debugging print\r\n-\r\n-        # Ensure the \"Log in\" button is visible and clickable\r\n-        login_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, 'login-dhi-button button')))\r\n-        logging.info(\"Log in button detected and clickable.\")\r\n-        print(\"Log in button detected and clickable.\")  # Debugging print\r\n-\r\n-        # Click the login button using JavaScript to ensure it is clicked\r\n-        driver.execute_script(\"arguments[0].click();\", login_button)\r\n-        logging.info(\"Clicked 'Log in' button in modal.\")\r\n-        print(\"Clicked 'Log in' button in modal.\")  # Debugging print\r\n-\r\n-        # Wait for the modal to disappear (indicating a successful login)\r\n-        wait.until(EC.invisibility_of_element_located((By.TAG_NAME, 'dialog')))\r\n-        logging.info(\"Successfully logged in via modal.\")\r\n-        print(\"Successfully logged in via modal.\")  # Debugging print\r\n-\r\n-    except TimeoutException:\r\n-        logging.error(\"Login modal did not appear as expected.\")\r\n-        print(\"Login modal did not appear as expected.\")  # Debugging print\r\n-        capture_screenshot('login_modal_missing', subfolder='login')\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"Error finding login modal elements: {e}\")\r\n-        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")  # Debugging print\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        logging.info('Waiting for filters widget.')\r\n-        print('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        logging.info('Filters widget located.')\r\n-        print('Filters widget located.')\r\n-\r\n-        # For debugging: log the inner HTML of the filters_widget\r\n-        filters_html = filters_widget.get_attribute('innerHTML')\r\n-        logging.debug(f'Filters widget inner HTML: {filters_html}')\r\n-        print('Logged filters widget inner HTML for debugging.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" accordion.')\r\n-            print('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            logging.info('\"Easy Apply\" accordion located.')\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" accordion not found within filters widget.')\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            logging.info('Locating \"Easy Apply\" filter button.')\r\n-            print('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            logging.info('\"Easy Apply\" filter button located.')\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            logging.error('\"Easy Apply\" filter button not found within accordion.')\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            logging.info('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            logging.error('\"Easy Apply\" filter button is not clickable.')\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        logging.debug(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            logging.info('\"Easy Apply\" filter is already active.')\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                logging.info('Attempting to click \"Easy Apply\" filter button.')\r\n-                print('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                logging.warning(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            logging.info('\"Easy Apply\" filter activated.')\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            logging.warning(f'URL does not contain expected parameters: {expected_params}')\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            logging.info('Navigated to filtered URL.')\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            logging.info('URL contains the expected filter parameters.')\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        logging.error(f'Unexpected error activating \"Easy Apply\" filter: {e}')\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(driver):\r\n-    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n-    logging.info(\"Attempting to locate the shadow host element.\")\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        logging.info(\"Shadow host element found: %s\", shadow_host)\r\n-        print(\"Shadow host element found\")  # Debugging print\r\n-\r\n-        logging.info(\"Accessing the shadow root.\")\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        logging.info(\"Shadow root accessed: %s\", shadow_root)\r\n-        print(\"Shadow root accessed\")  # Debugging print\r\n-\r\n-        logging.info(\"Attempting to locate the 'Easy Apply' button within the shadow root.\")\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        logging.info(\"Found the 'Easy Apply' button: %s\", apply_now_button)\r\n-        print(\"Easy Apply button found\")  # Debugging print\r\n-\r\n-        # Scroll the button into view before clicking\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button using JavaScript\r\n-        try:\r\n-            apply_now_button.click()  # Attempt to click the button\r\n-            logging.info(\"Clicked 'Easy Apply' button using click method.\")\r\n-            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n-        except Exception as e:\r\n-            logging.warning(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            logging.info(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n-\r\n-        return True\r\n-    except NoSuchElementException as e:\r\n-        logging.error(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        print(\"NoSuchElementException caught\")  # Debugging print\r\n-        return False\r\n-    except Exception as e:\r\n-        logging.error(f\"An unexpected error occurred: {str(e)}\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        print(\"Unexpected exception caught\")  # Debugging print\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        logging.debug(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        logging.debug(f'Screenshot saved to {screenshot_path}')\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        logging.error(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            logging.info(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        logging.info(f'Scrolling into view for job: {job_title}')\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        logging.info(f'Locating job title link for: {job_title}')\r\n-        print(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        logging.info(f'Waiting for job title to be clickable for: {job_title}')\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            logging.info(f'Attempting to click on job title: {job_title}')\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            logging.info(f'Clicked on job title: {job_title}')\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            logging.warning(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            logging.info(f'Switched to new window for job: {job_title}')\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            logging.info(f'Job details opened in the same window for job: {job_title}')\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        logging.info(f'Waiting for job details to load for: {job_title}')\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        logging.debug(f'Job details loaded for: {job_title}')\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            logging.info(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Call handle_login_modal right after the apply button is clicked\r\n-        handle_login_modal()\r\n-\r\n-        # Continue with the application process...\r\n-        # Wait for the apply modal to appear\r\n-        logging.info(f'Waiting for apply modal for job: {job_title}')\r\n-        print(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            logging.debug(f'Apply modal appeared for job: {job_title}')\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Apply modal did not appear for job: {job_title}')\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the resume upload field to be present within the modal\r\n-        logging.info(f'Locating resume upload field for job: {job_title}')\r\n-        print(f'Locating resume upload field for job: {job_title}')\r\n-        try:\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            logging.info(f'Uploaded resume for job: {job_title}')\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-        except TimeoutException:\r\n-            logging.error(f'Resume upload field not found for job: {job_title}')\r\n-            print(f'Resume upload field not found for job: {job_title}')\r\n-            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        logging.info(f'Locating \"Submit\" button for job: {job_title}')\r\n-        print(f'Locating \"Submit\" button for job: {job_title}')\r\n-        try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            logging.info(f'Successfully applied to {job_title}')\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-        except TimeoutException:\r\n-            logging.error(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            logging.info(f'Navigated back to job listings after processing {job_title}')\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        logging.error(f'Error applying to \"{job_title}\": {e}')\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        logging.error(f'Failed to apply to \"{job_title}\": {e}')\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            logging.info(f'Closed new window and switched back to original window after processing {job_title}')\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-   \r\n-\r\n-    try:\r\n-        logging.info('Navigating to Dice homepage.')\r\n-        print('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        logging.info('Waiting for search field.')\r\n-        print('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        logging.info(f'Entered search terms: {SEARCH_TERMS}')\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        logging.info('Locating search button.')\r\n-        print('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        logging.info('Clicked search button.')\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        logging.info('Locating job cards.')\r\n-        print('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        logging.info(f'Found {len(job_cards)} job postings.')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                logging.info(f'Processing job {index}.')\r\n-                print(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                logging.info(f'Job {index}: Found title: {job_title}')\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                logging.warning(f'Job {index}: Title element not found.')\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                logging.debug(f'Job {index} HTML: {job_card_html}')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            # Debugging: Log job titles\r\n-            logging.debug(f'Job {index}: Title=\"{job_title}\"')\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                logging.info(f'Job {index}: Applying to job: {job_title}')\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                logging.info(f'Job {index}: Skipping job: {job_title}')\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-        logging.info(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        logging.error(f'An error occurred in main(): {e}')\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n"
                },
                {
                    "date": 1726951227967,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n \r\n # Add options to use existing Chrome profile\r\n # Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\YourUserName\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n-chrome_options.add_argument(\"profile-directory=anon\")  # Or the name of your profile directory\r\n+chrome_options.add_argument(\"profile-directory=anon anon\")  # Or the name of your profile directory\r\n \r\n # Initialize the WebDriver\r\n try:\r\n     driver = webdriver.Chrome(options=chrome_options)\r\n"
                },
                {
                    "date": 1726951365931,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,562 @@\n+import configparser\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('--disable-extensions')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Add options to use existing Chrome profile\r\n+# Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n+chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n+chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n+except WebDriverException as e:\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n+    except Exception as e:\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+        # Save cookies after successful login\r\n+        cookies = driver.get_cookies()\r\n+\r\n+        # Reapply cookies if needed\r\n+        for cookie in cookies:\r\n+            driver.add_cookie(cookie)\r\n+\r\n+        # Verify session persistence by checking if we're still on the dashboard\r\n+        driver.get('https://www.dice.com/dashboard')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def handle_login_modal():\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)\r\n+        print(\"Checking if login modal is present.\")\r\n+\r\n+        # Wait for the modal dialog to be present\r\n+        modal_dialog = wait.until(EC.presence_of_element_located((By.XPATH, '//dialog')))\r\n+        print(f\"Modal dialog detected: {modal_dialog}\")\r\n+\r\n+        # Use the modal_dialog as the context for finding elements\r\n+        # Locate the email field within the dialog\r\n+        email_field = modal_dialog.find_element(By.ID, 'username')\r\n+        print(\"Email field detected.\")\r\n+\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        print(\"Entered email in modal.\")\r\n+\r\n+        # Locate the password field within the dialog\r\n+        password_field = modal_dialog.find_element(By.ID, 'password')\r\n+        print(\"Password field detected.\")\r\n+\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        print(\"Entered password in modal.\")\r\n+\r\n+        # Locate the login button within the dialog\r\n+        login_button = modal_dialog.find_element(By.XPATH, './/login-dhi-button[@data-cy=\"login-submit\"]//button')\r\n+        print(\"Log in button detected.\")\r\n+\r\n+        # Click the login button\r\n+        login_button.click()\r\n+        print(\"Clicked 'Log in' button in modal.\")\r\n+\r\n+        # Wait for the modal to disappear (indicating successful login)\r\n+        wait.until(EC.invisibility_of_element_located((By.XPATH, '//dialog')))\r\n+        print(\"Successfully logged in via modal.\")\r\n+\r\n+    except TimeoutException:\r\n+        print(\"Login modal did not appear as expected.\")\r\n+        capture_screenshot('login_modal_missing', subfolder='login')\r\n+    except NoSuchElementException as e:\r\n+        print(f\"Error finding login modal elements: {e}\")\r\n+        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n+    except Exception as e:\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        print('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        print('Filters widget located.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(driver):\r\n+    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n+    try:\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        print(\"Shadow host element found\")  # Debugging print\r\n+\r\n+        # Access the shadow root\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        print(\"Shadow root accessed\")  # Debugging print\r\n+\r\n+        # Locate the 'Easy Apply' button within the shadow root\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        print(\"Easy Apply button found\")  # Debugging print\r\n+\r\n+        # Scroll the button into view before clicking\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button\r\n+        try:\r\n+            apply_now_button.click()  # Attempt to click the button\r\n+            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n+        except Exception as e:\r\n+            print(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n+\r\n+        return True\r\n+    except NoSuchElementException as e:\r\n+        print(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        print(\"NoSuchElementException caught\")  # Debugging print\r\n+        return False\r\n+    except Exception as e:\r\n+        print(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        print(\"Unexpected exception caught\")  # Debugging print\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            print(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Call handle_login_modal right after the apply button is clicked\r\n+        handle_login_modal()\r\n+\r\n+        # Continue with the application process...\r\n+        # Wait for the apply modal to appear\r\n+        print(f'Waiting for apply modal for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the resume upload field to be present within the modal\r\n+        print(f'Locating resume upload field for job: {job_title}')\r\n+        try:\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+        except TimeoutException:\r\n+            print(f'Resume upload field not found for job: {job_title}')\r\n+            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        print(f'Locating \"Submit\" button for job: {job_title}')\r\n+        try:\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+        except TimeoutException:\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    try:\r\n+        print('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        print('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        print('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        print('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                print(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726951394099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n \r\n # Add options to use existing Chrome profile\r\n # Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n-chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n+chrome_options.add_argument(\"profile-directory=anon\")  # Or the name of your profile directory\r\n \r\n # Initialize the WebDriver\r\n try:\r\n     driver = webdriver.Chrome(options=chrome_options)\r\n@@ -559,566 +559,4 @@\n # -----------------------------\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-import configparser\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n-chrome_options.add_argument('--disable-extensions')\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Add options to use existing Chrome profile\r\n-# Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n-chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\YourUserName\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n-chrome_options.add_argument(\"profile-directory=anon anon\")  # Or the name of your profile directory\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-    print(\"Initialized Chrome WebDriver.\")\r\n-except WebDriverException as e:\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-print(\"Maximized browser window.\")\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-        print(f\"Created directory at path: {path}\")\r\n-    except Exception as e:\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-        # Save cookies after successful login\r\n-        cookies = driver.get_cookies()\r\n-\r\n-        # Reapply cookies if needed\r\n-        for cookie in cookies:\r\n-            driver.add_cookie(cookie)\r\n-\r\n-        # Verify session persistence by checking if we're still on the dashboard\r\n-        driver.get('https://www.dice.com/dashboard')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def handle_login_modal():\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)\r\n-        print(\"Checking if login modal is present.\")\r\n-\r\n-        # Wait for the modal dialog to be present\r\n-        modal_dialog = wait.until(EC.presence_of_element_located((By.XPATH, '//dialog')))\r\n-        print(f\"Modal dialog detected: {modal_dialog}\")\r\n-\r\n-        # Use the modal_dialog as the context for finding elements\r\n-        # Locate the email field within the dialog\r\n-        email_field = modal_dialog.find_element(By.ID, 'username')\r\n-        print(\"Email field detected.\")\r\n-\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        print(\"Entered email in modal.\")\r\n-\r\n-        # Locate the password field within the dialog\r\n-        password_field = modal_dialog.find_element(By.ID, 'password')\r\n-        print(\"Password field detected.\")\r\n-\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        print(\"Entered password in modal.\")\r\n-\r\n-        # Locate the login button within the dialog\r\n-        login_button = modal_dialog.find_element(By.XPATH, './/login-dhi-button[@data-cy=\"login-submit\"]//button')\r\n-        print(\"Log in button detected.\")\r\n-\r\n-        # Click the login button\r\n-        login_button.click()\r\n-        print(\"Clicked 'Log in' button in modal.\")\r\n-\r\n-        # Wait for the modal to disappear (indicating successful login)\r\n-        wait.until(EC.invisibility_of_element_located((By.XPATH, '//dialog')))\r\n-        print(\"Successfully logged in via modal.\")\r\n-\r\n-    except TimeoutException:\r\n-        print(\"Login modal did not appear as expected.\")\r\n-        capture_screenshot('login_modal_missing', subfolder='login')\r\n-    except NoSuchElementException as e:\r\n-        print(f\"Error finding login modal elements: {e}\")\r\n-        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n-    except Exception as e:\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        print('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        print('Filters widget located.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                print('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(driver):\r\n-    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        print(\"Shadow host element found\")  # Debugging print\r\n-\r\n-        # Access the shadow root\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        print(\"Shadow root accessed\")  # Debugging print\r\n-\r\n-        # Locate the 'Easy Apply' button within the shadow root\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        print(\"Easy Apply button found\")  # Debugging print\r\n-\r\n-        # Scroll the button into view before clicking\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button\r\n-        try:\r\n-            apply_now_button.click()  # Attempt to click the button\r\n-            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n-        except Exception as e:\r\n-            print(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n-\r\n-        return True\r\n-    except NoSuchElementException as e:\r\n-        print(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        print(\"NoSuchElementException caught\")  # Debugging print\r\n-        return False\r\n-    except Exception as e:\r\n-        print(f\"An unexpected error occurred: {str(e)}\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        print(\"Unexpected exception caught\")  # Debugging print\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            print(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        print(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Call handle_login_modal right after the apply button is clicked\r\n-        handle_login_modal()\r\n-\r\n-        # Continue with the application process...\r\n-        # Wait for the apply modal to appear\r\n-        print(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-        except TimeoutException:\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the resume upload field to be present within the modal\r\n-        print(f'Locating resume upload field for job: {job_title}')\r\n-        try:\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-        except TimeoutException:\r\n-            print(f'Resume upload field not found for job: {job_title}')\r\n-            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        print(f'Locating \"Submit\" button for job: {job_title}')\r\n-        try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-        except TimeoutException:\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    try:\r\n-        print('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        print('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        print('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        print('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                print(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n"
                },
                {
                    "date": 1726951456193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n \r\n # Add options to use existing Chrome profile\r\n # Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n-chrome_options.add_argument(\"profile-directory=anon\")  # Or the name of your profile directory\r\n+chrome_options.add_argument(\"profile-directory=anon anon\")  # Or the name of your profile directory\r\n \r\n # Initialize the WebDriver\r\n try:\r\n     driver = webdriver.Chrome(options=chrome_options)\r\n"
                },
                {
                    "date": 1726951497485,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,562 @@\n+import configparser\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('--disable-extensions')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Add options to use existing Chrome profile\r\n+# Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n+chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n+chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n+except WebDriverException as e:\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n+    except Exception as e:\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def login_to_dice():\r\n+    \"\"\"\r\n+    Logs into Dice.com using the provided email and password.\r\n+    \"\"\"\r\n+    try:\r\n+        driver.get('https://www.dice.com/dashboard/login')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the email field to be present\r\n+        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        print('Entered email.')\r\n+\r\n+        # Locate and click the \"Continue\" button\r\n+        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n+        continue_button.click()\r\n+        print('Clicked \"Continue\" button.')\r\n+\r\n+        # Wait for the password field to be present\r\n+        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        print('Entered password.')\r\n+\r\n+        # Locate and click the \"Sign In\" button\r\n+        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n+        sign_in_button.click()\r\n+        print('Clicked \"Sign In\" button.')\r\n+\r\n+        # Wait until dashboard loads by checking URL or a specific element\r\n+        wait.until(EC.url_contains('/dashboard'))\r\n+        print(\"Successfully logged into Dice.\")\r\n+\r\n+        # Save cookies after successful login\r\n+        cookies = driver.get_cookies()\r\n+\r\n+        # Reapply cookies if needed\r\n+        for cookie in cookies:\r\n+            driver.add_cookie(cookie)\r\n+\r\n+        # Verify session persistence by checking if we're still on the dashboard\r\n+        driver.get('https://www.dice.com/dashboard')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f\"Error during login: {e}\")\r\n+        capture_screenshot('login_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+    except WebDriverException as e:\r\n+        print(f\"Unexpected redirection or logout: {e}\")\r\n+        capture_screenshot('login_redirection_error', subfolder='login')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def handle_login_modal():\r\n+    \"\"\"\r\n+    Handles the login modal that appears after clicking \"Apply now\".\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)\r\n+        print(\"Checking if login modal is present.\")\r\n+\r\n+        # Wait for the modal dialog to be present\r\n+        modal_dialog = wait.until(EC.presence_of_element_located((By.XPATH, '//dialog')))\r\n+        print(f\"Modal dialog detected: {modal_dialog}\")\r\n+\r\n+        # Use the modal_dialog as the context for finding elements\r\n+        # Locate the email field within the dialog\r\n+        email_field = modal_dialog.find_element(By.ID, 'username')\r\n+        print(\"Email field detected.\")\r\n+\r\n+        email_field.clear()\r\n+        email_field.send_keys(EMAIL)\r\n+        print(\"Entered email in modal.\")\r\n+\r\n+        # Locate the password field within the dialog\r\n+        password_field = modal_dialog.find_element(By.ID, 'password')\r\n+        print(\"Password field detected.\")\r\n+\r\n+        password_field.clear()\r\n+        password_field.send_keys(PASSWORD)\r\n+        print(\"Entered password in modal.\")\r\n+\r\n+        # Locate the login button within the dialog\r\n+        login_button = modal_dialog.find_element(By.XPATH, './/login-dhi-button[@data-cy=\"login-submit\"]//button')\r\n+        print(\"Log in button detected.\")\r\n+\r\n+        # Click the login button\r\n+        login_button.click()\r\n+        print(\"Clicked 'Log in' button in modal.\")\r\n+\r\n+        # Wait for the modal to disappear (indicating successful login)\r\n+        wait.until(EC.invisibility_of_element_located((By.XPATH, '//dialog')))\r\n+        print(\"Successfully logged in via modal.\")\r\n+\r\n+    except TimeoutException:\r\n+        print(\"Login modal did not appear as expected.\")\r\n+        capture_screenshot('login_modal_missing', subfolder='login')\r\n+    except NoSuchElementException as e:\r\n+        print(f\"Error finding login modal elements: {e}\")\r\n+        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n+    except Exception as e:\r\n+        print(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n+        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        print('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        print('Filters widget located.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(driver):\r\n+    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n+    try:\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        print(\"Shadow host element found\")  # Debugging print\r\n+\r\n+        # Access the shadow root\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        print(\"Shadow root accessed\")  # Debugging print\r\n+\r\n+        # Locate the 'Easy Apply' button within the shadow root\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        print(\"Easy Apply button found\")  # Debugging print\r\n+\r\n+        # Scroll the button into view before clicking\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button\r\n+        try:\r\n+            apply_now_button.click()  # Attempt to click the button\r\n+            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n+        except Exception as e:\r\n+            print(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n+\r\n+        return True\r\n+    except NoSuchElementException as e:\r\n+        print(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        print(\"NoSuchElementException caught\")  # Debugging print\r\n+        return False\r\n+    except Exception as e:\r\n+        print(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        print(\"Unexpected exception caught\")  # Debugging print\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            print(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+        # Call handle_login_modal right after the apply button is clicked\r\n+        handle_login_modal()\r\n+\r\n+        # Continue with the application process...\r\n+        # Wait for the apply modal to appear\r\n+        print(f'Waiting for apply modal for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the resume upload field to be present within the modal\r\n+        print(f'Locating resume upload field for job: {job_title}')\r\n+        try:\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+        except TimeoutException:\r\n+            print(f'Resume upload field not found for job: {job_title}')\r\n+            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        print(f'Locating \"Submit\" button for job: {job_title}')\r\n+        try:\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+        except TimeoutException:\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    try:\r\n+        print('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        print('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        print('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        print('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                print(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726951867620,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,453 @@\n+import configparser\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('--disable-extensions')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Add options to use existing Chrome profile\r\n+# Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n+chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n+chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n+except WebDriverException as e:\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n+    except Exception as e:\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        print('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        print('Filters widget located.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def has_apply_now(driver):\r\n+    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n+    try:\r\n+        # Locate the shadow host element\r\n+        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        print(\"Shadow host element found\")  # Debugging print\r\n+\r\n+        # Access the shadow root\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n+        print(\"Shadow root accessed\")  # Debugging print\r\n+\r\n+        # Locate the 'Easy Apply' button within the shadow root\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        print(\"Easy Apply button found\")  # Debugging print\r\n+\r\n+        # Scroll the button into view before clicking\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n+        time.sleep(1)  # Give time for scrolling animation\r\n+\r\n+        # Try clicking the button\r\n+        try:\r\n+            apply_now_button.click()  # Attempt to click the button\r\n+            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n+        except Exception as e:\r\n+            print(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n+\r\n+        return True\r\n+    except NoSuchElementException as e:\r\n+        print(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n+        print(\"NoSuchElementException caught\")  # Debugging print\r\n+        return False\r\n+    except Exception as e:\r\n+        print(f\"An unexpected error occurred: {str(e)}\")\r\n+        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n+        print(\"Unexpected exception caught\")  # Debugging print\r\n+        return False\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            print(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+\r\n+        # Scroll the job card into view\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details panel to load\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n+        if not has_apply_now(driver):\r\n+            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n+            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return  # Exit if the button is not found\r\n+\r\n+\r\n+        # Continue with the application process...\r\n+        # Wait for the apply modal to appear\r\n+        print(f'Waiting for apply modal for job: {job_title}')\r\n+        try:\r\n+            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n+            print(f'Apply modal appeared for job: {job_title}')\r\n+        except TimeoutException:\r\n+            print(f'Apply modal did not appear for job: {job_title}')\r\n+            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the resume upload field to be present within the modal\r\n+        print(f'Locating resume upload field for job: {job_title}')\r\n+        try:\r\n+            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n+            upload_field.send_keys(RESUME_PATH)\r\n+            print(f'Uploaded resume for job: {job_title}')\r\n+        except TimeoutException:\r\n+            print(f'Resume upload field not found for job: {job_title}')\r\n+            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Wait for the 'Submit' button to be clickable and click it\r\n+        print(f'Locating \"Submit\" button for job: {job_title}')\r\n+        try:\r\n+            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n+            submit_button.click()\r\n+            print(f\"Successfully applied to {job_title}\")\r\n+        except TimeoutException:\r\n+            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n+            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n+            return\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    try:\r\n+        print('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        print('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        print('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        print('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                print(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                print(f'Job {index}: Title element not found.')\r\n+\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726953456814,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,16 +39,17 @@\n # Uncomment the following line to run the browser in headless mode\r\n # chrome_options.add_argument('--headless')\r\n \r\n # Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)\\\r\n+ Chrome/91.0.4472.124 Safari/537.36')\r\n chrome_options.add_argument('--disable-extensions')\r\n chrome_options.add_argument('--ignore-certificate-errors')\r\n chrome_options.add_argument('--ignore-ssl-errors')\r\n \r\n # Add options to use existing Chrome profile\r\n # Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n-chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n+chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\YourUserName\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n \r\n # Initialize the WebDriver\r\n try:\r\n@@ -96,152 +97,8 @@\n         print(f'Screenshot saved to {screenshot_path}')\r\n     except Exception as e:\r\n         print(f'Failed to capture screenshot \"{name}\": {e}')\r\n \r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        print('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        print('Filters widget located.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                print('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(driver):\r\n-    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        print(\"Shadow host element found\")  # Debugging print\r\n-\r\n-        # Access the shadow root\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        print(\"Shadow root accessed\")  # Debugging print\r\n-\r\n-        # Locate the 'Easy Apply' button within the shadow root\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        print(\"Easy Apply button found\")  # Debugging print\r\n-\r\n-        # Scroll the button into view before clicking\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button\r\n-        try:\r\n-            apply_now_button.click()  # Attempt to click the button\r\n-            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n-        except Exception as e:\r\n-            print(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n-\r\n-        return True\r\n-    except NoSuchElementException as e:\r\n-        print(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        print(\"NoSuchElementException caught\")  # Debugging print\r\n-        return False\r\n-    except Exception as e:\r\n-        print(f\"An unexpected error occurred: {str(e)}\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        print(\"Unexpected exception caught\")  # Debugging print\r\n-        return False\r\n-\r\n def log_available_buttons(job_card, job_title):\r\n     \"\"\"\r\n     Logs all available buttons within a job card for debugging purposes.\r\n     \"\"\"\r\n@@ -257,578 +114,23 @@\n         print(f'Screenshot saved to {screenshot_path}')\r\n     except Exception as e:\r\n         print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n \r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            print(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-\r\n-        # Scroll the job card into view\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        print(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-\r\n-        # Continue with the application process...\r\n-        # Wait for the apply modal to appear\r\n-        print(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-        except TimeoutException:\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the resume upload field to be present within the modal\r\n-        print(f'Locating resume upload field for job: {job_title}')\r\n-        try:\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-        except TimeoutException:\r\n-            print(f'Resume upload field not found for job: {job_title}')\r\n-            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        print(f'Locating \"Submit\" button for job: {job_title}')\r\n-        try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-        except TimeoutException:\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    try:\r\n-        print('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        print('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        print('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        print('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                print(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n-chrome_options.add_argument('--disable-extensions')\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Add options to use existing Chrome profile\r\n-# Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n-chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n-chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-    print(\"Initialized Chrome WebDriver.\")\r\n-except WebDriverException as e:\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-print(\"Maximized browser window.\")\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-        print(f\"Created directory at path: {path}\")\r\n-    except Exception as e:\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-        # Save cookies after successful login\r\n-        cookies = driver.get_cookies()\r\n-\r\n-        # Reapply cookies if needed\r\n-        for cookie in cookies:\r\n-            driver.add_cookie(cookie)\r\n-\r\n-        # Verify session persistence by checking if we're still on the dashboard\r\n-        driver.get('https://www.dice.com/dashboard')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def handle_login_modal():\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)\r\n-        print(\"Checking if login modal is present.\")\r\n-\r\n-        # Wait for the modal dialog to be present\r\n-        modal_dialog = wait.until(EC.presence_of_element_located((By.XPATH, '//dialog')))\r\n-        print(f\"Modal dialog detected: {modal_dialog}\")\r\n-\r\n-        # Use the modal_dialog as the context for finding elements\r\n-        # Locate the email field within the dialog\r\n-        email_field = modal_dialog.find_element(By.ID, 'username')\r\n-        print(\"Email field detected.\")\r\n-\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        print(\"Entered email in modal.\")\r\n-\r\n-        # Locate the password field within the dialog\r\n-        password_field = modal_dialog.find_element(By.ID, 'password')\r\n-        print(\"Password field detected.\")\r\n-\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        print(\"Entered password in modal.\")\r\n-\r\n-        # Locate the login button within the dialog\r\n-        login_button = modal_dialog.find_element(By.XPATH, './/login-dhi-button[@data-cy=\"login-submit\"]//button')\r\n-        print(\"Log in button detected.\")\r\n-\r\n-        # Click the login button\r\n-        login_button.click()\r\n-        print(\"Clicked 'Log in' button in modal.\")\r\n-\r\n-        # Wait for the modal to disappear (indicating successful login)\r\n-        wait.until(EC.invisibility_of_element_located((By.XPATH, '//dialog')))\r\n-        print(\"Successfully logged in via modal.\")\r\n-\r\n-    except TimeoutException:\r\n-        print(\"Login modal did not appear as expected.\")\r\n-        capture_screenshot('login_modal_missing', subfolder='login')\r\n-    except NoSuchElementException as e:\r\n-        print(f\"Error finding login modal elements: {e}\")\r\n-        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n-    except Exception as e:\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-\r\n def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+    # [Your existing activate_easy_apply_filter function]\r\n+    # Ensure this function remains the same as before\r\n+    pass\r\n \r\n-        # Wait for the filters widget to load\r\n-        print('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        print('Filters widget located.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                print('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(driver):\r\n-    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        print(\"Shadow host element found\")  # Debugging print\r\n-\r\n-        # Access the shadow root\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        print(\"Shadow root accessed\")  # Debugging print\r\n-\r\n-        # Locate the 'Easy Apply' button within the shadow root\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        print(\"Easy Apply button found\")  # Debugging print\r\n-\r\n-        # Scroll the button into view before clicking\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button\r\n-        try:\r\n-            apply_now_button.click()  # Attempt to click the button\r\n-            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n-        except Exception as e:\r\n-            print(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n-\r\n-        return True\r\n-    except NoSuchElementException as e:\r\n-        print(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        print(\"NoSuchElementException caught\")  # Debugging print\r\n-        return False\r\n-    except Exception as e:\r\n-        print(f\"An unexpected error occurred: {str(e)}\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        print(\"Unexpected exception caught\")  # Debugging print\r\n-        return False\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n def apply_to_job(job_card, job_title, applied_jobs):\r\n     \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n+    Attempts to apply to a job by handling the navigation to the application page.\r\n     \"\"\"\r\n     try:\r\n         if job_title in applied_jobs:\r\n             print(f'Skipping already applied job: {job_title}')\r\n             return  # Skip if we've already applied to this job\r\n \r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n \r\n         # Scroll the job card into view\r\n         print(f'Scrolling into view for job: {job_title}')\r\n         driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n@@ -860,618 +162,67 @@\n         else:\r\n             # Job details opened in the same window\r\n             print(f'Job details opened in the same window for job: {job_title}')\r\n \r\n-        # Wait for the job details panel to load\r\n+        # Wait for the job details page to load\r\n         print(f'Waiting for job details to load for: {job_title}')\r\n         wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n         time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n         print(f'Job details loaded for: {job_title}')\r\n \r\n-        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n+        # Locate and click the \"Easy Apply\" button\r\n+        print(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n+        easy_apply_button = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        driver.execute_script('arguments[0].scrollIntoView(true);', easy_apply_button)\r\n+        time.sleep(1)\r\n \r\n-        # Call handle_login_modal right after the apply button is clicked\r\n-        handle_login_modal()\r\n-\r\n-        # Continue with the application process...\r\n-        # Wait for the apply modal to appear\r\n-        print(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-        except TimeoutException:\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the resume upload field to be present within the modal\r\n-        print(f'Locating resume upload field for job: {job_title}')\r\n-        try:\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-        except TimeoutException:\r\n-            print(f'Resume upload field not found for job: {job_title}')\r\n-            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        print(f'Locating \"Submit\" button for job: {job_title}')\r\n-        try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-        except TimeoutException:\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    try:\r\n-        print('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n-        print('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        print('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        print('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                print(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                print(f'Job {index}: Title element not found.')\r\n-\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36')\r\n-chrome_options.add_argument('--disable-extensions')\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Add options to use existing Chrome profile\r\n-# Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n-chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n-chrome_options.add_argument(\"profile-directory=anon anon\")  # Or the name of your profile directory\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-    print(\"Initialized Chrome WebDriver.\")\r\n-except WebDriverException as e:\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-print(\"Maximized browser window.\")\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-        print(f\"Created directory at path: {path}\")\r\n-    except Exception as e:\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def login_to_dice():\r\n-    \"\"\"\r\n-    Logs into Dice.com using the provided email and password.\r\n-    \"\"\"\r\n-    try:\r\n-        driver.get('https://www.dice.com/dashboard/login')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the email field to be present\r\n-        email_field = wait.until(EC.presence_of_element_located((By.NAME, 'email')))\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        print('Entered email.')\r\n-\r\n-        # Locate and click the \"Continue\" button\r\n-        continue_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"sign-in-button\")]')\r\n-        continue_button.click()\r\n-        print('Clicked \"Continue\" button.')\r\n-\r\n-        # Wait for the password field to be present\r\n-        password_field = wait.until(EC.presence_of_element_located((By.NAME, 'password')))\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        print('Entered password.')\r\n-\r\n-        # Locate and click the \"Sign In\" button\r\n-        sign_in_button = driver.find_element(By.XPATH, '//button[contains(@data-testid, \"submit-password\")]')\r\n-        sign_in_button.click()\r\n-        print('Clicked \"Sign In\" button.')\r\n-\r\n-        # Wait until dashboard loads by checking URL or a specific element\r\n-        wait.until(EC.url_contains('/dashboard'))\r\n-        print(\"Successfully logged into Dice.\")\r\n-\r\n-        # Save cookies after successful login\r\n-        cookies = driver.get_cookies()\r\n-\r\n-        # Reapply cookies if needed\r\n-        for cookie in cookies:\r\n-            driver.add_cookie(cookie)\r\n-\r\n-        # Verify session persistence by checking if we're still on the dashboard\r\n-        driver.get('https://www.dice.com/dashboard')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f\"Error during login: {e}\")\r\n-        capture_screenshot('login_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-    except WebDriverException as e:\r\n-        print(f\"Unexpected redirection or logout: {e}\")\r\n-        capture_screenshot('login_redirection_error', subfolder='login')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def handle_login_modal():\r\n-    \"\"\"\r\n-    Handles the login modal that appears after clicking \"Apply now\".\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)\r\n-        print(\"Checking if login modal is present.\")\r\n-\r\n-        # Wait for the modal dialog to be present\r\n-        modal_dialog = wait.until(EC.presence_of_element_located((By.XPATH, '//dialog')))\r\n-        print(f\"Modal dialog detected: {modal_dialog}\")\r\n-\r\n-        # Use the modal_dialog as the context for finding elements\r\n-        # Locate the email field within the dialog\r\n-        email_field = modal_dialog.find_element(By.ID, 'username')\r\n-        print(\"Email field detected.\")\r\n-\r\n-        email_field.clear()\r\n-        email_field.send_keys(EMAIL)\r\n-        print(\"Entered email in modal.\")\r\n-\r\n-        # Locate the password field within the dialog\r\n-        password_field = modal_dialog.find_element(By.ID, 'password')\r\n-        print(\"Password field detected.\")\r\n-\r\n-        password_field.clear()\r\n-        password_field.send_keys(PASSWORD)\r\n-        print(\"Entered password in modal.\")\r\n-\r\n-        # Locate the login button within the dialog\r\n-        login_button = modal_dialog.find_element(By.XPATH, './/login-dhi-button[@data-cy=\"login-submit\"]//button')\r\n-        print(\"Log in button detected.\")\r\n-\r\n-        # Click the login button\r\n-        login_button.click()\r\n-        print(\"Clicked 'Log in' button in modal.\")\r\n-\r\n-        # Wait for the modal to disappear (indicating successful login)\r\n-        wait.until(EC.invisibility_of_element_located((By.XPATH, '//dialog')))\r\n-        print(\"Successfully logged in via modal.\")\r\n-\r\n-    except TimeoutException:\r\n-        print(\"Login modal did not appear as expected.\")\r\n-        capture_screenshot('login_modal_missing', subfolder='login')\r\n-    except NoSuchElementException as e:\r\n-        print(f\"Error finding login modal elements: {e}\")\r\n-        capture_screenshot('login_modal_element_not_found', subfolder='login')\r\n-    except Exception as e:\r\n-        print(f\"An unexpected error occurred while handling the login modal: {e}\")\r\n-        capture_screenshot('login_modal_unexpected_error', subfolder='login')\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        print('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        print('Filters widget located.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                print('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def has_apply_now(driver):\r\n-    print(\"Entering `has_apply_now` function\")  # Debugging print\r\n-    try:\r\n-        # Locate the shadow host element\r\n-        shadow_host = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        print(\"Shadow host element found\")  # Debugging print\r\n-\r\n-        # Access the shadow root\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', shadow_host)\r\n-        print(\"Shadow root accessed\")  # Debugging print\r\n-\r\n-        # Locate the 'Easy Apply' button within the shadow root\r\n+        # Access the shadow root of the \"Easy Apply\" button\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', easy_apply_button)\r\n         apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        print(\"Easy Apply button found\")  # Debugging print\r\n+        print('Easy Apply button found')\r\n \r\n-        # Scroll the button into view before clicking\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", apply_now_button)\r\n-        time.sleep(1)  # Give time for scrolling animation\r\n-\r\n-        # Try clicking the button\r\n+        # Click the \"Easy Apply\" button\r\n         try:\r\n-            apply_now_button.click()  # Attempt to click the button\r\n-            print(\"Clicked 'Easy Apply' button using click method.\")  # Debugging print\r\n+            apply_now_button.click()\r\n+            print(\"Clicked 'Easy Apply' button.\")\r\n         except Exception as e:\r\n-            print(f\"Regular click failed: {e}, trying JavaScript click.\")\r\n+            print(f\"Click failed: {e}, trying JavaScript click.\")\r\n             driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")  # Debugging print\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n \r\n-        return True\r\n-    except NoSuchElementException as e:\r\n-        print(f\"NoSuchElementException: {str(e)} - Element not found.\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/screenshot_easy_apply_not_found.png')\r\n-        print(\"NoSuchElementException caught\")  # Debugging print\r\n-        return False\r\n-    except Exception as e:\r\n-        print(f\"An unexpected error occurred: {str(e)}\")\r\n-        driver.save_screenshot(f'screenshots/easy_apply_missing/unexpected_error.png')\r\n-        print(\"Unexpected exception caught\")  # Debugging print\r\n-        return False\r\n+        # Wait for navigation to the application page\r\n+        print('Waiting for navigation to the application page.')\r\n+        wait.until(EC.url_contains('/apply'))\r\n+        print('Navigated to application page.')\r\n \r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+        # Now on the application page, proceed with the application\r\n+        # Wait for the \"Next\" button to appear\r\n+        print('Waiting for \"Next\" button on the application page.')\r\n+        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n+        print('\"Next\" button found.')\r\n \r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+        # Click the \"Next\" button\r\n+        next_button.click()\r\n+        print('Clicked \"Next\" button.')\r\n \r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job using the \"Easy Apply\" option.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            print(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n+        # Wait for the resume upload field\r\n+        print('Waiting for resume upload field.')\r\n+        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, '//input[@type=\"file\"]')))\r\n+        print('Resume upload field found.')\r\n \r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        # Upload the resume\r\n+        upload_field.send_keys(RESUME_PATH)\r\n+        print(f'Uploaded resume for job: {job_title}')\r\n \r\n-        # Scroll the job card into view\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n+        # Wait for the \"Submit\" button to be clickable\r\n+        print('Waiting for \"Submit\" button.')\r\n+        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Submit\")]')))\r\n+        print('\"Submit\" button found.')\r\n \r\n-        # Click on the job title to open job details\r\n-        print(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+        # Click the \"Submit\" button\r\n+        submit_button.click()\r\n+        print(f\"Successfully applied to {job_title}\")\r\n \r\n-        # Wait until the title_element is clickable\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details panel to load\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # **NEW CODE**: Call `has_apply_now` to check for the \"Easy Apply\" button within the Shadow DOM\r\n-        if not has_apply_now(driver):\r\n-            print(f'\"Easy Apply\" button not found for job: {job_title}. Skipping application.')\r\n-            capture_screenshot(f'easy_apply_not_found_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return  # Exit if the button is not found\r\n-\r\n-        # Call handle_login_modal right after the apply button is clicked\r\n-        handle_login_modal()\r\n-\r\n-        # Continue with the application process...\r\n-        # Wait for the apply modal to appear\r\n-        print(f'Waiting for apply modal for job: {job_title}')\r\n-        try:\r\n-            modal = wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"apply-modal\")]')))\r\n-            print(f'Apply modal appeared for job: {job_title}')\r\n-        except TimeoutException:\r\n-            print(f'Apply modal did not appear for job: {job_title}')\r\n-            capture_screenshot(f'apply_modal_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the resume upload field to be present within the modal\r\n-        print(f'Locating resume upload field for job: {job_title}')\r\n-        try:\r\n-            upload_field = wait.until(EC.presence_of_element_located((By.XPATH, './/input[@type=\"file\"]')))\r\n-            upload_field.send_keys(RESUME_PATH)\r\n-            print(f'Uploaded resume for job: {job_title}')\r\n-        except TimeoutException:\r\n-            print(f'Resume upload field not found for job: {job_title}')\r\n-            capture_screenshot(f'resume_upload_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n-        # Wait for the 'Submit' button to be clickable and click it\r\n-        print(f'Locating \"Submit\" button for job: {job_title}')\r\n-        try:\r\n-            submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, './/button[contains(text(), \"Submit\")]')))\r\n-            submit_button.click()\r\n-            print(f\"Successfully applied to {job_title}\")\r\n-        except TimeoutException:\r\n-            print(f'\"Submit\" button not found or not clickable for job: {job_title}')\r\n-            capture_screenshot(f'submit_button_missing_{sanitize_title(job_title)}', subfolder='easy_apply_missing')\r\n-            return\r\n-\r\n         # Add the job to the set of applied jobs\r\n         applied_jobs.add(job_title)\r\n \r\n         # Close the new window or navigate back\r\n@@ -1485,9 +236,8 @@\n             print(f'Navigated back to job listings after processing {job_title}')\r\n \r\n     except (NoSuchElementException, TimeoutException) as e:\r\n         print(f'Error applying to \"{job_title}\": {e}')\r\n-\r\n         # Log available buttons and capture a screenshot\r\n         log_available_buttons(job_card, job_title)\r\n         capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n \r\n@@ -1508,9 +258,9 @@\n     try:\r\n         print('Navigating to Dice homepage.')\r\n         # Enter search criteria\r\n         driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout\r\n+        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n         print('Waiting for search field.')\r\n         search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n         search_field.clear()\r\n         search_field.send_keys(SEARCH_TERMS)\r\n@@ -1541,9 +291,8 @@\n                 print(f'Job {index}: Found title: {job_title}')\r\n \r\n             except NoSuchElementException:\r\n                 print(f'Job {index}: Title element not found.')\r\n-\r\n                 # Debugging: Print the outer HTML of the job card\r\n                 job_card_html = job_card.get_attribute('outerHTML')\r\n                 print(f'Job {index} HTML: {job_card_html}')\r\n                 capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n"
                },
                {
                    "date": 1726953681398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,11 +45,10 @@\n chrome_options.add_argument('--disable-extensions')\r\n chrome_options.add_argument('--ignore-certificate-errors')\r\n chrome_options.add_argument('--ignore-ssl-errors')\r\n \r\n-# Add options to use existing Chrome profile\r\n-# Replace 'YourUserName' with your actual username and adjust the path if necessary\r\n-chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\YourUserName\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n+# Add options to use your existing Chrome profile\r\n+chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n \r\n # Initialize the WebDriver\r\n try:\r\n@@ -97,8 +96,112 @@\n         print(f'Screenshot saved to {screenshot_path}')\r\n     except Exception as e:\r\n         print(f'Failed to capture screenshot \"{name}\": {e}')\r\n \r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        print('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        print('Filters widget located.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n def log_available_buttons(job_card, job_title):\r\n     \"\"\"\r\n     Logs all available buttons within a job card for debugging purposes.\r\n     \"\"\"\r\n@@ -114,13 +217,8 @@\n         print(f'Screenshot saved to {screenshot_path}')\r\n     except Exception as e:\r\n         print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n \r\n-def activate_easy_apply_filter():\r\n-    # [Your existing activate_easy_apply_filter function]\r\n-    # Ensure this function remains the same as before\r\n-    pass\r\n-\r\n def apply_to_job(job_card, job_title, applied_jobs):\r\n     \"\"\"\r\n     Attempts to apply to a job by handling the navigation to the application page.\r\n     \"\"\"\r\n"
                },
                {
                    "date": 1726955041870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,557 @@\n+import configparser\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)\\\r\n+ Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('--disable-extensions')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Add options to use your existing Chrome profile\r\n+chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n+chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n+except WebDriverException as e:\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n+    except Exception as e:\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        print('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        print('Filters widget located.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job by handling the navigation to the application page.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            print(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n+\r\n+        # Scroll the job card into view\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details page to load\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Locate and click the \"Easy Apply\" button\r\n+        print(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n+        easy_apply_button = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        driver.execute_script('arguments[0].scrollIntoView(true);', easy_apply_button)\r\n+        time.sleep(1)\r\n+\r\n+        # Access the shadow root of the \"Easy Apply\" button\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', easy_apply_button)\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        print('Easy Apply button found')\r\n+\r\n+        # Click the \"Easy Apply\" button\r\n+        try:\r\n+            apply_now_button.click()\r\n+            print(\"Clicked 'Easy Apply' button.\")\r\n+        except Exception as e:\r\n+            print(f\"Click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+\r\n+        # Wait for navigation to the application page\r\n+        print('Waiting for navigation to the application page.')\r\n+        wait.until(EC.url_contains('/apply'))\r\n+        print('Navigated to application page.')\r\n+\r\n+        # Now on the application page, proceed with the application\r\n+        # Wait for the \"Next\" button to appear\r\n+        print('Waiting for \"Next\" button on the application page.')\r\n+        next_button = wait.until(EC.element_to_be_clickable(\r\n+            (By.CSS_SELECTOR, 'button.btn-next')\r\n+        ))\r\n+        print('\"Next\" button found.')\r\n+\r\n+        # Click the \"Next\" button\r\n+        next_button.click()\r\n+        print('Clicked \"Next\" button.')\r\n+\r\n+        # Wait for the resume upload field\r\n+        print('Waiting for resume upload field.')\r\n+        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, '//input[@type=\"file\"]')))\r\n+        print('Resume upload field found.')\r\n+\r\n+        # Upload the resume\r\n+        upload_field.send_keys(RESUME_PATH)\r\n+        print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+        # Wait for the \"Submit\" button to be clickable\r\n+        print('Waiting for \"Submit\" button.')\r\n+        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Submit\")]')))\r\n+        print('\"Submit\" button found.')\r\n+\r\n+        # Click the \"Submit\" button\r\n+        submit_button.click()\r\n+        print(f\"Successfully applied to {job_title}\")\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job by handling the navigation to the application page.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            print(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n+\r\n+        # Scroll the job card into view\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details page to load\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Locate and click the \"Easy Apply\" button\r\n+        print(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n+        easy_apply_button = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        driver.execute_script('arguments[0].scrollIntoView(true);', easy_apply_button)\r\n+        time.sleep(1)\r\n+\r\n+        # Access the shadow root of the \"Easy Apply\" button\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', easy_apply_button)\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        print('Easy Apply button found')\r\n+\r\n+        # Click the \"Easy Apply\" button\r\n+        try:\r\n+            apply_now_button.click()\r\n+            print(\"Clicked 'Easy Apply' button.\")\r\n+        except Exception as e:\r\n+            print(f\"Click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+\r\n+        # Wait for navigation to the application page\r\n+        print('Waiting for navigation to the application page.')\r\n+        wait.until(EC.url_contains('/apply'))\r\n+        print('Navigated to application page.')\r\n+\r\n+        # Now on the application page, proceed with the application\r\n+        # Wait for the \"Next\" button to appear\r\n+        print('Waiting for \"Next\" button on the application page.')\r\n+        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n+        print('\"Next\" button found.')\r\n+\r\n+        # Click the \"Next\" button\r\n+        next_button.click()\r\n+        print('Clicked \"Next\" button.')\r\n+\r\n+        # Wait for the resume upload field\r\n+        print('Waiting for resume upload field.')\r\n+        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, '//input[@type=\"file\"]')))\r\n+        print('Resume upload field found.')\r\n+\r\n+        # Upload the resume\r\n+        upload_field.send_keys(RESUME_PATH)\r\n+        print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+        # Wait for the \"Submit\" button to be clickable\r\n+        print('Waiting for \"Submit\" button.')\r\n+        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Submit\")]')))\r\n+        print('\"Submit\" button found.')\r\n+\r\n+        # Click the \"Submit\" button\r\n+        submit_button.click()\r\n+        print(f\"Successfully applied to {job_title}\")\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    try:\r\n+        print('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n+        print('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        print('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        print('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                print(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                print(f'Job {index}: Title element not found.')\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726956973025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -303,20 +303,19 @@\n         # Click the \"Next\" button\r\n         next_button.click()\r\n         print('Clicked \"Next\" button.')\r\n \r\n-        # Wait for the resume upload field\r\n-        print('Waiting for resume upload field.')\r\n-        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, '//input[@type=\"file\"]')))\r\n-        print('Resume upload field found.')\r\n+        # **Updated Code Starts Here**\r\n+        # Wait for the URL to update to '/apply/submit'\r\n+        print('Waiting for URL to update to \"/apply/submit\".')\r\n+        wait.until(EC.url_contains('/apply/submit'))\r\n+        print('URL updated to \"/apply/submit\".')\r\n \r\n-        # Upload the resume\r\n-        upload_field.send_keys(RESUME_PATH)\r\n-        print(f'Uploaded resume for job: {job_title}')\r\n-\r\n         # Wait for the \"Submit\" button to be clickable\r\n-        print('Waiting for \"Submit\" button.')\r\n-        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Submit\")]')))\r\n+        print('Waiting for \"Submit\" button on the application page.')\r\n+        submit_button = wait.until(EC.element_to_be_clickable(\r\n+            (By.CSS_SELECTOR, 'button.btn-next')\r\n+        ))\r\n         print('\"Submit\" button found.')\r\n \r\n         # Click the \"Submit\" button\r\n         submit_button.click()\r\n@@ -427,9 +426,11 @@\n \r\n         # Now on the application page, proceed with the application\r\n         # Wait for the \"Next\" button to appear\r\n         print('Waiting for \"Next\" button on the application page.')\r\n-        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n+        next_button = wait.until(EC.element_to_be_clickable(\r\n+            (By.CSS_SELECTOR, 'button.btn-next')\r\n+        ))\r\n         print('\"Next\" button found.')\r\n \r\n         # Click the \"Next\" button\r\n         next_button.click()\r\n@@ -482,302 +483,9 @@\n             driver.close()\r\n             driver.switch_to.window(original_window)\r\n             print(f'Closed new window and switched back to original window after processing {job_title}')\r\n \r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    try:\r\n-        print('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n-        print('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        print('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        print('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                print(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                print(f'Job {index}: Title element not found.')\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n-import configparser\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)\\\r\n- Chrome/91.0.4472.124 Safari/537.36')\r\n-chrome_options.add_argument('--disable-extensions')\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Add options to use your existing Chrome profile\r\n-chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n-chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-    print(\"Initialized Chrome WebDriver.\")\r\n-except WebDriverException as e:\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-print(\"Maximized browser window.\")\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n     \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-        print(f\"Created directory at path: {path}\")\r\n-    except Exception as e:\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        print('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        print('Filters widget located.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                print('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n     Attempts to apply to a job by handling the navigation to the application page.\r\n     \"\"\"\r\n     try:\r\n         if job_title in applied_jobs:\r\n"
                },
                {
                    "date": 1726957781725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,750 @@\n+import configparser\r\n+import time\r\n+import os\r\n+from selenium import webdriver\r\n+from selenium.webdriver.common.by import By\r\n+from selenium.webdriver.chrome.options import Options\r\n+from selenium.webdriver.common.action_chains import ActionChains\r\n+from selenium.common.exceptions import (\r\n+    NoSuchElementException,\r\n+    WebDriverException,\r\n+    TimeoutException,\r\n+    ElementClickInterceptedException,\r\n+    ElementNotInteractableException\r\n+)\r\n+from selenium.webdriver.support.ui import WebDriverWait\r\n+from selenium.webdriver.support import expected_conditions as EC\r\n+\r\n+# -----------------------------\r\n+# Configuration and Setup\r\n+# -----------------------------\r\n+\r\n+# Load configuration from config.ini\r\n+config = configparser.ConfigParser()\r\n+config.read('config.ini')\r\n+\r\n+SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n+RESUME_PATH = config['DEFAULT']['ResumePath']\r\n+PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n+EMAIL = config['DEFAULT']['Email']\r\n+PASSWORD = config['DEFAULT']['Password']\r\n+\r\n+# Validate Resume Path\r\n+if not os.path.isfile(RESUME_PATH):\r\n+    print(f'Resume file not found at path: {RESUME_PATH}')\r\n+    exit(1)\r\n+\r\n+# Set up Chrome options\r\n+chrome_options = Options()\r\n+# Uncomment the following line to run the browser in headless mode\r\n+# chrome_options.add_argument('--headless')\r\n+\r\n+# Optional: Ignore SSL certificate errors (Use with caution)\r\n+chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)\\\r\n+ Chrome/91.0.4472.124 Safari/537.36')\r\n+chrome_options.add_argument('--disable-extensions')\r\n+chrome_options.add_argument('--ignore-certificate-errors')\r\n+chrome_options.add_argument('--ignore-ssl-errors')\r\n+\r\n+# Add options to use your existing Chrome profile\r\n+chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n+chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n+\r\n+# Initialize the WebDriver\r\n+try:\r\n+    driver = webdriver.Chrome(options=chrome_options)\r\n+    print(\"Initialized Chrome WebDriver.\")\r\n+except WebDriverException as e:\r\n+    print(f'Error initializing Chrome WebDriver: {e}')\r\n+    exit(1)\r\n+\r\n+# Maximize browser window\r\n+driver.maximize_window()\r\n+print(\"Maximized browser window.\")\r\n+\r\n+# -----------------------------\r\n+# Utility Functions\r\n+# -----------------------------\r\n+\r\n+def sanitize_title(title):\r\n+    \"\"\"\r\n+    Sanitizes the job title to create a safe filename.\r\n+    \"\"\"\r\n+    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n+\r\n+def create_directory(path):\r\n+    \"\"\"\r\n+    Creates a directory if it doesn't exist.\r\n+    \"\"\"\r\n+    try:\r\n+        os.makedirs(path, exist_ok=True)\r\n+        print(f\"Created directory at path: {path}\")\r\n+    except Exception as e:\r\n+        print(f'Failed to create directory {path}: {e}')\r\n+\r\n+def capture_screenshot(name, subfolder='general'):\r\n+    \"\"\"\r\n+    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n+    \"\"\"\r\n+    try:\r\n+        timestamp = int(time.time())\r\n+        screenshots_dir = os.path.join('screenshots', subfolder)\r\n+        create_directory(screenshots_dir)\r\n+        sanitized_name = sanitize_title(name)\r\n+        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n+\r\n+# -----------------------------\r\n+# Function Definitions\r\n+# -----------------------------\r\n+\r\n+def activate_easy_apply_filter():\r\n+    \"\"\"\r\n+    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n+    Ensures that the filter button is clickable and not obscured by overlays.\r\n+    \"\"\"\r\n+    try:\r\n+        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n+\r\n+        # Wait for the filters widget to load\r\n+        print('Waiting for filters widget.')\r\n+        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n+        print('Filters widget located.')\r\n+\r\n+        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" accordion.')\r\n+            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n+                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n+            )\r\n+            print('\"Easy Apply\" accordion located.')\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" accordion not found within filters widget.')\r\n+            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Scroll the \"Easy Apply\" accordion into view\r\n+        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n+        try:\r\n+            print('Locating \"Easy Apply\" filter button.')\r\n+            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n+                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n+            )\r\n+            print('\"Easy Apply\" filter button located.')\r\n+        except NoSuchElementException:\r\n+            print('\"Easy Apply\" filter button not found within accordion.')\r\n+            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Wait until the \"Easy Apply\" filter button is clickable\r\n+        try:\r\n+            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n+            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n+                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n+            )\r\n+        except TimeoutException:\r\n+            print('\"Easy Apply\" filter button is not clickable.')\r\n+            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n+            driver.quit()\r\n+            exit(1)\r\n+\r\n+        # Check if the \"Easy Apply\" filter is already active\r\n+        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n+        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n+\r\n+        if aria_checked == 'true':\r\n+            print('\"Easy Apply\" filter is already active.')\r\n+        else:\r\n+            # Click using ActionChains to ensure the element is in view\r\n+            try:\r\n+                print('Attempting to click \"Easy Apply\" filter button.')\r\n+                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n+            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n+                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n+\r\n+            print('\"Easy Apply\" filter activated.')\r\n+            # Wait for the page to refresh after applying the filter\r\n+            time.sleep(3)  # Adjust as needed based on network speed\r\n+\r\n+        # Verify that the URL contains the required parameters\r\n+        current_url = driver.current_url\r\n+        expected_params = 'filters.easyApply=true'\r\n+        if expected_params not in current_url:\r\n+            print(f'URL does not contain expected parameters: {expected_params}')\r\n+            # Optionally, navigate to the correct URL directly\r\n+            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n+            # Wait for job listings to load\r\n+            wait.until(EC.presence_of_all_elements_located(\r\n+                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+            ))\r\n+            print('Navigated to filtered URL.')\r\n+        else:\r\n+            print('URL contains the expected filter parameters.')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n+        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+    except Exception as e:\r\n+        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n+        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n+        driver.quit()\r\n+        exit(1)\r\n+\r\n+def log_available_buttons(job_card, job_title):\r\n+    \"\"\"\r\n+    Logs all available buttons within a job card for debugging purposes.\r\n+    \"\"\"\r\n+    try:\r\n+        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n+        button_texts = [button.text for button in buttons]\r\n+        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n+\r\n+        # Capture a screenshot for visual debugging\r\n+        sanitized_title = sanitize_title(job_title)\r\n+        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n+        driver.save_screenshot(screenshot_path)\r\n+        print(f'Screenshot saved to {screenshot_path}')\r\n+    except Exception as e:\r\n+        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n+\r\n+def apply_to_job(job_card, job_title, applied_jobs):\r\n+    \"\"\"\r\n+    Attempts to apply to a job by handling the navigation to the application page.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            print(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n+\r\n+        # Scroll the job card into view\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details page to load\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Locate and click the \"Easy Apply\" button\r\n+        print(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n+        easy_apply_button = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        driver.execute_script('arguments[0].scrollIntoView(true);', easy_apply_button)\r\n+        time.sleep(1)\r\n+\r\n+        # Access the shadow root of the \"Easy Apply\" button\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', easy_apply_button)\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        print('Easy Apply button found')\r\n+\r\n+        # Click the \"Easy Apply\" button\r\n+        try:\r\n+            apply_now_button.click()\r\n+            print(\"Clicked 'Easy Apply' button.\")\r\n+        except Exception as e:\r\n+            print(f\"Click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+\r\n+        # Wait for navigation to the application page\r\n+        print('Waiting for navigation to the application page.')\r\n+        wait.until(EC.url_contains('/apply'))\r\n+        print('Navigated to application page.')\r\n+\r\n+        # Now on the application page, proceed with the application\r\n+        # Wait for the \"Next\" button to appear\r\n+        print('Waiting for \"Next\" button on the application page.')\r\n+        next_button = wait.until(EC.element_to_be_clickable(\r\n+            (By.CSS_SELECTOR, 'button.btn-next')\r\n+        ))\r\n+        print('\"Next\" button found.')\r\n+\r\n+        # Click the \"Next\" button\r\n+        next_button.click()\r\n+        print('Clicked \"Next\" button.')\r\n+\r\n+        # **Updated Code Starts Here**\r\n+        # Wait for the URL to update to '/apply/submit'\r\n+        print('Waiting for URL to update to \"/apply/submit\".')\r\n+        wait.until(EC.url_contains('/apply/submit'))\r\n+        print('URL updated to \"/apply/submit\".')\r\n+\r\n+        # Wait for the \"Submit\" button to be clickable\r\n+        print('Waiting for \"Submit\" button on the application page.')\r\n+        submit_button = wait.until(EC.element_to_be_clickable(\r\n+            (By.CSS_SELECTOR, 'button.btn-next')\r\n+        ))\r\n+        print('\"Submit\" button found.')\r\n+\r\n+        # Click the \"Submit\" button\r\n+        submit_button.click()\r\n+        print(f\"Successfully applied to {job_title}\")\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job by handling the navigation to the application page.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            print(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n+\r\n+        # Scroll the job card into view\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details page to load\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Locate and click the \"Easy Apply\" button\r\n+        print(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n+        easy_apply_button = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        driver.execute_script('arguments[0].scrollIntoView(true);', easy_apply_button)\r\n+        time.sleep(1)\r\n+\r\n+        # Access the shadow root of the \"Easy Apply\" button\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', easy_apply_button)\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        print('Easy Apply button found')\r\n+\r\n+        # Click the \"Easy Apply\" button\r\n+        try:\r\n+            apply_now_button.click()\r\n+            print(\"Clicked 'Easy Apply' button.\")\r\n+        except Exception as e:\r\n+            print(f\"Click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+\r\n+        # Wait for navigation to the application page\r\n+        print('Waiting for navigation to the application page.')\r\n+        wait.until(EC.url_contains('/apply'))\r\n+        print('Navigated to application page.')\r\n+\r\n+        # Now on the application page, proceed with the application\r\n+        # Wait for the \"Next\" button to appear\r\n+        print('Waiting for \"Next\" button on the application page.')\r\n+        next_button = wait.until(EC.element_to_be_clickable(\r\n+            (By.CSS_SELECTOR, 'button.btn-next')\r\n+        ))\r\n+        print('\"Next\" button found.')\r\n+\r\n+        # Click the \"Next\" button\r\n+        next_button.click()\r\n+        print('Clicked \"Next\" button.')\r\n+\r\n+        # Wait for the resume upload field\r\n+        print('Waiting for resume upload field.')\r\n+        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, '//input[@type=\"file\"]')))\r\n+        print('Resume upload field found.')\r\n+\r\n+        # Upload the resume\r\n+        upload_field.send_keys(RESUME_PATH)\r\n+        print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+        # Wait for the \"Submit\" button to be clickable\r\n+        print('Waiting for \"Submit\" button.')\r\n+        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Submit\")]')))\r\n+        print('\"Submit\" button found.')\r\n+\r\n+        # Click the \"Submit\" button\r\n+        submit_button.click()\r\n+        print(f\"Successfully applied to {job_title}\")\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+    \"\"\"\r\n+    Attempts to apply to a job by handling the navigation to the application page.\r\n+    \"\"\"\r\n+    try:\r\n+        if job_title in applied_jobs:\r\n+            print(f'Skipping already applied job: {job_title}')\r\n+            return  # Skip if we've already applied to this job\r\n+\r\n+        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n+\r\n+        # Scroll the job card into view\r\n+        print(f'Scrolling into view for job: {job_title}')\r\n+        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n+        time.sleep(1)  # Wait for scrolling animation\r\n+\r\n+        # Click on the job title to open job details\r\n+        print(f'Locating job title link for: {job_title}')\r\n+        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+\r\n+        # Wait until the title_element is clickable\r\n+        print(f'Waiting for job title to be clickable for: {job_title}')\r\n+        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n+\r\n+        try:\r\n+            print(f'Attempting to click on job title: {job_title}')\r\n+            title_element.click()\r\n+            print(f'Clicked on job title: {job_title}')\r\n+        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n+            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n+            driver.execute_script(\"arguments[0].click();\", title_element)\r\n+\r\n+        # Check if a new window has been opened\r\n+        original_window = driver.current_window_handle\r\n+        windows_after_click = driver.window_handles\r\n+        if len(windows_after_click) > 1:\r\n+            new_window = [window for window in windows_after_click if window != original_window][0]\r\n+            driver.switch_to.window(new_window)\r\n+            print(f'Switched to new window for job: {job_title}')\r\n+        else:\r\n+            # Job details opened in the same window\r\n+            print(f'Job details opened in the same window for job: {job_title}')\r\n+\r\n+        # Wait for the job details page to load\r\n+        print(f'Waiting for job details to load for: {job_title}')\r\n+        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n+        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n+        print(f'Job details loaded for: {job_title}')\r\n+\r\n+        # Locate and click the \"Easy Apply\" button\r\n+        print(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n+        easy_apply_button = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n+        driver.execute_script('arguments[0].scrollIntoView(true);', easy_apply_button)\r\n+        time.sleep(1)\r\n+\r\n+        # Access the shadow root of the \"Easy Apply\" button\r\n+        shadow_root = driver.execute_script('return arguments[0].shadowRoot', easy_apply_button)\r\n+        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n+        print('Easy Apply button found')\r\n+\r\n+        # Click the \"Easy Apply\" button\r\n+        try:\r\n+            apply_now_button.click()\r\n+            print(\"Clicked 'Easy Apply' button.\")\r\n+        except Exception as e:\r\n+            print(f\"Click failed: {e}, trying JavaScript click.\")\r\n+            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n+            print(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n+\r\n+        # Wait for navigation to the application page\r\n+        print('Waiting for navigation to the application page.')\r\n+        wait.until(EC.url_contains('/apply'))\r\n+        print('Navigated to application page.')\r\n+\r\n+        # Now on the application page, proceed with the application\r\n+        # Wait for the \"Next\" button to appear\r\n+        print('Waiting for \"Next\" button on the application page.')\r\n+        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n+        print('\"Next\" button found.')\r\n+\r\n+        # Click the \"Next\" button\r\n+        next_button.click()\r\n+        print('Clicked \"Next\" button.')\r\n+\r\n+        # Wait for the resume upload field\r\n+        print('Waiting for resume upload field.')\r\n+        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, '//input[@type=\"file\"]')))\r\n+        print('Resume upload field found.')\r\n+\r\n+        # Upload the resume\r\n+        upload_field.send_keys(RESUME_PATH)\r\n+        print(f'Uploaded resume for job: {job_title}')\r\n+\r\n+        # Wait for the \"Submit\" button to be clickable\r\n+        print('Waiting for \"Submit\" button.')\r\n+        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Submit\")]')))\r\n+        print('\"Submit\" button found.')\r\n+\r\n+        # Click the \"Submit\" button\r\n+        submit_button.click()\r\n+        print(f\"Successfully applied to {job_title}\")\r\n+\r\n+        # Add the job to the set of applied jobs\r\n+        applied_jobs.add(job_title)\r\n+\r\n+        # Close the new window or navigate back\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+        else:\r\n+            # Navigate back to the job listings page\r\n+            driver.back()\r\n+            print(f'Navigated back to job listings after processing {job_title}')\r\n+\r\n+    except (NoSuchElementException, TimeoutException) as e:\r\n+        print(f'Error applying to \"{job_title}\": {e}')\r\n+        # Log available buttons and capture a screenshot\r\n+        log_available_buttons(job_card, job_title)\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    except Exception as e:\r\n+        print(f'Failed to apply to \"{job_title}\": {e}')\r\n+        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n+\r\n+    finally:\r\n+        # Ensure that any new window is closed and focus is back to the original window\r\n+        if len(driver.window_handles) > 1:\r\n+            driver.close()\r\n+            driver.switch_to.window(original_window)\r\n+            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n+\r\n+def main():\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    try:\r\n+        print('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n+        print('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        print('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        print('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                print(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                print(f'Job {index}: Title element not found.')\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Apply to the job without any conditions\r\n+            print(f'Applying to job: {job_title}')\r\n+            apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+            # Pause for specified duration before the next application\r\n+            print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+            time.sleep(PAUSE_DURATION)\r\n+\r\n+        print(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+    applied_jobs = set()  # Track jobs that have been applied to\r\n+\r\n+    try:\r\n+        print('Navigating to Dice homepage.')\r\n+        # Enter search criteria\r\n+        driver.get('https://www.dice.com/')\r\n+        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n+        print('Waiting for search field.')\r\n+        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n+        search_field.clear()\r\n+        search_field.send_keys(SEARCH_TERMS)\r\n+        print(f'Entered search terms: {SEARCH_TERMS}')\r\n+\r\n+        print('Locating search button.')\r\n+        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n+        search_button.click()\r\n+        print('Clicked search button.')\r\n+\r\n+        # Activate the \"Easy Apply\" filter\r\n+        activate_easy_apply_filter()\r\n+\r\n+        # Wait for job listings to load\r\n+        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n+\r\n+        # Get the list of job postings\r\n+        print('Locating job cards.')\r\n+        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n+        print(f'Found {len(job_cards)} job postings.')\r\n+\r\n+        for index, job_card in enumerate(job_cards, start=1):\r\n+            try:\r\n+                # Extract the job title using data-cy attribute\r\n+                print(f'Processing job {index}.')\r\n+                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n+                job_title = title_element.text.strip()\r\n+                print(f'Job {index}: Found title: {job_title}')\r\n+\r\n+            except NoSuchElementException:\r\n+                print(f'Job {index}: Title element not found.')\r\n+                # Debugging: Print the outer HTML of the job card\r\n+                job_card_html = job_card.get_attribute('outerHTML')\r\n+                print(f'Job {index} HTML: {job_card_html}')\r\n+                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n+                continue\r\n+\r\n+            print(f'Job {index}: Title=\"{job_title}\"')\r\n+\r\n+            # Simplified criteria for applying\r\n+            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n+                print(f'Applying to job: {job_title}')\r\n+                apply_to_job(job_card, job_title, applied_jobs)\r\n+\r\n+                # Pause for specified duration before the next application\r\n+                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n+                time.sleep(PAUSE_DURATION)\r\n+            else:\r\n+                print(f\"Skipping job: {job_title}\")\r\n+\r\n+        print(\"Job application process completed.\")\r\n+    except Exception as e:\r\n+        print(f\"An error occurred in main(): {e}\")\r\n+        capture_screenshot('main_exception', subfolder='main_errors')\r\n+    finally:\r\n+        driver.quit()\r\n+\r\n+# -----------------------------\r\n+# Entry Point\r\n+# -----------------------------\r\n+\r\n+if __name__ == '__main__':\r\n+    main()\r\n"
                },
                {
                    "date": 1726957852970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -676,8 +676,9 @@\n         print(f\"An error occurred in main(): {e}\")\r\n         capture_screenshot('main_exception', subfolder='main_errors')\r\n     finally:\r\n         driver.quit()\r\n+        \r\n     applied_jobs = set()  # Track jobs that have been applied to\r\n \r\n     try:\r\n         print('Navigating to Dice homepage.')\r\n@@ -747,693 +748,4 @@\n # -----------------------------\r\n \r\n if __name__ == '__main__':\r\n     main()\r\n-import configparser\r\n-import time\r\n-import os\r\n-from selenium import webdriver\r\n-from selenium.webdriver.common.by import By\r\n-from selenium.webdriver.chrome.options import Options\r\n-from selenium.webdriver.common.action_chains import ActionChains\r\n-from selenium.common.exceptions import (\r\n-    NoSuchElementException,\r\n-    WebDriverException,\r\n-    TimeoutException,\r\n-    ElementClickInterceptedException,\r\n-    ElementNotInteractableException\r\n-)\r\n-from selenium.webdriver.support.ui import WebDriverWait\r\n-from selenium.webdriver.support import expected_conditions as EC\r\n-\r\n-# -----------------------------\r\n-# Configuration and Setup\r\n-# -----------------------------\r\n-\r\n-# Load configuration from config.ini\r\n-config = configparser.ConfigParser()\r\n-config.read('config.ini')\r\n-\r\n-SEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\n-RESUME_PATH = config['DEFAULT']['ResumePath']\r\n-PAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\n-EMAIL = config['DEFAULT']['Email']\r\n-PASSWORD = config['DEFAULT']['Password']\r\n-\r\n-# Validate Resume Path\r\n-if not os.path.isfile(RESUME_PATH):\r\n-    print(f'Resume file not found at path: {RESUME_PATH}')\r\n-    exit(1)\r\n-\r\n-# Set up Chrome options\r\n-chrome_options = Options()\r\n-# Uncomment the following line to run the browser in headless mode\r\n-# chrome_options.add_argument('--headless')\r\n-\r\n-# Optional: Ignore SSL certificate errors (Use with caution)\r\n-chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)\\\r\n- Chrome/91.0.4472.124 Safari/537.36')\r\n-chrome_options.add_argument('--disable-extensions')\r\n-chrome_options.add_argument('--ignore-certificate-errors')\r\n-chrome_options.add_argument('--ignore-ssl-errors')\r\n-\r\n-# Add options to use your existing Chrome profile\r\n-chrome_options.add_argument(\"user-data-dir=C:\\\\Users\\\\d33psp33d\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User Data\")\r\n-chrome_options.add_argument(\"profile-directory=Default\")  # Or the name of your profile directory\r\n-\r\n-# Initialize the WebDriver\r\n-try:\r\n-    driver = webdriver.Chrome(options=chrome_options)\r\n-    print(\"Initialized Chrome WebDriver.\")\r\n-except WebDriverException as e:\r\n-    print(f'Error initializing Chrome WebDriver: {e}')\r\n-    exit(1)\r\n-\r\n-# Maximize browser window\r\n-driver.maximize_window()\r\n-print(\"Maximized browser window.\")\r\n-\r\n-# -----------------------------\r\n-# Utility Functions\r\n-# -----------------------------\r\n-\r\n-def sanitize_title(title):\r\n-    \"\"\"\r\n-    Sanitizes the job title to create a safe filename.\r\n-    \"\"\"\r\n-    return \"\".join(c for c in title if c.isalnum() or c in (' ', '_')).rstrip().replace(\" \", \"_\")\r\n-\r\n-def create_directory(path):\r\n-    \"\"\"\r\n-    Creates a directory if it doesn't exist.\r\n-    \"\"\"\r\n-    try:\r\n-        os.makedirs(path, exist_ok=True)\r\n-        print(f\"Created directory at path: {path}\")\r\n-    except Exception as e:\r\n-        print(f'Failed to create directory {path}: {e}')\r\n-\r\n-def capture_screenshot(name, subfolder='general'):\r\n-    \"\"\"\r\n-    Captures a screenshot with the given name and saves it in the specified subfolder.\r\n-    \"\"\"\r\n-    try:\r\n-        timestamp = int(time.time())\r\n-        screenshots_dir = os.path.join('screenshots', subfolder)\r\n-        create_directory(screenshots_dir)\r\n-        sanitized_name = sanitize_title(name)\r\n-        screenshot_path = os.path.join(screenshots_dir, f'screenshot_{sanitized_name}_{timestamp}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        print(f'Failed to capture screenshot \"{name}\": {e}')\r\n-\r\n-# -----------------------------\r\n-# Function Definitions\r\n-# -----------------------------\r\n-\r\n-def activate_easy_apply_filter():\r\n-    \"\"\"\r\n-    Activates the \"Easy Apply\" filter to focus on jobs that offer this option.\r\n-    Ensures that the filter button is clickable and not obscured by overlays.\r\n-    \"\"\"\r\n-    try:\r\n-        wait = WebDriverWait(driver, 20)  # Increased timeout for dynamic content\r\n-\r\n-        # Wait for the filters widget to load\r\n-        print('Waiting for filters widget.')\r\n-        filters_widget = wait.until(EC.presence_of_element_located((By.TAG_NAME, 'dhi-filters-widget')))\r\n-        print('Filters widget located.')\r\n-\r\n-        # Locate the \"Easy Apply\" accordion within the filters widget using CSS Selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" accordion.')\r\n-            easy_apply_accordion = WebDriverWait(filters_widget, 20).until(\r\n-                EC.presence_of_element_located((By.CSS_SELECTOR, 'dhi-accordion[data-cy=\"accordion-easyApply\"]'))\r\n-            )\r\n-            print('\"Easy Apply\" accordion located.')\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" accordion not found within filters widget.')\r\n-            capture_screenshot('missing_easy_apply_accordion', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Scroll the \"Easy Apply\" accordion into view\r\n-        driver.execute_script(\"arguments[0].scrollIntoView(true);\", easy_apply_accordion)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Locate the filter button within the \"Easy Apply\" accordion using a more precise selector\r\n-        try:\r\n-            print('Locating \"Easy Apply\" filter button.')\r\n-            easy_apply_filter_button = easy_apply_accordion.find_element(\r\n-                By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'\r\n-            )\r\n-            print('\"Easy Apply\" filter button located.')\r\n-        except NoSuchElementException:\r\n-            print('\"Easy Apply\" filter button not found within accordion.')\r\n-            capture_screenshot('missing_easy_apply_filter_button', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Wait until the \"Easy Apply\" filter button is clickable\r\n-        try:\r\n-            print('Waiting for \"Easy Apply\" filter button to be clickable.')\r\n-            easy_apply_filter_button = WebDriverWait(driver, 20).until(\r\n-                EC.element_to_be_clickable((By.XPATH, './/js-single-select-filter[@data-cy=\"filter-easyApply\"]//button[@aria-label=\"Filter Search Results by Easy Apply\"]'))\r\n-            )\r\n-        except TimeoutException:\r\n-            print('\"Easy Apply\" filter button is not clickable.')\r\n-            capture_screenshot('easy_apply_not_clickable', subfolder='filters')\r\n-            driver.quit()\r\n-            exit(1)\r\n-\r\n-        # Check if the \"Easy Apply\" filter is already active\r\n-        aria_checked = easy_apply_filter_button.get_attribute('aria-checked')\r\n-        print(f'\"Easy Apply\" aria-checked: {aria_checked}')\r\n-\r\n-        if aria_checked == 'true':\r\n-            print('\"Easy Apply\" filter is already active.')\r\n-        else:\r\n-            # Click using ActionChains to ensure the element is in view\r\n-            try:\r\n-                print('Attempting to click \"Easy Apply\" filter button.')\r\n-                ActionChains(driver).move_to_element(easy_apply_filter_button).click().perform()\r\n-            except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-                print(f'\"Easy Apply\" filter button not interactable: {e}. Attempting JavaScript click.')\r\n-                driver.execute_script(\"arguments[0].click();\", easy_apply_filter_button)\r\n-\r\n-            print('\"Easy Apply\" filter activated.')\r\n-            # Wait for the page to refresh after applying the filter\r\n-            time.sleep(3)  # Adjust as needed based on network speed\r\n-\r\n-        # Verify that the URL contains the required parameters\r\n-        current_url = driver.current_url\r\n-        expected_params = 'filters.easyApply=true'\r\n-        if expected_params not in current_url:\r\n-            print(f'URL does not contain expected parameters: {expected_params}')\r\n-            # Optionally, navigate to the correct URL directly\r\n-            driver.get(f'https://www.dice.com/jobs?q={SEARCH_TERMS}&filters.easyApply=true')\r\n-            # Wait for job listings to load\r\n-            wait.until(EC.presence_of_all_elements_located(\r\n-                (By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-            ))\r\n-            print('Navigated to filtered URL.')\r\n-        else:\r\n-            print('URL contains the expected filter parameters.')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error activating \"Easy Apply\" filter: {e}')\r\n-        capture_screenshot('error_activating_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-    except Exception as e:\r\n-        print(f\"Unexpected error activating 'Easy Apply' filter: {e}\")\r\n-        capture_screenshot('unexpected_error_easy_apply_filter', subfolder='filters')\r\n-        driver.quit()\r\n-        exit(1)\r\n-\r\n-def log_available_buttons(job_card, job_title):\r\n-    \"\"\"\r\n-    Logs all available buttons within a job card for debugging purposes.\r\n-    \"\"\"\r\n-    try:\r\n-        buttons = job_card.find_elements(By.TAG_NAME, 'button')\r\n-        button_texts = [button.text for button in buttons]\r\n-        print(f'Available buttons for job \"{job_title}\": {button_texts}')\r\n-\r\n-        # Capture a screenshot for visual debugging\r\n-        sanitized_title = sanitize_title(job_title)\r\n-        screenshot_path = os.path.join('screenshots', 'missing_easy_apply', f'screenshot_job_{sanitized_title}.png')\r\n-        driver.save_screenshot(screenshot_path)\r\n-        print(f'Screenshot saved to {screenshot_path}')\r\n-    except Exception as e:\r\n-        print(f'Error logging available buttons for \"{job_title}\": {e}')\r\n-\r\n-def apply_to_job(job_card, job_title, applied_jobs):\r\n-    \"\"\"\r\n-    Attempts to apply to a job by handling the navigation to the application page.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            print(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n-\r\n-        # Scroll the job card into view\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        print(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details page to load\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Locate and click the \"Easy Apply\" button\r\n-        print(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n-        easy_apply_button = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        driver.execute_script('arguments[0].scrollIntoView(true);', easy_apply_button)\r\n-        time.sleep(1)\r\n-\r\n-        # Access the shadow root of the \"Easy Apply\" button\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', easy_apply_button)\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        print('Easy Apply button found')\r\n-\r\n-        # Click the \"Easy Apply\" button\r\n-        try:\r\n-            apply_now_button.click()\r\n-            print(\"Clicked 'Easy Apply' button.\")\r\n-        except Exception as e:\r\n-            print(f\"Click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n-\r\n-        # Wait for navigation to the application page\r\n-        print('Waiting for navigation to the application page.')\r\n-        wait.until(EC.url_contains('/apply'))\r\n-        print('Navigated to application page.')\r\n-\r\n-        # Now on the application page, proceed with the application\r\n-        # Wait for the \"Next\" button to appear\r\n-        print('Waiting for \"Next\" button on the application page.')\r\n-        next_button = wait.until(EC.element_to_be_clickable(\r\n-            (By.CSS_SELECTOR, 'button.btn-next')\r\n-        ))\r\n-        print('\"Next\" button found.')\r\n-\r\n-        # Click the \"Next\" button\r\n-        next_button.click()\r\n-        print('Clicked \"Next\" button.')\r\n-\r\n-        # **Updated Code Starts Here**\r\n-        # Wait for the URL to update to '/apply/submit'\r\n-        print('Waiting for URL to update to \"/apply/submit\".')\r\n-        wait.until(EC.url_contains('/apply/submit'))\r\n-        print('URL updated to \"/apply/submit\".')\r\n-\r\n-        # Wait for the \"Submit\" button to be clickable\r\n-        print('Waiting for \"Submit\" button on the application page.')\r\n-        submit_button = wait.until(EC.element_to_be_clickable(\r\n-            (By.CSS_SELECTOR, 'button.btn-next')\r\n-        ))\r\n-        print('\"Submit\" button found.')\r\n-\r\n-        # Click the \"Submit\" button\r\n-        submit_button.click()\r\n-        print(f\"Successfully applied to {job_title}\")\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job by handling the navigation to the application page.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            print(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n-\r\n-        # Scroll the job card into view\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        print(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details page to load\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Locate and click the \"Easy Apply\" button\r\n-        print(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n-        easy_apply_button = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        driver.execute_script('arguments[0].scrollIntoView(true);', easy_apply_button)\r\n-        time.sleep(1)\r\n-\r\n-        # Access the shadow root of the \"Easy Apply\" button\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', easy_apply_button)\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        print('Easy Apply button found')\r\n-\r\n-        # Click the \"Easy Apply\" button\r\n-        try:\r\n-            apply_now_button.click()\r\n-            print(\"Clicked 'Easy Apply' button.\")\r\n-        except Exception as e:\r\n-            print(f\"Click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n-\r\n-        # Wait for navigation to the application page\r\n-        print('Waiting for navigation to the application page.')\r\n-        wait.until(EC.url_contains('/apply'))\r\n-        print('Navigated to application page.')\r\n-\r\n-        # Now on the application page, proceed with the application\r\n-        # Wait for the \"Next\" button to appear\r\n-        print('Waiting for \"Next\" button on the application page.')\r\n-        next_button = wait.until(EC.element_to_be_clickable(\r\n-            (By.CSS_SELECTOR, 'button.btn-next')\r\n-        ))\r\n-        print('\"Next\" button found.')\r\n-\r\n-        # Click the \"Next\" button\r\n-        next_button.click()\r\n-        print('Clicked \"Next\" button.')\r\n-\r\n-        # Wait for the resume upload field\r\n-        print('Waiting for resume upload field.')\r\n-        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, '//input[@type=\"file\"]')))\r\n-        print('Resume upload field found.')\r\n-\r\n-        # Upload the resume\r\n-        upload_field.send_keys(RESUME_PATH)\r\n-        print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-        # Wait for the \"Submit\" button to be clickable\r\n-        print('Waiting for \"Submit\" button.')\r\n-        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Submit\")]')))\r\n-        print('\"Submit\" button found.')\r\n-\r\n-        # Click the \"Submit\" button\r\n-        submit_button.click()\r\n-        print(f\"Successfully applied to {job_title}\")\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-    \"\"\"\r\n-    Attempts to apply to a job by handling the navigation to the application page.\r\n-    \"\"\"\r\n-    try:\r\n-        if job_title in applied_jobs:\r\n-            print(f'Skipping already applied job: {job_title}')\r\n-            return  # Skip if we've already applied to this job\r\n-\r\n-        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n-\r\n-        # Scroll the job card into view\r\n-        print(f'Scrolling into view for job: {job_title}')\r\n-        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", job_card)\r\n-        time.sleep(1)  # Wait for scrolling animation\r\n-\r\n-        # Click on the job title to open job details\r\n-        print(f'Locating job title link for: {job_title}')\r\n-        title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-\r\n-        # Wait until the title_element is clickable\r\n-        print(f'Waiting for job title to be clickable for: {job_title}')\r\n-        wait.until(EC.element_to_be_clickable((By.XPATH, './/a[@data-cy=\"card-title-link\"]')))\r\n-\r\n-        try:\r\n-            print(f'Attempting to click on job title: {job_title}')\r\n-            title_element.click()\r\n-            print(f'Clicked on job title: {job_title}')\r\n-        except (ElementClickInterceptedException, ElementNotInteractableException) as e:\r\n-            print(f'Click intercepted or element not interactable for job title: {job_title}. Trying JavaScript click.')\r\n-            driver.execute_script(\"arguments[0].click();\", title_element)\r\n-\r\n-        # Check if a new window has been opened\r\n-        original_window = driver.current_window_handle\r\n-        windows_after_click = driver.window_handles\r\n-        if len(windows_after_click) > 1:\r\n-            new_window = [window for window in windows_after_click if window != original_window][0]\r\n-            driver.switch_to.window(new_window)\r\n-            print(f'Switched to new window for job: {job_title}')\r\n-        else:\r\n-            # Job details opened in the same window\r\n-            print(f'Job details opened in the same window for job: {job_title}')\r\n-\r\n-        # Wait for the job details page to load\r\n-        print(f'Waiting for job details to load for: {job_title}')\r\n-        wait.until(EC.presence_of_element_located((By.XPATH, '//div[contains(@class, \"job-details\")]')))\r\n-        time.sleep(2)  # Additional wait to ensure all elements are loaded\r\n-        print(f'Job details loaded for: {job_title}')\r\n-\r\n-        # Locate and click the \"Easy Apply\" button\r\n-        print(f'Locating \"Easy Apply\" button for job: {job_title}')\r\n-        easy_apply_button = driver.find_element(By.CSS_SELECTOR, 'apply-button-wc')\r\n-        driver.execute_script('arguments[0].scrollIntoView(true);', easy_apply_button)\r\n-        time.sleep(1)\r\n-\r\n-        # Access the shadow root of the \"Easy Apply\" button\r\n-        shadow_root = driver.execute_script('return arguments[0].shadowRoot', easy_apply_button)\r\n-        apply_now_button = shadow_root.find_element(By.CSS_SELECTOR, 'button.btn.btn-primary')\r\n-        print('Easy Apply button found')\r\n-\r\n-        # Click the \"Easy Apply\" button\r\n-        try:\r\n-            apply_now_button.click()\r\n-            print(\"Clicked 'Easy Apply' button.\")\r\n-        except Exception as e:\r\n-            print(f\"Click failed: {e}, trying JavaScript click.\")\r\n-            driver.execute_script(\"arguments[0].click();\", apply_now_button)\r\n-            print(\"Clicked 'Easy Apply' button using JavaScript.\")\r\n-\r\n-        # Wait for navigation to the application page\r\n-        print('Waiting for navigation to the application page.')\r\n-        wait.until(EC.url_contains('/apply'))\r\n-        print('Navigated to application page.')\r\n-\r\n-        # Now on the application page, proceed with the application\r\n-        # Wait for the \"Next\" button to appear\r\n-        print('Waiting for \"Next\" button on the application page.')\r\n-        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Next\")]')))\r\n-        print('\"Next\" button found.')\r\n-\r\n-        # Click the \"Next\" button\r\n-        next_button.click()\r\n-        print('Clicked \"Next\" button.')\r\n-\r\n-        # Wait for the resume upload field\r\n-        print('Waiting for resume upload field.')\r\n-        upload_field = wait.until(EC.presence_of_element_located((By.XPATH, '//input[@type=\"file\"]')))\r\n-        print('Resume upload field found.')\r\n-\r\n-        # Upload the resume\r\n-        upload_field.send_keys(RESUME_PATH)\r\n-        print(f'Uploaded resume for job: {job_title}')\r\n-\r\n-        # Wait for the \"Submit\" button to be clickable\r\n-        print('Waiting for \"Submit\" button.')\r\n-        submit_button = wait.until(EC.element_to_be_clickable((By.XPATH, '//button[contains(text(), \"Submit\")]')))\r\n-        print('\"Submit\" button found.')\r\n-\r\n-        # Click the \"Submit\" button\r\n-        submit_button.click()\r\n-        print(f\"Successfully applied to {job_title}\")\r\n-\r\n-        # Add the job to the set of applied jobs\r\n-        applied_jobs.add(job_title)\r\n-\r\n-        # Close the new window or navigate back\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-        else:\r\n-            # Navigate back to the job listings page\r\n-            driver.back()\r\n-            print(f'Navigated back to job listings after processing {job_title}')\r\n-\r\n-    except (NoSuchElementException, TimeoutException) as e:\r\n-        print(f'Error applying to \"{job_title}\": {e}')\r\n-        # Log available buttons and capture a screenshot\r\n-        log_available_buttons(job_card, job_title)\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    except Exception as e:\r\n-        print(f'Failed to apply to \"{job_title}\": {e}')\r\n-        capture_screenshot(f'error_applying_{sanitize_title(job_title)}', subfolder='easy_apply_errors')\r\n-\r\n-    finally:\r\n-        # Ensure that any new window is closed and focus is back to the original window\r\n-        if len(driver.window_handles) > 1:\r\n-            driver.close()\r\n-            driver.switch_to.window(original_window)\r\n-            print(f'Closed new window and switched back to original window after processing {job_title}')\r\n-\r\n-def main():\r\n-    applied_jobs = set()  # Track jobs that have been applied to\r\n-\r\n-    try:\r\n-        print('Navigating to Dice homepage.')\r\n-        # Enter search criteria\r\n-        driver.get('https://www.dice.com/')\r\n-        wait = WebDriverWait(driver, 20)  # Adjust timeout as needed\r\n-        print('Waiting for search field.')\r\n-        search_field = wait.until(EC.presence_of_element_located((By.ID, 'typeaheadInput')))\r\n-        search_field.clear()\r\n-        search_field.send_keys(SEARCH_TERMS)\r\n-        print(f'Entered search terms: {SEARCH_TERMS}')\r\n-\r\n-        print('Locating search button.')\r\n-        search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n-        search_button.click()\r\n-        print('Clicked search button.')\r\n-\r\n-        # Activate the \"Easy Apply\" filter\r\n-        activate_easy_apply_filter()\r\n-\r\n-        # Wait for job listings to load\r\n-        time.sleep(3)  # Add a small delay to ensure the page is loaded after applying the filter\r\n-\r\n-        # Get the list of job postings\r\n-        print('Locating job cards.')\r\n-        job_cards = driver.find_elements(By.XPATH, '//div[contains(@class, \"card\") and contains(@class, \"search-card\")]')\r\n-        print(f'Found {len(job_cards)} job postings.')\r\n-\r\n-        for index, job_card in enumerate(job_cards, start=1):\r\n-            try:\r\n-                # Extract the job title using data-cy attribute\r\n-                print(f'Processing job {index}.')\r\n-                title_element = job_card.find_element(By.XPATH, './/a[@data-cy=\"card-title-link\"]')\r\n-                job_title = title_element.text.strip()\r\n-                print(f'Job {index}: Found title: {job_title}')\r\n-\r\n-            except NoSuchElementException:\r\n-                print(f'Job {index}: Title element not found.')\r\n-                # Debugging: Print the outer HTML of the job card\r\n-                job_card_html = job_card.get_attribute('outerHTML')\r\n-                print(f'Job {index} HTML: {job_card_html}')\r\n-                capture_screenshot(f'job_{index}_no_title', subfolder='job_card_errors')\r\n-                continue\r\n-\r\n-            print(f'Job {index}: Title=\"{job_title}\"')\r\n-\r\n-            # Simplified criteria for applying\r\n-            if 'angular' in job_title.lower() and ('lead' in job_title.lower() or 'senior' in job_title.lower() or 'frontend' in job_title.lower()):\r\n-                print(f'Applying to job: {job_title}')\r\n-                apply_to_job(job_card, job_title, applied_jobs)\r\n-\r\n-                # Pause for specified duration before the next application\r\n-                print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n-                time.sleep(PAUSE_DURATION)\r\n-            else:\r\n-                print(f\"Skipping job: {job_title}\")\r\n-\r\n-        print(\"Job application process completed.\")\r\n-    except Exception as e:\r\n-        print(f\"An error occurred in main(): {e}\")\r\n-        capture_screenshot('main_exception', subfolder='main_errors')\r\n-    finally:\r\n-        driver.quit()\r\n-\r\n-# -----------------------------\r\n-# Entry Point\r\n-# -----------------------------\r\n-\r\n-if __name__ == '__main__':\r\n-    main()\r\n"
                }
            ],
            "date": 1726887760936,
            "name": "Commit-0",
            "content": "# job_application_automator.py\r\n\r\nimport configparser\r\nimport logging\r\nimport time\r\nfrom selenium import webdriver\r\nfrom selenium.webdriver.common.by import By\r\nfrom selenium.webdriver.chrome.options import Options\r\n\r\n# Load configuration\r\nconfig = configparser.ConfigParser()\r\nconfig.read('config.ini')\r\n\r\nSEARCH_TERMS = config['DEFAULT']['SearchTerms']\r\nRESUME_PATH = config['DEFAULT']['ResumePath']\r\nPAUSE_DURATION = int(config['DEFAULT']['PauseDuration'])\r\nEMAIL = config['DEFAULT']['Email']\r\nPASSWORD = config['DEFAULT']['Password']\r\n\r\n# Configure logging\r\nlogging.basicConfig(filename='application_log.txt', level=logging.INFO)\r\n\r\n# Set up Chrome options\r\nchrome_options = Options()\r\n# Uncomment the following line to run the browser in headless mode\r\n# chrome_options.add_argument('--headless')\r\n\r\n# Initialize the WebDriver\r\ndriver = webdriver.Chrome(options=chrome_options)\r\n\r\n# Maximize window\r\ndriver.maximize_window()\r\n\r\ndef login_to_dice():\r\n    driver.get('https://www.dice.com/dashboard/login')\r\n    time.sleep(3)\r\n    email_field = driver.find_element(By.ID, 'email')\r\n    email_field.clear()\r\n    email_field.send_keys(EMAIL)\r\n    password_field = driver.find_element(By.ID, 'password')\r\n    password_field.clear()\r\n    password_field.send_keys(PASSWORD)\r\n    login_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Sign In\")]')\r\n    login_button.click()\r\n    time.sleep(5)\r\n\r\ndef apply_to_job(job_link):\r\n    driver.get(job_link)\r\n    time.sleep(2)  # Wait for the page to load\r\n\r\n    try:\r\n        # Find the 'Apply' button; update the XPath if necessary\r\n        apply_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Easy Apply\")]')\r\n        apply_button.click()\r\n        time.sleep(2)\r\n\r\n        # Upload resume\r\n        upload_field = driver.find_element(By.NAME, 'resume')\r\n        upload_field.send_keys(RESUME_PATH)\r\n        time.sleep(2)\r\n\r\n        # Submit application\r\n        submit_button = driver.find_element(By.XPATH, '//button[contains(text(), \"Submit\")]')\r\n        submit_button.click()\r\n        logging.info(f'Successfully applied to {job_link}')\r\n        print(f\"Successfully applied to {job_link}\")\r\n    except Exception as e:\r\n        logging.error(f'Failed to apply to {job_link}: {e}')\r\n        print(f\"Failed to apply to {job_link}: {e}\")\r\n\r\ndef main():\r\n    login_to_dice()\r\n\r\n    # Enter search criteria\r\n    driver.get('https://www.dice.com/')\r\n    time.sleep(3)\r\n    search_field = driver.find_element(By.ID, 'typeaheadInput')\r\n    search_field.clear()\r\n    search_field.send_keys(SEARCH_TERMS)\r\n    search_button = driver.find_element(By.ID, 'submitSearch-button')\r\n    search_button.click()\r\n    time.sleep(5)\r\n\r\n    # Get the list of job postings\r\n    jobs = driver.find_elements(By.XPATH, '//a[@data-cy=\"card-title-link\"]')\r\n\r\n    for index, job in enumerate(jobs):\r\n        job_title = job.text\r\n\r\n        # Check if the job title contains both \"Angular\" and \"Senior Frontend Developer\"\r\n        if 'Angular' in job_title and 'Senior Frontend Developer' in job_title:\r\n            print(f\"Applying to job: {job_title}\")\r\n            job_link = job.get_attribute('href')\r\n            apply_to_job(job_link)\r\n\r\n            # Pause for specified duration before the next application\r\n            print(f\"Waiting for {PAUSE_DURATION} seconds before the next application...\")\r\n            time.sleep(PAUSE_DURATION)\r\n        else:\r\n            print(f\"Skipping job: {job_title}\")\r\n\r\n    print(\"Job application process completed.\")\r\n\r\nif __name__ == '__main__':\r\n    try:\r\n        main()\r\n    finally:\r\n        driver.quit()\r\n"
        }
    ]
}